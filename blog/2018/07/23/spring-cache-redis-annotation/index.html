<!doctype html>



  


<html class="theme-next pisces use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.useso.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="spring,redis,cache," />





  <link rel="alternate" href="/atom.xml" title="申艳超-博客" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="前言：
spring-data-redis使得Spring项目可以快速简单的通过RedisTemplate来操作Redis。而spring-boot-starter-data-redis更是让redis集成更加的方便。

SpringBoot如何与Redis集成，作为cacheapplication.xml里如下配置：
spring:
     redis:
       host: 127.0.">
<meta property="og:type" content="article">
<meta property="og:title" content="Spring Redis 注解式Cache那些事">
<meta property="og:url" content="https://www.shenyanchao.cn/blog/2018/07/23/spring-cache-redis-annotation/index.html">
<meta property="og:site_name" content="申艳超-博客">
<meta property="og:description" content="前言：
spring-data-redis使得Spring项目可以快速简单的通过RedisTemplate来操作Redis。而spring-boot-starter-data-redis更是让redis集成更加的方便。

SpringBoot如何与Redis集成，作为cacheapplication.xml里如下配置：
spring:
     redis:
       host: 127.0.">
<meta property="og:updated_time" content="2018-10-23T08:36:10.153Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Spring Redis 注解式Cache那些事">
<meta name="twitter:description" content="前言：
spring-data-redis使得Spring项目可以快速简单的通过RedisTemplate来操作Redis。而spring-boot-starter-data-redis更是让redis集成更加的方便。

SpringBoot如何与Redis集成，作为cacheapplication.xml里如下配置：
spring:
     redis:
       host: 127.0.">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>

  <title> Spring Redis 注解式Cache那些事 | 申艳超-博客 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?81c9612f8fdceca45435ef7f5404d7b2";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>








  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">申艳超-博客</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">搜索引擎、自然语言处理、ElasticSearch、Solr</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404.html" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            公益404
          </a>
        </li>
      
        
        <li class="menu-item menu-item-douban">
          <a href="/douban" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            豆瓣读书
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                Spring Redis 注解式Cache那些事
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-07-23T17:05:00+08:00" content="2018-07-23">
              2018-07-23
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/spring/" itemprop="url" rel="index">
                    <span itemprop="name">spring</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/blog/2018/07/23/spring-cache-redis-annotation/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="blog/2018/07/23/spring-cache-redis-annotation/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><blockquote>
<p>spring-data-redis使得Spring项目可以快速简单的通过RedisTemplate来操作Redis。而spring-boot-starter-data-redis更是让redis集成更加的方便。</p>
</blockquote>
<h3 id="SpringBoot如何与Redis集成，作为cache"><a href="#SpringBoot如何与Redis集成，作为cache" class="headerlink" title="SpringBoot如何与Redis集成，作为cache"></a>SpringBoot如何与Redis集成，作为cache</h3><p>application.xml里如下配置：</p>
<pre><code>spring:
     redis:
       host: 127.0.0.1
       port: 6379
       database: 0
       timeout: 1000
       pool:
             max-idle: 200
             min-idle: 0
             max-active: 200
             max-wait: 1000
</code></pre><p>spring boot可以自动组装相关配置，注意其中使用到了jedis pool，用于提升性能，非必须。<br>通过以下的annotation加入方法名上，可以无侵入的使用cache。</p>
<ul>
<li>@Cacheable   缓存</li>
<li>@CachePut    设置缓存</li>
<li>@CacheEvict  失效或更新缓存</li>
<li><p>@Caching   组合操作</p>
<p>以上annotation不做详细展开。</p>
<a id="more"></a>
<p>做到上面似乎已经可以了，但有一些问题需要我们来解决。</p>
</li>
</ul>
<ul>
<li>a.redis连接报错\超时怎么办？此时应该是可降级的。</li>
<li>b.使用连接池，连接不可用如何破？</li>
</ul>
<p>下面贴一个比较成熟的做法，继承<code>CachingConfigurerSupport</code>：</p>
<pre><code>@Configuration
@EnableCaching //启用
public class RedisConfig extends CachingConfigurerSupport {

    // 过期时间
    private static final long expire = 600;

    // application.yml配置参数有限，注入并扩展用。
    @Autowired
    private RedisProperties redisProperties;

    //此处自定义jedis pool配置，设置TestOnBrrow等等
    @Bean
    public JedisPoolConfig jedisPoolConfig() {
        JedisPoolConfig jedisPoolConfig = new JedisPoolConfig();
        RedisProperties.Pool pool = redisProperties.getPool();
        jedisPoolConfig.setMaxIdle(pool.getMaxIdle());
        jedisPoolConfig.setMaxTotal(pool.getMaxActive());
        jedisPoolConfig.setMinIdle(pool.getMinIdle());
        jedisPoolConfig.setMaxWaitMillis(pool.getMaxWait());
        jedisPoolConfig.setTestOnBorrow(true);
        jedisPoolConfig.setTestWhileIdle(true);
        return jedisPoolConfig;
    }

   //生成redisConnectionFactory，使用自定义的jedis pool
    @Bean
    public RedisConnectionFactory redisConnectionFactory(JedisPoolConfig jedisPoolConfig) {
        JedisConnectionFactory jedisConnectionFactory = new JedisConnectionFactory();
        jedisConnectionFactory.setHostName(redisProperties.getHost());
        jedisConnectionFactory.setPort(redisProperties.getPort());
        jedisConnectionFactory.setDatabase(redisProperties.getDatabase());
        jedisConnectionFactory.setTimeout(redisProperties.getTimeout());
        if (null != redisProperties.getPassword()) {
            jedisConnectionFactory.setPassword(redisProperties.getPassword());
        }
        jedisConnectionFactory.setPoolConfig(jedisPoolConfig);
        return jedisConnectionFactory;
    }

    // 设置cacheManager相关，主要涉及默认过期时间。
    @Bean
    public CacheManager cacheManager(RedisTemplate redisTemplate) {
        RedisCacheManager cacheManager = new RedisCacheManager(redisTemplate);
        //设置缓存过期时间，可单独对某个cache制定过期时间
        cacheManager.setDefaultExpiration(expire);
        //设置redis key是否使用前缀，默认前缀是cacheName
        cacheManager.setUsePrefix(true);
        return cacheManager;
    }

    //定义redisTemplate，主要是定义key\value的序列化器
    @Bean
    public RedisTemplate&lt;String, String&gt; redisTemplate(RedisConnectionFactory redisConnectionFactory) {
        StringRedisTemplate template = new StringRedisTemplate(redisConnectionFactory);
        template.setValueSerializer(getValueSerializer());
        template.afterPropertiesSet();
        return template;
    }

    private RedisSerializer getValueSerializer() {
        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class);
        ObjectMapper om = new ObjectMapper();
        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);
        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);
        jackson2JsonRedisSerializer.setObjectMapper(om);
        return jackson2JsonRedisSerializer;
    }

    // 设置redis key生成策略
    @Bean
    @Override
    public KeyGenerator keyGenerator() {
        return new RequestKeyGenerator();
    }

    // 重点：设置和redis交互报错时的错误处理器。
    @Bean
    @Override
    public CacheErrorHandler errorHandler() {
        return new CallbackCacheErrorHandler();
    }
</code></pre><p>下面看一下<code>CallbackCacheErrorHandler</code>    :</p>
<pre><code>public class CallbackCacheErrorHandler implements CacheErrorHandler {

    private static final Logger LOGGER = LoggerFactory.getLogger(CallbackCacheErrorHandler.class);

    @Override
    public void handleCacheGetError(RuntimeException exception, Cache cache, Object key) {
        LOGGER.error(&quot;cache get error, cacheName:{}, key:{}, msg:&quot;, cache.getName(), key, exception);
    }

    @Override
    public void handleCachePutError(RuntimeException exception, Cache cache, Object key, Object value) {
        LOGGER.error(&quot;cache put error, cacheName:{}, key:{}, msg:&quot;, cache.getName(), key, exception);

    }

    @Override
    public void handleCacheEvictError(RuntimeException exception, Cache cache, Object key) {
        LOGGER.error(&quot;cache evict error, cacheName:{}, key:{}, msg:&quot;, cache.getName(), key, exception);

    }

    @Override
    public void handleCacheClearError(RuntimeException exception, Cache cache) {
        LOGGER.error(&quot;cache clear error, cacheName:{}, msg:&quot;, cache.getName(), exception);
    }
}
</code></pre><p>此处当报错的时候只进行了日志记录，当然如果有其他需求，都可以在这里扩展。自此，spring boot与redis集成大功告成，一切都是那么的完美。</p>
<h3 id="关于RedisCacheManager是否setUsePrefix的坑"><a href="#关于RedisCacheManager是否setUsePrefix的坑" class="headerlink" title="关于RedisCacheManager是否setUsePrefix的坑"></a>关于RedisCacheManager是否<code>setUsePrefix</code>的坑</h3><p>首先，我们要知道是否使用<code>prefix</code>的区别是什么？<br>区别如下：</p>
<ul>
<li><ol>
<li>使用<code>prefix</code>的时候，redis cache的key都会默认添加上cacheName，用于区分不同的cache。</li>
</ol>
</li>
<li><ol>
<li>使用<code>prefix</code>的时候，当清除或者失效所有的key的时候，使用的是key prefix*获取所有的key,然后依次清楚。而不使用<code>prefix</code>的时候，需要清除或者失效所有key的时候，则是从一个维护了所有key的zset中获取的，这个zset通常叫做<code>${cacheName}~keys</code>。</li>
</ol>
</li>
</ul>
<p>下面通过源代码来证实一下：<br>RedisCache.java内<code>RedisWriteThroughCallback</code>负责往redis设置缓存：</p>
<pre><code>    static class RedisWriteThroughCallback extends AbstractRedisCacheCallback&lt;byte[]&gt; {

    public RedisWriteThroughCallback(BinaryRedisCacheElement element, RedisCacheMetadata metadata) {
        super(element, metadata);
    }

    @Override
    public byte[] doInRedis(BinaryRedisCacheElement element, RedisConnection connection) throws DataAccessException {

        try {
          //加锁
            lock(connection);

            try {

                byte[] value = connection.get(element.getKeyBytes());

                if (value != null) {
                    return value;
                }

                if (!isClusterConnection(connection)) {

                    connection.watch(element.getKeyBytes());
                    // 开始事务
                    connection.multi();
                }

                value = element.get();

                if (value.length == 0) {
                    connection.del(element.getKeyBytes());
                } else {
                   // 设置缓存key-value
                    connection.set(element.getKeyBytes(), value);
                    // 设置失效日期
                    processKeyExpiration(element, connection);
                    // 维护key到已知zset内
                    maintainKnownKeys(element, connection);
                }

                if (!isClusterConnection(connection)) {
                    connection.exec();
                }

                return value;
            } catch (RuntimeException e) {
                if (!isClusterConnection(connection)) {
                    connection.discard();
                }
                throw e;
            }
        } finally {
           // 释放锁
            unlock(connection);
        }
    }
};

 protected void maintainKnownKeys(RedisCacheElement element, RedisConnection connection) {

        if (!element.hasKeyPrefix()) { //不使用prefix
          // 则zadd到已知的key集合内
            connection.zAdd(cacheMetadata.getSetOfKnownKeysKey(), 0, element.getKeyBytes());

            if (!element.isEternal()) {
                connection.expire(cacheMetadata.getSetOfKnownKeysKey(), element.getTimeToLive());
            }
        }
    }
</code></pre><p>从上面分析得知，设置缓存的时候有以下几步：</p>
<ul>
<li>1.设置key-value</li>
<li>2.设置key的过期时间</li>
<li>3.维护key到已知key的zset列表</li>
</ul>
<p>清理所有key的时候，是怎么操作的呢？</p>
<pre><code>public void clear() {
    redisOperations.execute(cacheMetadata.usesKeyPrefix() ? new RedisCacheCleanByPrefixCallback(cacheMetadata)
            : new RedisCacheCleanByKeysCallback(cacheMetadata));
}
</code></pre><p>可以看出依据是否使用前缀，使用不同的回调方法。</p>
<pre><code>/**
 * @author Christoph Strobl
 * @since 1.5
 */
static class RedisCacheCleanByKeysCallback extends LockingRedisCacheCallback&lt;Void&gt; {

    private static final int PAGE_SIZE = 128;
    private final RedisCacheMetadata metadata;

    RedisCacheCleanByKeysCallback(RedisCacheMetadata metadata) {
        super(metadata);
        this.metadata = metadata;
    }

    /*
     * (non-Javadoc)
     * @see org.springframework.data.redis.cache.RedisCache.LockingRedisCacheCallback#doInLock(org.springframework.data.redis.connection.RedisConnection)
     */
    @Override
    public Void doInLock(RedisConnection connection) {

        int offset = 0;
        boolean finished = false;

        do {
            // need to paginate the keys
            Set&lt;byte[]&gt; keys = connection.zRange(metadata.getSetOfKnownKeysKey(), (offset) * PAGE_SIZE,
                    (offset + 1) * PAGE_SIZE - 1);  //使用zrange遍历，删除
            finished = keys.size() &lt; PAGE_SIZE;
            offset++;
            if (!keys.isEmpty()) {
                connection.del(keys.toArray(new byte[keys.size()][]));
            }
        } while (!finished);

        connection.del(metadata.getSetOfKnownKeysKey());
        return null;
    }
}

/**
 * @author Christoph Strobl
 * @since 1.5
 */
static class RedisCacheCleanByPrefixCallback extends LockingRedisCacheCallback&lt;Void&gt; {

    private static final byte[] REMOVE_KEYS_BY_PATTERN_LUA = new StringRedisSerializer().serialize(
            &quot;local keys = redis.call(&apos;KEYS&apos;, ARGV[1]); local keysCount = table.getn(keys); if(keysCount &gt; 0) then for _, key in ipairs(keys) do redis.call(&apos;del&apos;, key); end; end; return keysCount;&quot;);
    private static final byte[] WILD_CARD = new StringRedisSerializer().serialize(&quot;*&quot;);
    private final RedisCacheMetadata metadata;

    public RedisCacheCleanByPrefixCallback(RedisCacheMetadata metadata) {
        super(metadata);
        this.metadata = metadata;
    }

    /*
     * (non-Javadoc)
     * @see org.springframework.data.redis.cache.RedisCache.LockingRedisCacheCallback#doInLock(org.springframework.data.redis.connection.RedisConnection)
     */
    @Override
    public Void doInLock(RedisConnection connection) throws DataAccessException {

        byte[] prefixToUse = Arrays.copyOf(metadata.getKeyPrefix(), metadata.getKeyPrefix().length + WILD_CARD.length);
        System.arraycopy(WILD_CARD, 0, prefixToUse, metadata.getKeyPrefix().length, WILD_CARD.length);

        if (isClusterConnection(connection)) {

            // load keys to the client because currently Redis Cluster connections do not allow eval of lua scripts.
            Set&lt;byte[]&gt; keys = connection.keys(prefixToUse);  //集群模式下，使用keys获取所有的key
            if (!keys.isEmpty()) {
                connection.del(keys.toArray(new byte[keys.size()][]));
            }
        } else {
           // 非集群模式下，使用LUA脚本，keys删除。
            connection.eval(REMOVE_KEYS_BY_PATTERN_LUA, ReturnType.INTEGER, 0, prefixToUse);
        }

        return null;
    }
}
</code></pre><p>从以上源码可以看出使用prefix的区别。总结下，坑在哪儿，应该如何根据业务来选择。</p>
<ul>
<li>坑1：不使用<code>prefix</code>,需要额外的zset来保存已知key集合，风险点是zset有可能很大，占用空间，如果被置换出去，功能则不一致</li>
<li>坑2：使用<code>prefix</code>, 没有额外的zset。但是失效或者清理所有key的时候，使用<code>keys *</code>可能导致redis被拖死，清理时间内无响应。</li>
<li>坑3：设置缓存，使用了multi，对redis压力不小，高并发下尤其明显，需要注意。</li>
</ul>
<h3 id="关于Redis-Cache默认使用lock的问题"><a href="#关于Redis-Cache默认使用lock的问题" class="headerlink" title="关于Redis Cache默认使用lock的问题"></a>关于Redis Cache默认使用lock的问题</h3><p>在高并发下，发现spring redis cache的put效率并不高，经过排查发现put操作有lock机制，切lock时间无法更改。</p>
<p>如上<code>RedisWriteThroughCallback</code>所示，有lock和unlock操作，其实就是往redis写一个key作为lock, 删除这个key作为unlock。这个操作在分布式系统中，可以保证其一致性，但是也损失了性能。尤其在仅作为缓存使用的场景，key对应的value具备幂等性，完全可以忽略。</p>
<p>源码重点在这个<code>waitForLock</code>方法里：</p>
<pre><code>  protected boolean waitForLock(RedisConnection connection) {

      boolean retry;
      boolean foundLock = false;
      do {
          retry = false;
          if (connection.exists(cacheMetadata.getCacheLockKey())) {
              foundLock = true;
              try {
                  Thread.sleep(WAIT_FOR_LOCK_TIMEOUT); //此处WAIT_FOR_LOCK_TIMEOUT=300ms
              } catch (InterruptedException ex) {
                  Thread.currentThread().interrupt();
              }
              retry = true;
          }
      } while (retry);

      return foundLock;
  }

 // 加锁
  protected void lock(RedisConnection connection) {
      waitForLock(connection);
      connection.set(cacheMetadata.getCacheLockKey(), &quot;locked&quot;.getBytes());
  }
// 解锁
  protected void unlock(RedisConnection connection) {
      connection.del(cacheMetadata.getCacheLockKey());
  }
</code></pre><p>可以看出每次加锁，如果lock已经存在的情况下，会额外sleep 300ms,这在高并发、高性能的缓存场景是<strong>极其低效</strong>的。并且在极端情况下，unlock删除key没成功，将会导致所有key都无法设置或更新,并陷入死循环。spring内部也没有提供相关的行为覆盖机制，这是一个较大的坑。</p>
<h3 id="Spring-Data-Redis-2-0-RC1的优化"><a href="#Spring-Data-Redis-2-0-RC1的优化" class="headerlink" title="Spring-Data-Redis 2.0 RC1的优化"></a>Spring-Data-Redis 2.0 RC1的优化</h3><p><a href="https://jira.spring.io/browse/DATAREDIS-481" target="_blank" rel="external">官方DATAREDIS-481</a>注意到了Lock的优化，并对cache manager做了颠覆性的升级。<br>下面跟着我来看看，spring-data-redis 2.0之后如何使用注解式cache.<br>由于底层依赖的<a href="https://github.com/xetorthio/jedis" target="_blank" rel="external">Jedis</a>,自从发布2.9.0版本之后，升级缓慢，目前也仅支持到2.8.x和3.x.x版本，所以Spring推荐使用<a href="https://github.com/lettuce-io/lettuce-core" target="_blank" rel="external">lettuce</a>.</p>
<p>先看application.xml里如何写：</p>
<pre><code>spring:
    redis:
      host: 127.0.0.1
      database: 0
      port: 6379
      timeout: 1000
      lettuce:
        pool:
          max-active: 500
          min-idle: 0
          max-idle: 500
          max-wait: 1000
</code></pre><p>开始使用lettuce了，jedis提示deprecated了。<br>pool提供的参数有限，如果想自己定制，参见如下设置：</p>
<pre><code>   //继承CachingConfigurerSupport
@Configuration
@EnableCaching
public class RedisConfig extends CachingConfigurerSupport {

    //注入默认参数
    @Autowired
    private RedisProperties redisProperties;
    //默认超时
    private long expire = 600L;

    @Bean
    public RedisConnectionFactory redisConnectionFactory() {
        //commons-pool2包
        GenericObjectPoolConfig poolConfig = new GenericObjectPoolConfig();
        poolConfig.setMaxIdle(500);
        poolConfig.setMinIdle(0);
        poolConfig.setMaxTotal(500);
        poolConfig.setMaxWaitMillis(1000);
        poolConfig.setTestOnBorrow(true);   //额外设置

        // 基本连接信息：host port database password
        RedisStandaloneConfiguration redisStandaloneConfiguration = new RedisStandaloneConfiguration();
        redisStandaloneConfiguration.setHostName(redisProperties.getHost());
        redisStandaloneConfiguration.setPort(redisProperties.getPort());
        redisStandaloneConfiguration.setDatabase(redisProperties.getDatabase());
        if (null != redisProperties.getPassword()){
            redisStandaloneConfiguration.setPassword(RedisPassword.of(redisProperties.getPassword()));
        }

        //这里单独配置超时时间，连接池管理
        LettuceClientConfiguration lettuceClientConfiguration = LettucePoolingClientConfiguration.builder()
                .commandTimeout(Duration.ofMillis(200)).shutdownTimeout(Duration.ofMillis(200)).poolConfig
                        (poolConfig)
                .build();
        LettuceConnectionFactory lettuceConnectionFactory = new LettuceConnectionFactory
                (redisStandaloneConfiguration, lettuceClientConfiguration);
        lettuceConnectionFactory.setValidateConnection(true);
        return lettuceConnectionFactory;
    }

    @Bean
    public CacheManager cacheManager(RedisConnectionFactory redisConnectionFactory) {
        // 默认配置使用prefix、单独设置valueSerializer、过期时间
        RedisCacheConfiguration redisCacheConfiguration =
                RedisCacheConfiguration.defaultCacheConfig().serializeValuesWith(
                        RedisSerializationContext.SerializationPair.fromSerializer(getValueSerializer()))
                        .entryTtl(Duration.ofSeconds
                                (expire)).disableCachingNullValues();
        // 使用redisConnectionFactory直接创建无锁的cm
        RedisCacheManager cm = RedisCacheManager.builder(RedisCacheWriter.nonLockingRedisCacheWriter(redisConnectionFactory)).cacheDefaults(redisCacheConfiguration).transactionAware().build();
        return cm;
    }

    private RedisSerializer getValueSerializer() {
        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class);
        ObjectMapper om = new ObjectMapper();
        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);
        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);
        jackson2JsonRedisSerializer.setObjectMapper(om);
        return jackson2JsonRedisSerializer;
    }

    @Bean
    @Override
    public CacheErrorHandler errorHandler() {
        return new RedisCacheErrorHandler();
    }

    @Override
    public KeyGenerator keyGenerator() {
        return new MyKeyGenerator()
    }
</code></pre><p>从上面可以看出，基本操作是一致的，但是RedisCacheManager创建更加优雅，不在直接依赖redisTemplate。<br>关于是否使用prefix问题，<code>RedisCacheConfiguration.defaultCacheConfig()</code>中代码如下：</p>
<pre><code>private RedisCacheConfiguration(Duration ttl, Boolean cacheNullValues, Boolean usePrefix,
        CacheKeyPrefix keyPrefix, SerializationPair&lt;String&gt; keySerializationPair,
        SerializationPair&lt;?&gt; valueSerializationPair, ConversionService conversionService) {

    this.ttl = ttl;
    this.cacheNullValues = cacheNullValues;
    this.usePrefix = usePrefix;
    this.keyPrefix = keyPrefix;
    this.keySerializationPair = keySerializationPair;
    this.valueSerializationPair = (SerializationPair&lt;Object&gt;) valueSerializationPair;
    this.conversionService = conversionService;
}


public static RedisCacheConfiguration defaultCacheConfig() {

    DefaultFormattingConversionService conversionService = new DefaultFormattingConversionService();

    registerDefaultConverters(conversionService);
   // 默认usePrefix为true,是推荐的
    return new RedisCacheConfiguration(Duration.ZERO, true, true, CacheKeyPrefix.simple(),
            SerializationPair.fromSerializer(new StringRedisSerializer()),
            SerializationPair.fromSerializer(new JdkSerializationRedisSerializer()), conversionService);
}
</code></pre><p>当然也是可以覆盖禁用的，使用<code>disableKeyPrefix</code>, 但明确提出，你需要特别注意，不建议使用。</p>
<p>关于是否使用lock的问题，新版本也提供了可选方案。通过<code>RedisCacheWriter</code>来实现：</p>
<pre><code>static RedisCacheWriter nonLockingRedisCacheWriter(RedisConnectionFactory connectionFactory) {

    Assert.notNull(connectionFactory, &quot;ConnectionFactory must not be null!&quot;);

    return new DefaultRedisCacheWriter(connectionFactory);
}

static RedisCacheWriter lockingRedisCacheWriter(RedisConnectionFactory connectionFactory) {

    Assert.notNull(connectionFactory, &quot;ConnectionFactory must not be null!&quot;);

    return new DefaultRedisCacheWriter(connectionFactory, Duration.ofMillis(50));
}
</code></pre><p>可以看出lockingRedisCacheWriter将会有sleep 50ms来处理锁,nonlocking则没有加锁等待，给用户提供了更好的处理方案。</p>
<p>关于全部失效或者清理key的问题，2.0版本处理方案如下：</p>
<pre><code>@Override
public void clean(String name, byte[] pattern) {

    Assert.notNull(name, &quot;Name must not be null!&quot;);
    Assert.notNull(pattern, &quot;Pattern must not be null!&quot;);

    execute(name, connection -&gt; {

        boolean wasLocked = false;

        try {

            if (isLockingCacheWriter()) {
                doLock(name, connection);
                wasLocked = true;
            }
         // 这里仍旧是使用的keys操作
            byte[][] keys = Optional.ofNullable(connection.keys(pattern)).orElse(Collections.emptySet())
                    .toArray(new byte[0][]);

            if (keys.length &gt; 0) {
                connection.del(keys);
            }
        } finally {

            if (wasLocked &amp;&amp; isLockingCacheWriter()) {
                doUnlock(name, connection);
            }
        }

        return &quot;OK&quot;;
    });
}
</code></pre><p>这里仍旧使用的是<code>keys</code>命令，坑仍在。后续使用<code>scan</code>操作也许是更好的选择，但最终还是要依据自己的业务需求来定制。</p>
<p>总结：</p>
<blockquote>
<p><strong>开源项目的坑无处不在，即使是spring</strong>。<br>无论是什么版本，使用<code>prefix</code>是更好的选择，也是趋势所在。<br>keys操作对性能的影响始终未能彻底消除，建议使用key expire机制来规避。（生产环境keys操作也是尽可能要避免的）。<br>redis缓存key的大小，无论是性能还是存储的影响都很大，强烈建议在业务允许范围内尽可能减小key的大小(比如使用MD5,有一定碰撞率)。</p>
</blockquote>

      
    </div>

    <div>
      
        
      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/spring/" rel="tag">#spring</a>
          
            <a href="/tags/redis/" rel="tag">#redis</a>
          
            <a href="/tags/cache/" rel="tag">#cache</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/blog/2015/11/03/restful-springmvc/" rel="next" title="Restful Spring MVC">
                <i class="fa fa-chevron-left"></i> Restful Spring MVC
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/blog/2018/08/23/the-principle-of-api-design-in-mircoservice/" rel="prev" title="微服务下的API设计原则">
                微服务下的API设计原则 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
        
  <div class="bdsharebuttonbox">
    <a href="#" class="bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a>
    <a href="#" class="bds_douban" data-cmd="douban" title="分享到豆瓣网"></a>
    <a href="#" class="bds_sqq" data-cmd="sqq" title="分享到QQ好友"></a>
    <a href="#" class="bds_qzone" data-cmd="qzone" title="分享到QQ空间"></a>
    <a href="#" class="bds_weixin" data-cmd="weixin" title="分享到微信"></a>
    <a href="#" class="bds_tieba" data-cmd="tieba" title="分享到百度贴吧"></a>
    <a href="#" class="bds_twi" data-cmd="twi" title="分享到Twitter"></a>
    <a href="#" class="bds_fbook" data-cmd="fbook" title="分享到Facebook"></a>
    <a href="#" class="bds_more" data-cmd="more"></a>
    <a class="bds_count" data-cmd="count"></a>
  </div>
  <script>
    window._bd_share_config = {
      "common": {
        "bdText": "",
        "bdMini": "2",
        "bdMiniList": false,
        "bdPic": ""
      },
      "share": {
        "bdSize": "16",
        "bdStyle": "0"
      },
      "image": {
        "viewList": ["tsina", "douban", "sqq", "qzone", "weixin", "twi", "fbook"],
        "viewText": "分享到：",
        "viewSize": "16"
      }
    }
  </script>

<script>
  with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?cdnversion='+~(-new Date()/36e5)];
</script>

      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="https://avatars0.githubusercontent.com/u/2255020?v=3&s=460"
               alt="申艳超" />
          <p class="site-author-name" itemprop="name">申艳超</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">108</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">35</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">196</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/blueshen" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
          
        </div>

        
        

        
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#前言："><span class="nav-number">1.</span> <span class="nav-text">前言：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SpringBoot如何与Redis集成，作为cache"><span class="nav-number">2.</span> <span class="nav-text">SpringBoot如何与Redis集成，作为cache</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#关于RedisCacheManager是否setUsePrefix的坑"><span class="nav-number">3.</span> <span class="nav-text">关于RedisCacheManager是否setUsePrefix的坑</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#关于Redis-Cache默认使用lock的问题"><span class="nav-number">4.</span> <span class="nav-text">关于Redis Cache默认使用lock的问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Spring-Data-Redis-2-0-RC1的优化"><span class="nav-number">5.</span> <span class="nav-text">Spring-Data-Redis 2.0 RC1的优化</span></a></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2012 - 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">申艳超</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.0.1"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  

    <script type="text/javascript">
      var disqus_shortname = 'blueshen';
      var disqus_identifier = 'blog/2018/07/23/spring-cache-redis-annotation/';
      var disqus_title = 'Spring Redis 注解式Cache那些事';
      var disqus_url = 'https://www.shenyanchao.cn/blog/2018/07/23/spring-cache-redis-annotation/';

      function run_disqus_script(disqus_script){
        var dsq = document.createElement('script');
        dsq.type = 'text/javascript';
        dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      }

      run_disqus_script('count.js');
      
        run_disqus_script('embed.js');
      
    </script>
  



  
  
  

  

  
<script type="text/javascript" async src="//push.zhanzhang.baidu.com/push.js">
</script>


</body>
</html>
