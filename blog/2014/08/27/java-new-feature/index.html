<!doctype html>



  


<html class="theme-next pisces use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.useso.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="java7,java8," />





  <link rel="alternate" href="/atom.xml" title="申艳超-博客" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="##Java7新特性
###Java7语法特性根据JSR 334，Java7添加了数个语法方面的新特性：
####1. switch可以消化String
比如：
public static void switchString(String s){
    switch (s){
    case &amp;quot;db&amp;quot;: ...
    case &amp;quot;wls&amp;quot;: ...">
<meta property="og:type" content="article">
<meta property="og:title" content="Java新特性">
<meta property="og:url" content="http://www.shenyanchao.cn/blog/2014/08/27/java-new-feature/index.html">
<meta property="og:site_name" content="申艳超-博客">
<meta property="og:description" content="##Java7新特性
###Java7语法特性根据JSR 334，Java7添加了数个语法方面的新特性：
####1. switch可以消化String
比如：
public static void switchString(String s){
    switch (s){
    case &amp;quot;db&amp;quot;: ...
    case &amp;quot;wls&amp;quot;: ...">
<meta property="og:updated_time" content="2018-10-22T09:30:45.564Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java新特性">
<meta name="twitter:description" content="##Java7新特性
###Java7语法特性根据JSR 334，Java7添加了数个语法方面的新特性：
####1. switch可以消化String
比如：
public static void switchString(String s){
    switch (s){
    case &amp;quot;db&amp;quot;: ...
    case &amp;quot;wls&amp;quot;: ...">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>

  <title> Java新特性 | 申艳超-博客 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?81c9612f8fdceca45435ef7f5404d7b2";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>








  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">申艳超-博客</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">搜索引擎、自然语言处理、ElasticSearch、Solr</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404.html" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            公益404
          </a>
        </li>
      
        
        <li class="menu-item menu-item-douban">
          <a href="/douban" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            豆瓣读书
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                Java新特性
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2014-08-27T14:43:00+08:00" content="2014-08-27">
              2014-08-27
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/blog/2014/08/27/java-new-feature/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="blog/2014/08/27/java-new-feature/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>##Java7新特性</p>
<p>###Java7语法特性<br>根据JSR 334，Java7添加了数个语法方面的新特性：</p>
<p>####1. switch可以消化String</p>
<p>比如：</p>
<pre><code>public static void switchString(String s){
    switch (s){
    case &quot;db&quot;: ...
    case &quot;wls&quot;: ...
    case &quot;ibm&quot;: ...
    case &quot;soa&quot;: ...
    case &quot;fa&quot;: ...
    default: ...
    }
}
</code></pre><a id="more"></a>
<p>####2. 新的整数字面表达方式 - “0b”前缀和”_”连数符，提升程序员的幸福感。</p>
<ul>
<li><p>a. 表示二进制字面值的前缀, 0b:<br>比如以下三个变量的值相同：</p>
<pre><code>byte b1 = 0b00100001;     // New
byte b2 = 0x21;        // Old
byte b3 = 33;        // Old
</code></pre></li>
<li><p>b. 用下划线连接整数提升其可读性，自身无含义，不可用在数字的起始和末尾：</p>
<pre><code>long phone_nbr = 021_1111_2222;
</code></pre></li>
</ul>
<p>####3. 简化了泛型对象创建的语法 - “菱形 new”，以下两个语句等价：</p>
<pre><code>ArrayList&lt;String&gt; al1 = new ArrayList&lt;String&gt;();    // Old
ArrayList&lt;String&gt; al2 = new ArrayList&lt;&gt;();        // New
</code></pre><p>####4. 为所有的reflect操作异常找了个新爸爸 - ReflectOperationException，孩儿们是：</p>
<pre><code>ClassNotFoundException, 
IllegalAccessException, 
InstantiationException, 
InvocationTargetException, 
NoSuchFieldException, 
NoSuchMethodException
</code></pre><p>####5. catch有了多重捕获功能，也玩起了包养的勾当，以下代码心领神会：</p>
<pre><code>try{
    // code
}
catch (SQLException | IOException ex) {
    // ...
}
</code></pre><p>####6. 异常精确重抛 - 重抛时自动造型为子类，有点半主动制导武器的style：</p>
<pre><code>public void test() throws NoSuchMethodException, NoSuchFieldException{    // 子类
    try{
        // code
    }
    catch (RelectiveOperationException ex){    // 父类
        throws ex;
    }
}
</code></pre><p>####7. 发明了try()结构 - Try with Resources，能够自动接住异常并关闭资源(所谓的资源需要利用新的java.lang.AutoCloseable接口)，注意以下代码中try后面跟的是”(“不是”{“：<br>    try(BufferedReader br = new BufferedReader(new FileReader(“/home/oracle/temp.txt”))){<br>        … br.readLine() …<br>    }<br>try-with-resources语句可以带catch，也可以向上例一样一个catch也没有。</p>
<p>###Java7 NIO 新方法<br>整体来说，对IO操作进行了优化，使用起来更加顺手，甚至可以替换apache common-io包。</p>
<p>####1.增加<code>java.nio.file.Paths</code>用于目录操作</p>
<pre><code>Path path = Paths.get(&quot;/home/shenyanchao&quot;, &quot;Desktop&quot;);
System.out.println(path.toAbsolutePath());
System.out.println(path.getParent());
System.out.println(path.getFileSystem().isOpen());
</code></pre><p>####2.增加<code>java.nio.file.Files</code>工具类来处理文件</p>
<pre><code>Files.copy(src,dest, StandardCopyOption.COPY_ATTRIBUTES,StandardCopyOption.REPLACE_EXISTING);

Files.move(src,dest,StandardCopyOption.ATOMIC_MOVE);

Files.createLink(src,dest);
Files.createSymbolicLink(src,dest);
Files.deleteIfExists(dest);

Files.readAllLines(src);

Files.createTempFile(src,&quot;aa&quot;,&quot;bb&quot;);
</code></pre><p>####3.目录树遍历<br>使用<code>FileVisitor</code>来实现访问者模式。</p>
<pre><code>preVisitDirectory(T dir, BasicFileAttributes attrs);
visitFile(T dir, BasicFileAttributes attrs);
visitFileFailed(T dir, IOException exc);
postVisitDirectory(T dir, IOException exc);
</code></pre><p>####4.使用WatchService来监控目录，变化请通知</p>
<pre><code>WatchService watchService = FileSystems.getDefault().newWatchService();
Path path = Paths.get(&quot;/home/shenyanchao/Documents&quot;);
WatchKey watchKey = path.register(watchService, StandardWatchEventKinds.ENTRY_CREATE,
        StandardWatchEventKinds.ENTRY_DELETE, StandardWatchEventKinds.ENTRY_MODIFY);
while (true) {
    List&lt;WatchEvent&lt;?&gt;&gt; watchEvents = watchService.take().pollEvents();
    for (WatchEvent&lt;?&gt; watchEvent : watchEvents) {
        System.out.printf(&quot;[%s]文件发生了[%s]事件。%n&quot;, watchEvent.context(), watchEvent.kind());
    }
    boolean valid = watchKey.reset();
    if (!valid){
        break;
    }
}
</code></pre><p>###Java7并发（JSR166Y）</p>
<p>####Fork Join框架，大任务分解为小任务<br>通过ForkJoinPool，ForkJoinTask来实现的。</p>
<pre><code>public class Fibonacci extends RecursiveTask&lt;Integer&gt; {

    final int n;

    Fibonacci(int n) {
        this.n = n;
    }

    @Override
    protected Integer compute() {
        if (n &lt;= 1)
            return n;
        Fibonacci f1 = new Fibonacci(n - 1);
        f1.fork();
        Fibonacci f2 = new Fibonacci(n - 2);
        f2.fork();
        return f1.join() + f2.join();
    }

    public static void main(String[] args) {
        Fibonacci fibonacci = new Fibonacci(4);
        System.out.println(fibonacci.compute());
    }
}
</code></pre><p>####TransferQueue，ConcurrentLinkedDeque等新类<br>TransferQueue是一个继承了 BlockingQueue的接口，并且增加若干新的方法。</p>
<p>####ThreadLocalRandom用于生成随机数</p>
<pre><code>ThreadLocalRandom.current().nextInt (...)
</code></pre><p>Random是线程安全的，但速度较慢。而这个是快速的，但是速度很快。适用于线程内部的使用。</p>
<p>###Java7 client<br>诸如更新了很多swing显示相关的api.<br>更好的支持linux fonts</p>
<p>###Java7 VM新特性</p>
<p>####1.引入Garbage First回收算法<br>Garbage First简称G1，它的目标是要做到尽量减少GC所导致的应用暂停的时间，让应用达到准实时的效果，同时保持JVM堆空间的利用率。用于替代CMS</p>
<hr>
<p>参考文档：<a href="http://www.slideshare.net/boulderjug/55-things-in-java-7" target="_blank" rel="external">http://www.slideshare.net/boulderjug/55-things-in-java-7</a></p>
<p>##Java8新特性</p>
<p>###1.接口默认方法[接口允许有实现啦]<br>Java 8允许我们给接口添加一个非抽象的方法实现，只需要使用 <code>default</code>关键字即可，这个特征又叫做扩展方法。</p>
<pre><code>interface Formula {
    double calculate(int a);

    default double sqrt(int a) {
        return Math.sqrt(a);
    }
}
</code></pre><p>###2.Lambda表达式<br>据说借鉴了各种动态语言的新特性，比如scala，python<br>首先看看在老版本的Java中是如何排列字符串的：</p>
<pre><code>List&lt;String&gt; names = Arrays.asList(&quot;peter&quot;, &quot;anna&quot;, &quot;mike&quot;, &quot;xenia&quot;);

Collections.sort(names, new Comparator&lt;String&gt;() {
@Override
public int compare(String a, String b) {
    return b.compareTo(a);
}
});
</code></pre><p>Java 8 提供了更为简介的语法，lambda表达式：</p>
<pre><code>Collections.sort(names, (String a, String b) -&gt; {
    return b.compareTo(a);
});
</code></pre><p>可以更短：</p>
<pre><code>Collections.sort(names, (String a, String b) -&gt; b.compareTo(a));
</code></pre><p>再短： </p>
<pre><code>Collections.sort(names, (a, b) -&gt; b.compareTo(a));
</code></pre><p>###3.@FunctionalInterface<br>这是新引入的一个注解，用于支持lambda。用<code>FunctionalInterface</code>标识的接口，必须只包含1个抽象方法。否则会编译报错的。因为如果有多个抽象方法，lambda就无法知道对应哪个方法了。</p>
<pre><code>@FunctionalInterface
interface Converter&lt;F, T&gt; {
    T convert(F from);
}

Converter&lt;String, Integer&gt; converter = (from) -&gt; Integer.valueOf(from);
Integer converted = converter.convert(&quot;123&quot;);
System.out.println(converted);    // 123
</code></pre><p>例子中，<code>(from) -&gt; Integer.valueOf(from)</code>这个lambda表达式指出了convert方法的具体实现。</p>
<p>####(1)方法与构造函数的引用::<br>Java 8 允许你使用 :: 关键字来传递方法或者构造函数引用,下面的代码展示了如何引用一个静态方法</p>
<pre><code>Converter&lt;String, Integer&gt; converter = Integer::valueOf;
Integer converted = converter.convert(&quot;123&quot;);
System.out.println(converted);   // 123
</code></pre><p>当然也可以引用一个对象的方法：</p>
<pre><code>converter = something::startsWith;
String converted = converter.convert(&quot;Java&quot;);
System.out.println(converted);    // &quot;J&quot;
</code></pre><p>那么如何引用构造函数呢？</p>
<pre><code>class Person {
    String firstName;
    String lastName;

    Person() {}

    Person(String firstName, String lastName) {
        this.firstName = firstName;
        this.lastName = lastName;
    }
}
</code></pre><p>这是一个pojo类。下面创建一个用于创建person对象的FunctionalInterface：</p>
<pre><code>interface PersonFactory&lt;P extends Person&gt; {
    P create(String firstName, String lastName);
}
</code></pre><p>这里我们使用构造函数引用来将他们关联起来，而不是实现一个完整的工厂：</p>
<pre><code>PersonFactory&lt;Person&gt; personFactory = Person::new;
Person person = personFactory.create(&quot;Peter&quot;, &quot;Parker&quot;);
</code></pre><p>我们只需要使用 Person::new 来获取Person类构造函数的引用，Java编译器会自动根据PersonFactory.create方法的签名来选择合适的构造函数。</p>
<p>####(2)内嵌的Functional Interfaces<br>上面提到的Comparator接口，为什么可以使用lambda表达式，正是因为在java 8中，被定义为了FunctionalInterface。这些已经存在的接口是通过添加@FunctionalInterface注解来支持的。</p>
<p>另外，java 8 api还提供了丰富的接口。这些接口貌似都是从Google Guava包里得到的提示，命名甚至都是一样的。</p>
<ul>
<li>Predicates   </li>
</ul>
<p>Predicate 接口只有一个参数，返回boolean类型。该接口包含多种默认方法来将Predicate组合成其他复杂的逻辑（比如：与，或，非）：</p>
<pre><code>Predicate&lt;String&gt; predicate = (s) -&gt; s.length() &gt; 0;

predicate.test(&quot;foo&quot;);              // true
predicate.negate().test(&quot;foo&quot;);     // false

Predicate&lt;Boolean&gt; nonNull = Objects::nonNull;
Predicate&lt;Boolean&gt; isNull = Objects::isNull;

Predicate&lt;String&gt; isEmpty = String::isEmpty;
Predicate&lt;String&gt; isNotEmpty = isEmpty.negate();
</code></pre><ul>
<li>Function</li>
</ul>
<p>Function 接口有一个参数并且返回一个结果，并附带了一些可以和其他函数组合的默认方法（compose, andThen）：</p>
<pre><code>Function&lt;String, Integer&gt; toInteger = Integer::valueOf;
Function&lt;String, String&gt; backToString = toInteger.andThen(String::valueOf);

backToString.apply(&quot;123&quot;);     // &quot;123&quot;
</code></pre><ul>
<li>Supplier</li>
</ul>
<p>Supplier 接口返回一个给定类型的泛型，和Function接口不同的是该接口不接受任何参数.</p>
<pre><code>Supplier&lt;Person&gt; personSupplier = Person::new;
personSupplier.get();   // new Person
</code></pre><ul>
<li>Consumer</li>
</ul>
<p>Consumer在一个输入参数上做一些操作。</p>
<pre><code>Consumer&lt;Person&gt; greeter = (p) -&gt; System.out.println(&quot;Hello, &quot; + p.firstName);
greeter.accept(new Person(&quot;Luke&quot;, &quot;Skywalker&quot;));
</code></pre><ul>
<li>Comparator</li>
</ul>
<p>Comparator是早就存在的，不过java 8提供了一些默认方法。</p>
<pre><code>Comparator&lt;Person&gt; comparator = (p1, p2) -&gt; p1.firstName.compareTo(p2.firstName);

Person p1 = new Person(&quot;John&quot;, &quot;Doe&quot;);
Person p2 = new Person(&quot;Alice&quot;, &quot;Wonderland&quot;);

comparator.compare(p1, p2);             // &gt; 0
comparator.reversed().compare(p1, p2);  // &lt; 0
</code></pre><ul>
<li>Optional</li>
</ul>
<p>Optional其实并不是一个FunctionInterface，而是一个用来避免<code>NullPointerException</code>的工具。</p>
<pre><code>Optional&lt;String&gt; optional = Optional.of(&quot;bam&quot;);

optional.isPresent();           // true
optional.get();                 // &quot;bam&quot;
optional.orElse(&quot;fallback&quot;);    // &quot;bam&quot;

optional.ifPresent((s) -&gt; System.out.println(s.charAt(0)));     // &quot;b&quot;
</code></pre><ul>
<li>Stream</li>
</ul>
<p><code>java.util.stream.Stream</code>代表了能在其上做一系列操作的一串元素。在java 8中，Collections被扩展了。我们可以通过<code>Collections.stream()</code>或者<code>Collections.parallelStream()</code>来创建Stream。<br>首先，新建一个数组。</p>
<pre><code>List&lt;String&gt; stringCollection = new ArrayList&lt;&gt;();
stringCollection.add(&quot;ddd2&quot;);
stringCollection.add(&quot;aaa2&quot;);
stringCollection.add(&quot;bbb1&quot;);
stringCollection.add(&quot;aaa1&quot;);
stringCollection.add(&quot;bbb3&quot;);
stringCollection.add(&quot;ccc&quot;);
stringCollection.add(&quot;bbb2&quot;);
stringCollection.add(&quot;ddd1&quot;);
</code></pre><p>具体使用如下：</p>
<pre><code>stringCollection
    .stream()
    .sorted()
    .filter((s) -&gt; s.startsWith(&quot;a&quot;))
    .forEach(System.out::println);

// &quot;aaa1&quot;, &quot;aaa2&quot;
</code></pre><p>map()函数可以把每个值转换为另外的值。</p>
<pre><code>stringCollection
    .stream()
    .map(String::toUpperCase)
    .sorted((a, b) -&gt; b.compareTo(a))
    .forEach(System.out::println);

// &quot;DDD2&quot;, &quot;DDD1&quot;, &quot;CCC&quot;, &quot;BBB3&quot;, &quot;BBB2&quot;, &quot;AAA2&quot;, &quot;AAA1&quot;        
</code></pre><p>另外提供有各种match方法。</p>
<pre><code>boolean anyStartsWithA =
    stringCollection
        .stream()
        .anyMatch((s) -&gt; s.startsWith(&quot;a&quot;));

System.out.println(anyStartsWithA);      // true

boolean allStartsWithA =
    stringCollection
        .stream()
        .allMatch((s) -&gt; s.startsWith(&quot;a&quot;));

System.out.println(allStartsWithA);      // false

boolean noneStartsWithZ =
    stringCollection
        .stream()
        .noneMatch((s) -&gt; s.startsWith(&quot;z&quot;));

System.out.println(noneStartsWithZ);      // true
</code></pre><p>count()方法返回的是一个值。</p>
<pre><code>long startsWithB =
    stringCollection
        .stream()
        .filter((s) -&gt; s.startsWith(&quot;b&quot;))
        .count();

System.out.println(startsWithB);    // 3        
</code></pre><p>reduce则进行了归一化处理：</p>
<pre><code>Optional&lt;String&gt; reduced =
    stringCollection
        .stream()
        .sorted()
        .reduce((s1, s2) -&gt; s1 + &quot;#&quot; + s2);

reduced.ifPresent(System.out::println);
// &quot;aaa1#aaa2#bbb1#bbb2#bbb3#ccc#ddd1#ddd2&quot;
</code></pre><ul>
<li>ParallelStream </li>
</ul>
<p>它是一个并行的。速度要比stream快的多。</p>
<ul>
<li>Map</li>
</ul>
<p>Map并不支持Stream，不过Java 8 提供了各种有用的新方法：</p>
<pre><code>Map&lt;Integer, String&gt; map = new HashMap&lt;&gt;();

for (int i = 0; i &lt; 10; i++) {
    map.putIfAbsent(i, &quot;val&quot; + i);
}

map.forEach((id, val) -&gt; System.out.println(val));

map.computeIfPresent(3, (num, val) -&gt; val + num);
map.get(3);             // val33

map.computeIfPresent(9, (num, val) -&gt; null);
map.containsKey(9);     // false

map.computeIfAbsent(23, num -&gt; &quot;val&quot; + num);
map.containsKey(23);    // true

map.computeIfAbsent(3, num -&gt; &quot;bam&quot;);
map.get(3);             // val33

map.remove(3, &quot;val3&quot;);
map.get(3);             // val33

map.remove(3, &quot;val33&quot;);
map.get(3);             // null

map.getOrDefault(42, &quot;not found&quot;);  // not found

map.merge(9, &quot;val9&quot;, (value, newValue) -&gt; value.concat(newValue));
map.get(9);             // val9

map.merge(9, &quot;concat&quot;, (value, newValue) -&gt; value.concat(newValue));
map.get(9);             // val9concat
</code></pre><p>###4.时间API<br>Java8更新了Date API,这个新的api与joda-time类似。</p>
<p>####(1)Clock<br>Clock类提供了访问当前日期和时间的方法，Clock是时区敏感的，可以用来取代 System.currentTimeMillis() 来获取当前的微秒数。某一个特定的时间点也可以使用Instant类来表示，Instant类也可以用来创建老的java.util.Date对象。</p>
<pre><code>Clock clock = Clock.systemDefaultZone();
long millis = clock.millis();

Instant instant = clock.instant();
Date legacyDate = Date.from(instant);   // legacy java.util.Date
</code></pre><p>####(2)TimeZones<br>在新API中时区使用ZoneId来表示。时区可以很方便的使用静态方法of来获取到。 时区定义了到UTS时间的时间差，在Instant时间点对象到本地日期对象之间转换的时候是极其重要的</p>
<pre><code>System.out.println(ZoneId.getAvailableZoneIds());
// prints all available timezone ids

ZoneId zone1 = ZoneId.of(&quot;Europe/Berlin&quot;);
ZoneId zone2 = ZoneId.of(&quot;Brazil/East&quot;);
System.out.println(zone1.getRules());
System.out.println(zone2.getRules());

// ZoneRules[currentStandardOffset=+01:00]
// ZoneRules[currentStandardOffset=-03:00]
</code></pre><p>####(3)LocalTime<br>LocalTime 定义了一个没有时区信息的时间，例如 晚上10点，或者 17:30:15。下面的例子使用前面代码创建的时区创建了两个本地时间。之后比较时间并以小时和分钟为单位计算两个时间的时间差：</p>
<pre><code>LocalTime now1 = LocalTime.now(zone1);
LocalTime now2 = LocalTime.now(zone2);

System.out.println(now1.isBefore(now2));  // false

long hoursBetween = ChronoUnit.HOURS.between(now1, now2);
long minutesBetween = ChronoUnit.MINUTES.between(now1, now2);

System.out.println(hoursBetween);       // -3
System.out.println(minutesBetween);     // -239
</code></pre><p>LocalTime 提供了多种工厂方法来简化对象的创建，包括解析时间字符串</p>
<pre><code>LocalTime late = LocalTime.of(23, 59, 59);
System.out.println(late);       // 23:59:59

DateTimeFormatter germanFormatter =
    DateTimeFormatter
        .ofLocalizedTime(FormatStyle.SHORT)
        .withLocale(Locale.GERMAN);

LocalTime leetTime = LocalTime.parse(&quot;13:37&quot;, germanFormatter);
System.out.println(leetTime);   // 13:37
</code></pre><p>####(4)LocalDate<br>LocalDate 表示了一个确切的日期，比如 2014-03-11。该对象值是不可变的，用起来和LocalTime基本一致。下面的例子展示了如何给Date对象加减天/月/年。另外要注意的是这些对象是不可变的，操作返回的总是一个新实例。</p>
<pre><code>LocalDate today = LocalDate.now();
LocalDate tomorrow = today.plus(1, ChronoUnit.DAYS);
LocalDate yesterday = tomorrow.minusDays(2);

LocalDate independenceDay = LocalDate.of(2014, Month.JULY, 4);
DayOfWeek dayOfWeek = independenceDay.getDayOfWeek();
System.out.println(dayOfWeek);    // FRIDAY

DateTimeFormatter germanFormatter =
    DateTimeFormatter
        .ofLocalizedDate(FormatStyle.MEDIUM)
        .withLocale(Locale.GERMAN);

LocalDate xmas = LocalDate.parse(&quot;24.12.2014&quot;, germanFormatter);
System.out.println(xmas);   // 2014-12-24
</code></pre><p>####(5)LocalDateTime<br>        LocalDateTime 同时表示了时间和日期，相当于前两节内容合并到一个对象上了。LocalDateTime和LocalTime还有LocalDate一样，都是不可变的。LocalDateTime提供了一些能访问具体字段的方法。</p>
<pre><code>LocalDateTime sylvester = LocalDateTime.of(2014, Month.DECEMBER, 31, 23, 59, 59);

DayOfWeek dayOfWeek = sylvester.getDayOfWeek();
System.out.println(dayOfWeek);      // WEDNESDAY

Month month = sylvester.getMonth();
System.out.println(month);          // DECEMBER

long minuteOfDay = sylvester.getLong(ChronoField.MINUTE_OF_DAY);
System.out.println(minuteOfDay);    // 1439

Instant instant = sylvester
        .atZone(ZoneId.systemDefault())
        .toInstant();

Date legacyDate = Date.from(instant);
System.out.println(legacyDate);     // Wed Dec 31 23:59:59 CET 2014

DateTimeFormatter formatter =
    DateTimeFormatter
        .ofPattern(&quot;MMM dd, yyyy - HH:mm&quot;);

LocalDateTime parsed = LocalDateTime.parse(&quot;Nov 03, 2014 - 07:13&quot;, formatter);
String string = formatter.format(parsed);
System.out.println(string);     // Nov 03, 2014 - 07:13
</code></pre><p>###5.支持重复注解了，注解也可以用在任何地方了<br>java8之前，类，属性，方法才有注解，现在几乎任何地方都可以了。</p>
<pre><code>new @Interned MyObject();
myString = (@NonNull String) str;

void monitorTemperature() throws @Critical TemperatureException { ... }
</code></pre><p>之前要实现重复注解需要这样：</p>
<pre><code>public @interface Authority {
     String role();
}

public @interface Authorities {
    Authority[] value();
}

public class RepeatAnnotationUseOldVersion {

    @Authorities({@Authority(role=&quot;Admin&quot;),@Authority(role=&quot;Manager&quot;)})
    public void doSomeThing(){
    }
}
</code></pre><p>而现在：</p>
<pre><code>@Repeatable(Authorities.class)
public @interface Authority {
     String role();
}

public @interface Authorities {
    Authority[] value();
}

public class RepeatAnnotationUseNewVersion {
    @Authority(role=&quot;Admin&quot;)
    @Authority(role=&quot;Manager&quot;)
    public void doSomeThing(){ }
}
</code></pre><p>###6.Nashorn JavaScript 引擎<br>简单的说，它是 Rhino 的接替者.升级啦。</p>
<p>###7.StampedLock<br>它是java8在java.util.concurrent.locks新增的一个API。</p>
<p>ReentrantReadWriteLock 在沒有任何读写锁时，才可以取得写入锁，这可用于实现了悲观读取（Pessimistic Reading），即如果执行中进行读取时，经常可能有另一执行要写入的需求，为了保持同步，ReentrantReadWriteLock 的读取锁定就可派上用场。</p>
<p>然而，如果读取执行情况很多，写入很少的情况下，使用 ReentrantReadWriteLock 可能会使写入线程遭遇饥饿（Starvation）问题，也就是写入线程吃吃无法竞争到锁定而一直处于等待状态。</p>
<p>StampedLock控制锁有三种模式（写，读，乐观读），一个StampedLock状态是由版本和模式两个部分组成，锁获取方法返回一个数字作为票据stamp，它用相应的锁状态表示并控制访问，数字0表示没有写锁被授权访问。在读锁上分为悲观锁和乐观锁。</p>
<p>所谓的乐观读模式，也就是若读的操作很多，写的操作很少的情况下，你可以乐观地认为，写入与读取同时发生几率很少，因此不悲观地使用完全的读取锁定，程序可以查看读取资料之后，是否遭到写入执行的变更，再采取后续的措施（重新读取变更信息，或者抛出异常） ，这一个小小改进，可大幅度提高程序的吞吐量！！</p>
<p>它是java8在java.util.concurrent.locks新增的一个API。</p>
<p>ReentrantReadWriteLock 在沒有任何读写锁时，才可以取得写入锁，这可用于实现了悲观读取（Pessimistic Reading），即如果执行中进行读取时，经常可能有另一执行要写入的需求，为了保持同步，ReentrantReadWriteLock 的读取锁定就可派上用场。</p>
<p>然而，如果读取执行情况很多，写入很少的情况下，使用 ReentrantReadWriteLock 可能会使写入线程遭遇饥饿（Starvation）问题，也就是写入线程吃吃无法竞争到锁定而一直处于等待状态。</p>
<p>StampedLock控制锁有三种模式（写，读，乐观读），一个StampedLock状态是由版本和模式两个部分组成，锁获取方法返回一个数字作为票据stamp，它用相应的锁状态表示并控制访问，数字0表示没有写锁被授权访问。在读锁上分为悲观锁和乐观锁。</p>
<p>所谓的乐观读模式，也就是若读的操作很多，写的操作很少的情况下，你可以乐观地认为，写入与读取同时发生几率很少，因此不悲观地使用完全的读取锁定，程序可以查看读取资料之后，是否遭到写入执行的变更，再采取后续的措施（重新读取变更信息，或者抛出异常） ，这一个小小改进，可大幅度提高程序的吞吐量！！</p>
<pre><code>class Point {
   private double x, y;
   private final StampedLock sl = new StampedLock();
   void move(double deltaX, double deltaY) { // an exclusively locked method
     long stamp = sl.writeLock();
     try {
       x += deltaX;
       y += deltaY;
     } finally {
       sl.unlockWrite(stamp);
     }
   }
  //下面看看乐观读锁案例
   double distanceFromOrigin() { // A read-only method
     long stamp = sl.tryOptimisticRead(); //获得一个乐观读锁
     double currentX = x, currentY = y; //将两个字段读入本地局部变量
     if (!sl.validate(stamp)) { //检查发出乐观读锁后同时是否有其他写锁发生？
        stamp = sl.readLock(); //如果没有，我们再次获得一个读悲观锁
        try {
          currentX = x; // 将两个字段读入本地局部变量
          currentY = y; // 将两个字段读入本地局部变量
        } finally {
           sl.unlockRead(stamp);
        }
     }
     return Math.sqrt(currentX * currentX + currentY * currentY);
   }
//下面是悲观读锁案例
   void moveIfAtOrigin(double newX, double newY) { // upgrade
     // Could instead start with optimistic, not read mode
     long stamp = sl.readLock();
     try {
       while (x == 0.0 &amp;&amp; y == 0.0) { //循环，检查当前状态是否符合
         long ws = sl.tryConvertToWriteLock(stamp); //将读锁转为写锁
         if (ws != 0L) { //这是确认转为写锁是否成功
           stamp = ws; //如果成功 替换票据
           x = newX; //进行状态改变
           y = newY; //进行状态改变
           break;
         }
         else { //如果不能成功转换为写锁
           sl.unlockRead(stamp); //我们显式释放读锁
           stamp = sl.writeLock(); //显式直接进行写锁 然后再通过循环再试
         }
       }
     } finally {
       sl.unlock(stamp); //释放读锁或写锁
     }
   }
 }
</code></pre><hr>
<p>参考文档：<a href="http://winterbe.com/posts/2014/03/16/java-8-tutorial/" target="_blank" rel="external">http://winterbe.com/posts/2014/03/16/java-8-tutorial/</a></p>

      
    </div>

    <div>
      
        
      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/java7/" rel="tag">#java7</a>
          
            <a href="/tags/java8/" rel="tag">#java8</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/blog/2014/06/24/export-excel-by-jxls/" rel="next" title="使用 jXLS导出报表">
                <i class="fa fa-chevron-left"></i> 使用 jXLS导出报表
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/blog/2014/10/22/tie-breaker-in-solr/" rel="prev" title="solr中的tie breaker">
                solr中的tie breaker <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
        
  <div class="bdsharebuttonbox">
    <a href="#" class="bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a>
    <a href="#" class="bds_douban" data-cmd="douban" title="分享到豆瓣网"></a>
    <a href="#" class="bds_sqq" data-cmd="sqq" title="分享到QQ好友"></a>
    <a href="#" class="bds_qzone" data-cmd="qzone" title="分享到QQ空间"></a>
    <a href="#" class="bds_weixin" data-cmd="weixin" title="分享到微信"></a>
    <a href="#" class="bds_tieba" data-cmd="tieba" title="分享到百度贴吧"></a>
    <a href="#" class="bds_twi" data-cmd="twi" title="分享到Twitter"></a>
    <a href="#" class="bds_fbook" data-cmd="fbook" title="分享到Facebook"></a>
    <a href="#" class="bds_more" data-cmd="more"></a>
    <a class="bds_count" data-cmd="count"></a>
  </div>
  <script>
    window._bd_share_config = {
      "common": {
        "bdText": "",
        "bdMini": "2",
        "bdMiniList": false,
        "bdPic": ""
      },
      "share": {
        "bdSize": "16",
        "bdStyle": "0"
      },
      "image": {
        "viewList": ["tsina", "douban", "sqq", "qzone", "weixin", "twi", "fbook"],
        "viewText": "分享到：",
        "viewSize": "16"
      }
    }
  </script>

<script>
  with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?cdnversion='+~(-new Date()/36e5)];
</script>

      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="https://avatars0.githubusercontent.com/u/2255020?v=3&s=460"
               alt="申艳超" />
          <p class="site-author-name" itemprop="name">申艳超</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">108</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">35</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">196</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/blueshen" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
          
        </div>

        
        

        
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <p class="post-toc-empty">此文章未包含目录</p>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2012 - 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">申艳超</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.0.1"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  

    <script type="text/javascript">
      var disqus_shortname = 'blueshen';
      var disqus_identifier = 'blog/2014/08/27/java-new-feature/';
      var disqus_title = 'Java新特性';
      var disqus_url = 'http://www.shenyanchao.cn/blog/2014/08/27/java-new-feature/';

      function run_disqus_script(disqus_script){
        var dsq = document.createElement('script');
        dsq.type = 'text/javascript';
        dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      }

      run_disqus_script('count.js');
      
        run_disqus_script('embed.js');
      
    </script>
  



  
  
  

  

  
<script type="text/javascript" async src="//push.zhanzhang.baidu.com/push.js">
</script>


</body>
</html>
