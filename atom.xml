<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>申艳超-博客</title>
  <subtitle>搜索引擎、自然语言处理、ElasticSearch、Solr</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.shenyanchao.cn/"/>
  <updated>2018-12-20T12:02:48.981Z</updated>
  <id>https://www.shenyanchao.cn/</id>
  
  <author>
    <name>申艳超</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ElasticSearch线上故障-持续Yellow状态</title>
    <link href="https://www.shenyanchao.cn/blog/2018/12/13/elasticsearch-yellow-exception/"/>
    <id>https://www.shenyanchao.cn/blog/2018/12/13/elasticsearch-yellow-exception/</id>
    <published>2018-12-13T06:12:07.000Z</published>
    <updated>2018-12-20T12:02:48.981Z</updated>
    
    <content type="html"><![CDATA[<h3 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h3><p>ES集群，状态持续Yellow。出现部分replica一直在追primary的索引数据，追不上。</p>
<p>仔细排查：固定的几个ES节点，出现间歇性被<strong>踢出</strong>Cluster，随后又<strong>加入</strong>Cluster。这是导致出现yellow原因，并且一直不能恢复到Green状态。</p>
<h3 id="日志排查"><a href="#日志排查" class="headerlink" title="日志排查"></a>日志排查</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"> [2018-12-08T19:25:29,993][WARN ][o.e.x.s.t.n.SecurityNetty4Transport] [es35-search.mars.ljnode.com] write and flush on the network layer failed (channel: [id: 0x0e6ac038, L:0.0.0.0/0.0.0.0:8309 ! R:/10.200.24.96:46802])</div><div class="line">java.nio.channels.ClosedChannelException: null</div><div class="line">         at io.netty.channel.AbstractChannel$AbstractUnsafe.write(...)(Unknown Source) ~[?:?]</div><div class="line"> [2018-12-08T19:25:29,994][WARN ][o.e.x.s.t.n.SecurityNetty4Transport] [es35-search.mars.ljnode.com] write and flush on the network layer failed (channel: [id: 0x0e6ac038, L:0.0.0.0/0.0.0.0:8309 ! R:/10.200.24.96:46802])</div><div class="line"> java.nio.channels.ClosedChannelException: null</div><div class="line">         at io.netty.channel.AbstractChannel$AbstractUnsafe.write(...)(Unknown Source) ~[?:?]</div><div class="line"> [2018-12-08T19:25:31,111][DEBUG][o.e.a.a.c.n.i.TransportNodesInfoAction] [es35-search.mars.ljnode.com] failed to execute on node [_TS9PjOLRke8j12-d59iGA]</div><div class="line"> org.elasticsearch.transport.ReceiveTimeoutTransportException: [es39-search.mars.ljnode.com_node0][10.200.24.86:8309][cluster:monitor/nodes/info[n]] request_id [203863696] timed out after [5000ms]</div><div class="line">         at org.elasticsearch.transport.TransportService$TimeoutHandler.run(TransportService.java:961) [elasticsearch-5.6.9.jar:5.6.9]</div><div class="line">         at org.elasticsearch.common.util.concurrent.ThreadContext$ContextPreservingRunnable.run(ThreadContext.java:575) [elasticsearch-5.6.9.jar:5.6.9]</div><div class="line">         at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) [?:1.8.0_172]</div><div class="line">         at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) [?:1.8.0_172]</div><div class="line">         at java.lang.Thread.run(Thread.java:748) [?:1.8.0_172]</div><div class="line"> [2018-12-08T19:25:32,305][DEBUG][o.e.a.a.c.n.i.TransportNodesInfoAction] [es35-search.mars.ljnode.com] failed to execute on node [yt3RGpgJStKwtOENBe5Trw]</div><div class="line"> org.elasticsearch.transport.ReceiveTimeoutTransportException: [es38-search.mars.ljnode.com_node0][10.200.24.97:8309][cluster:monitor/nodes/info[n]] request_id [203863752] timed out after [5000ms]</div><div class="line">         at org.elasticsearch.transport.TransportService$TimeoutHandler.run(TransportService.java:961) [elasticsearch-5.6.9.jar:5.6.9]</div></pre></td></tr></table></figure>
<h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>网络是千兆的网卡，堵塞导致超时。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;现象&quot;&gt;&lt;a href=&quot;#现象&quot; class=&quot;headerlink&quot; title=&quot;现象&quot;&gt;&lt;/a&gt;现象&lt;/h3&gt;&lt;p&gt;ES集群，状态持续Yellow。出现部分replica一直在追primary的索引数据，追不上。&lt;/p&gt;
&lt;p&gt;仔细排查：固定的几个ES节点
    
    </summary>
    
      <category term="elasticsearch" scheme="https://www.shenyanchao.cn/categories/elasticsearch/"/>
    
    
      <category term="elasticsearch" scheme="https://www.shenyanchao.cn/tags/elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>lucene-bkm</title>
    <link href="https://www.shenyanchao.cn/blog/2018/12/04/lucene-bkm/"/>
    <id>https://www.shenyanchao.cn/blog/2018/12/04/lucene-bkm/</id>
    <published>2018-12-04T14:03:21.000Z</published>
    <updated>2018-12-04T14:03:21.754Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Lucene索引过程&amp;索引文件格式详解</title>
    <link href="https://www.shenyanchao.cn/blog/2018/12/04/lucene-index-files/"/>
    <id>https://www.shenyanchao.cn/blog/2018/12/04/lucene-index-files/</id>
    <published>2018-12-04T04:36:09.000Z</published>
    <updated>2018-12-07T13:56:26.089Z</updated>
    
    <content type="html"><![CDATA[<p>最近2年，整个开源搜索引擎领域，发展迅速，版本迭代很快。 Lucene最近两年从4.0版本已经发布到最新的7.5.0版本，Solr和Elasticsearch也不断跟进升级。Lucene作为核心包，互联网上或者是书籍上关于它的介绍和分析都比较陈旧了，很多都是基于Lucene3.x来。是时候，从底层来分析下最新的Lucene发展情况了。</p>
<p>本文，依Lucene 7.5.0（当时最新）版本描述。</p>
<h3 id="Lucene索引文件的表现"><a href="#Lucene索引文件的表现" class="headerlink" title="Lucene索引文件的表现"></a>Lucene索引文件的表现</h3><p>Lucene索引在硬盘上的<strong>表现</strong>就是一系列的文件，后缀名不同，下面是一个样例：</p>
<p><img src="/images/lucene-index-files/lucene-index-on-disk.jpg" alt="lucene 索引文件"></p>
<p>通常，看到这些文件，我们就想打开看看，发现根本无法直接查看。这里存的到底是什么，都有什么作用。很多时候是一脸的懵。为了更好的理解这些文件，下面将一步步进行细致的分析。</p>
<a id="more"></a>
<h3 id="Lucene构建索引过程"><a href="#Lucene构建索引过程" class="headerlink" title="Lucene构建索引过程"></a>Lucene构建索引过程</h3><p>Lucene源码读起来是比较晦涩的，毕竟它写于20年前，而且作者也是一个具备很多工作经验的老手，读源码是需要一定的时间的。    </p>
<p>做索引的入口是<code>IndexWriter.addDocument*()</code>, 当新索引N个Document的时候，是如何生成一系列的索引文件呢。</p>
<p>下面是一个源码导读图：</p>
<p><img src="/images/lucene-index-files/lucene-index-process.png" alt="Lucene 索引构建"></p>
<p>以上重点关注<code>DefaultIndexingChain</code>这个类，<code>processDocument()</code>方法主要是用来构建<strong>正排信息</strong>。而针对每个Field的<code>processField()</code>则通过一系列的操作，构建出了<strong>倒排信息</strong>。</p>
<p>什么时候写入磁盘文件中呢？触发点是DocumentsWriterPerThread(DWPT)的flush()方法。触发时间可能是以下条件：</p>
<ul>
<li>超过MaxBufferedDocs限制</li>
<li>超过RAMBufferSizeMB限制</li>
<li>人为flush()或commit()</li>
<li>MergePolicy触发</li>
</ul>
<p>经过以上的处理，就生成了一个最小的<strong>独立索引单元</strong>，称之为Segment。一个逻辑上的索引（表现为一个目录），是由N多个Segment构成的。</p>
<h3 id="Lucene索引文件"><a href="#Lucene索引文件" class="headerlink" title="Lucene索引文件"></a>Lucene索引文件</h3><p>以下描述在<a href="https://lucene.apache.org/core/7_5_0/core/org/apache/lucene/codecs/lucene70/package-summary.html" target="_blank" rel="external">Lucene JavaDoc</a>里有详细的介绍，为方便理解，介绍如下：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>扩展名</th>
<th>简要描述</th>
<th>相关源码</th>
</tr>
</thead>
<tbody>
<tr>
<td>Segment File</td>
<td>segments_N</td>
<td>commit点信息，其中N是一个36进制表示的值</td>
<td>SegmentInfos</td>
</tr>
<tr>
<td>Lock File</td>
<td>write.lock</td>
<td>文件锁，避免多个writer同时写；默认和索引文件一个目录。</td>
<td></td>
</tr>
<tr>
<td>Segment Info</td>
<td>.si</td>
<td>segment的元数据信息，指明这个segment都包含哪些文件</td>
<td>Lucene70SegmentInfoFormat</td>
</tr>
<tr>
<td>Compound File</td>
<td>.cfs, .cfe</td>
<td>如果启用compound功能，会压缩索引到2个文件内</td>
<td>Lucene50CompoundFormat</td>
</tr>
<tr>
<td>Fields</td>
<td>.fnm</td>
<td>存储有哪些Field,以及相关信息</td>
<td>Lucene60FieldInfosFormat</td>
</tr>
<tr>
<td>Field Index</td>
<td>.fdx</td>
<td>Field数据文件的索引</td>
<td>Lucene50StoredFieldsFormat</td>
</tr>
<tr>
<td>Field Data</td>
<td>.fdt</td>
<td>Field数据文件</td>
<td>Lucene50StoredFieldsFormat</td>
</tr>
<tr>
<td>Term Dictionary</td>
<td>.tim</td>
<td>Term词典</td>
<td>BlockTreeTermsWriter</td>
</tr>
<tr>
<td>Term Index</td>
<td>.tip</td>
<td>指向Term词典的索引</td>
<td>BlockTreeTermsWriter</td>
</tr>
<tr>
<td>Frequencies</td>
<td>.doc</td>
<td>保留包含每个Term的文档列表</td>
<td>Lucene50PostingsWriter</td>
</tr>
<tr>
<td>Positions</td>
<td>.pos</td>
<td>Term在文章中出现的位置信息</td>
<td>Lucene50PostingsWriter</td>
</tr>
<tr>
<td>Payloads</td>
<td>.pay</td>
<td>offset偏移/payload附加信息</td>
<td>Lucene50PostingsWriter</td>
</tr>
<tr>
<td>Norms</td>
<td>.nvd, .nvm</td>
<td>.nvm保存加权因子元数据；.nvd存储加权数据</td>
<td>Lucene70NormsFormat</td>
</tr>
<tr>
<td>Per-Document Values</td>
<td>.dvd, .dvm</td>
<td>.dvm存文档正排元数据；.dvd存文档正排数据</td>
<td>Lucene70DocValuesFormat</td>
</tr>
<tr>
<td>Term Vector Index</td>
<td>.tvx</td>
<td>指向tvd的offset</td>
<td>Lucene50TermVectorsFormat</td>
</tr>
<tr>
<td>Term Vector Data</td>
<td>.tvd</td>
<td>存储term vector信息</td>
<td>Lucene50TermVectorsFormat</td>
</tr>
<tr>
<td>Live Documents</td>
<td>.liv</td>
<td>活着的文档列表。位图形式</td>
<td>Lucene50LiveDocsFormat</td>
</tr>
<tr>
<td>Point Values</td>
<td>.dii, .dim</td>
<td>多维数据，地理位置等信息，用于处理数值型的查询</td>
<td>Lucene60PointsFormat</td>
</tr>
</tbody>
</table>
<h4 id="Segment-N"><a href="#Segment-N" class="headerlink" title="Segment_N"></a>Segment_N</h4><p>格式：</p>
<p><img src="/images/lucene-index-files/lucene-segments-n.png" alt="Lucene Segment_N"></p>
<p>其中N作为后缀，是36进制的数字, 实现方式为：<code>Long.toString(gen, Character.MAX_RADIX)</code>。</p>
<p>segments_N里通过SegName记录了这索引里<strong>所有.si文件名</strong>。</p>
<h4 id="segment格式（-si）"><a href="#segment格式（-si）" class="headerlink" title="segment格式（.si）"></a>segment格式（.si）</h4><p>格式：</p>
<p><img src="/images/lucene-index-files/lucene-si.png" alt="Lucene segment"></p>
<p>由于一个segment文件，就是一个独立的子索引，其中Files是一个列表，里面存储了本segment所有相关的索引文件。类似长这样：</p>
<pre><code>_8qh.dii
_8qh.dim
_8qh.fdt
_8qh.fdx
_8qh.fnm
_8qh_Lucene50_0.doc
_8qh_Lucene50_0.pos
_8qh_Lucene50_0.tim
_8qh_Lucene50_0.tip
_8qh_Lucene70_0.dvd
_8qh_Lucene70_0.dvm
_8qh.si    
</code></pre><p>IndexSort作为新加入的一个特性，也直接体现在了.si文件里。IndexSort可以加速排序，极大提升性能。</p>
<h4 id="Field-info格式（-fnm）"><a href="#Field-info格式（-fnm）" class="headerlink" title="Field info格式（.fnm）"></a>Field info格式（.fnm）</h4><p>格式：</p>
<p><img src="/images/lucene-index-files/lucene-fnm.png" alt="Lucene Filed info"></p>
<p>存储了Document所包含的FieldName以及Field的内部表示FieldNumber（可以理解为ID）。 同时，每个Field相关索引配置，都通过byte来存储保存下来。</p>
<p>其中DocValueBits里，不同类型的Field, 处理DocValue数据是不一样的，此处暂时按下不表。后续产出</p>
<h4 id="Field-Data格式（-fdx-fdt）"><a href="#Field-Data格式（-fdx-fdt）" class="headerlink" title="Field Data格式（.fdx, .fdt）"></a>Field Data格式（.fdx, .fdt）</h4><p>格式如下所示：</p>
<p><img src="/images/lucene-index-files/lucene-fdt.png" alt=""></p>
<p>由于fdt正排信息很多，在存到磁盘的时候，使用<strong>LZ4算法</strong>进行了压缩。每个Chunk大小16KB(<code>1&lt;&lt;14</code>), Doc个数不能超过128个。在fdx中每个Block有1024个Chunk。</p>
<p>CompressDocs是压缩后进行存储的，为了方便理解，可以认为就是一系列的Doc构成的。每个Doc又包含FieldNumAndType和实际的Field Value。</p>
<p>其中FieldNumAndType是一个VLong: <strong>低3位</strong>表示Field Type, 其余<strong>高位</strong>用来表示FieldNumber.  可见Lucene为了最大程度的节省空间，做了很多的Trick.</p>
<h4 id="Term-Index格式（-tip-tim）"><a href="#Term-Index格式（-tip-tim）" class="headerlink" title="Term Index格式（.tip,.tim）"></a>Term Index格式（.tip,.tim）</h4><p><a href="https://lucene.apache.org/core/7_5_0/core/org/apache/lucene/codecs/blocktree/BlockTreeTermsWriter.html" target="_blank" rel="external">格式</a>如下：</p>
<p>.tip:</p>
<p>​    Header, FSTIndex&lt; IndexStartFP&gt;…, DirOffset, Footer</p>
<p>.tim</p>
<p>​    Header, <em>PostingsHeader</em>, NodeBlock(…), FieldSummary, DirOffset, Footer</p>
<p>图例如下：</p>
<p><img src="/images/lucene-index-files/lucene-tim.png" alt="lucene Term Index &amp; Term Dictionary"></p>
<p>其中FST部分，是直接加载到内存的，详见另外一篇博文，这里为方便理解，直接写画为类TRIE一样。</p>
<h4 id="Pos列表（-doc-pos-pay）"><a href="#Pos列表（-doc-pos-pay）" class="headerlink" title="Pos列表（.doc, .pos, .pay）"></a>Pos列表（.doc, .pos, .pay）</h4><p>doc格式如下：</p>
<p><img src="/images/lucene-index-files/lucene-doc.png" alt="Lucene posting list"></p>
<p>需要注意的是，PackedBlock是对倒排列表的压缩，每128个作为一个Block，不能凑整的情况下，再按VIntBlock进行存储。无论如何存储，Block内部是存储了DocID（<code>PackedDocDeltaBlock</code>）和Term Freq(<code>PackedFreqBlock</code>)的对应关系的。</p>
<p>而Postings则是以SKIPLIST（跳表）进行存储的，这种存储格式保证了快速的查找和归并操作。最底层的SkipDatum通过DocSkip保有对实际doc的指针。PosFPSkip则指向.pos文件，PayFPSkip指向了.pay文件。</p>
<p>pos文件格式：</p>
<p><img src="/images/lucene-index-files/lucene-pos.png" alt="Lucene Position"></p>
<p>这里的PackedPosDeltaBlock与doc文件的很像，也是进行了压缩成block进行存储。最终通过PostionDelta和OffsetDelta来获取相关的位置和偏移信息。</p>
<p>pay格式：</p>
<p><img src="/images/lucene-index-files/lucene-pay.png" alt="Lucene payload"></p>
<p>同样做了Block处理，这个文件通过TermPayloads保留了Term和Payload的对应关系；通过TermOffsets保存了Term和Offset的对应关系。</p>
<h4 id="LIV文件格式-liv"><a href="#LIV文件格式-liv" class="headerlink" title="LIV文件格式(.liv)"></a>LIV文件格式(.liv)</h4><p>格式如下：</p>
<p><img src="/images/lucene-index-files/lucene-liv.png" alt="Lucene live document"></p>
<p>通过FixBitSet位图，来表示哪些是存活的，哪些是被删除的。FixBitSet的底层是通过<code>long[]</code>来模拟实现这样一个大的位图的。</p>
<p>Lucene的4.0版本之前是通过.del文件来标记哪些DocID是被删除的，而现在则改为.liv标记哪些是存活的。个人而言，没有看出来具体原因，毕竟功能实现其实是一样的。</p>
<h4 id="TermVector-tvx-tvd"><a href="#TermVector-tvx-tvd" class="headerlink" title="TermVector(.tvx, .tvd)"></a>TermVector(.tvx, .tvd)</h4><p>格式如下：</p>
<p><img src="/images/lucene-index-files/lucene-tvd.png" alt="Lucene TermVector"></p>
<p>这个格式和Field Data的很相似。区别在于最底层的Chunk直接保留了相关的信息TermFreqs、Positions、StartOffsets、TermAndPayLoads等信息。</p>
<p>从这里也可以看出Term Vector保存的信息很多都是和之前重复的，如果没有必要，完全可以关闭Term Vector功能，避免额外的性能损耗。  </p>
<h4 id="Norms-nvm-nvd"><a href="#Norms-nvm-nvd" class="headerlink" title="Norms (.nvm, .nvd)"></a>Norms (.nvm, .nvd)</h4><p>格式如下：</p>
<p><img src="/images/lucene-index-files/lucene-nvd.png" alt="Lucene Norms"></p>
<p>Norms信息通常是用来存储Field\Document的Boost加权信息，然后Lucene7之后，去除了Index时的boost加权操作。因此，目前Norms里存储的东西极少，有逐步被取消的的可能性。</p>
<h4 id="Doc-Values-dvx-dvd"><a href="#Doc-Values-dvx-dvd" class="headerlink" title="Doc Values(.dvx, .dvd)"></a>Doc Values(.dvx, .dvd)</h4><p>DocValues部分，比较复杂，以至于官方文档都没有给出详细的索引格式。以后将作为一个独立的文章还具体解释。</p>
<h4 id="Point-Values-dii，-dim"><a href="#Point-Values-dii，-dim" class="headerlink" title="Point Values(.dii，.dim)"></a>Point Values(.dii，.dim)</h4><p>Lucene7之后，彻底去除了之前关于数字类型索引和查找的逻辑。之前的TrieInt, TrieLong等完全被删除。取而代之的是IntPoint,LongPoint等类型。</p>
<p>这些类型都是由BKD-Tree来实现的，Point Value被用来实现N-Dimension多维数据的索引和快速的查询，有统一数字型查询、2D位置、3D乃至8D数据查询的趋势，这块将单独作为一个文章进行详细解读。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Lucene索引及其格式，是Solr以及ElasticSearch等分布式搜索引擎的根基。Lucene每一次核心功能的迭代与性能提升都是至关重要的。对Lucene索引过程以及索引文件格式的理解，有助于从更高层面来分析和看待生产环境出现的问题。</p>
<hr>
<p>参考文档：</p>
<p><a href="https://lucene.apache.org/core/7_5_0/core/org/apache/lucene/codecs/lucene70/package-summary.html" target="_blank" rel="external">Lucene Java DOC</a></p>
<p><a href="http://blog.51cto.com/sbp810050504" target="_blank" rel="external">sbp810050504的blog</a></p>
<p><a href="https://www.cnblogs.com/forfuture1978/" target="_blank" rel="external">刘超觉先的博客</a></p>
<p><a href="https://www.manning.com/books/lucene-in-action-second-edition" target="_blank" rel="external">Lucene in Action</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近2年，整个开源搜索引擎领域，发展迅速，版本迭代很快。 Lucene最近两年从4.0版本已经发布到最新的7.5.0版本，Solr和Elasticsearch也不断跟进升级。Lucene作为核心包，互联网上或者是书籍上关于它的介绍和分析都比较陈旧了，很多都是基于Lucene3.x来。是时候，从底层来分析下最新的Lucene发展情况了。&lt;/p&gt;
&lt;p&gt;本文，依Lucene 7.5.0（当时最新）版本描述。&lt;/p&gt;
&lt;h3 id=&quot;Lucene索引文件的表现&quot;&gt;&lt;a href=&quot;#Lucene索引文件的表现&quot; class=&quot;headerlink&quot; title=&quot;Lucene索引文件的表现&quot;&gt;&lt;/a&gt;Lucene索引文件的表现&lt;/h3&gt;&lt;p&gt;Lucene索引在硬盘上的&lt;strong&gt;表现&lt;/strong&gt;就是一系列的文件，后缀名不同，下面是一个样例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/lucene-index-files/lucene-index-on-disk.jpg&quot; alt=&quot;lucene 索引文件&quot;&gt;&lt;/p&gt;
&lt;p&gt;通常，看到这些文件，我们就想打开看看，发现根本无法直接查看。这里存的到底是什么，都有什么作用。很多时候是一脸的懵。为了更好的理解这些文件，下面将一步步进行细致的分析。&lt;/p&gt;
    
    </summary>
    
      <category term="lucene" scheme="https://www.shenyanchao.cn/categories/lucene/"/>
    
    
      <category term="lucene" scheme="https://www.shenyanchao.cn/tags/lucene/"/>
    
      <category term="index" scheme="https://www.shenyanchao.cn/tags/index/"/>
    
      <category term="lucene7" scheme="https://www.shenyanchao.cn/tags/lucene7/"/>
    
  </entry>
  
  <entry>
    <title>Lucene数字类型处理</title>
    <link href="https://www.shenyanchao.cn/blog/2018/12/04/lucene-numberic/"/>
    <id>https://www.shenyanchao.cn/blog/2018/12/04/lucene-numberic/</id>
    <published>2018-12-04T04:35:48.000Z</published>
    <updated>2018-12-04T13:49:18.932Z</updated>
    
    <content type="html"><![CDATA[<p>TODO</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;TODO&lt;/p&gt;

    
    </summary>
    
    
      <category term="lucene" scheme="https://www.shenyanchao.cn/tags/lucene/"/>
    
  </entry>
  
  <entry>
    <title>关于Lucene的词典FST深入剖析</title>
    <link href="https://www.shenyanchao.cn/blog/2018/12/04/lucene-fst/"/>
    <id>https://www.shenyanchao.cn/blog/2018/12/04/lucene-fst/</id>
    <published>2018-12-04T04:35:25.000Z</published>
    <updated>2018-12-20T11:59:20.155Z</updated>
    
    <content type="html"><![CDATA[<h3 id="搜索引擎为什么能查询速度那么快？"><a href="#搜索引擎为什么能查询速度那么快？" class="headerlink" title="搜索引擎为什么能查询速度那么快？"></a>搜索引擎为什么能查询速度那么快？</h3><p>核心是在于如何快速的依据<strong>查询词</strong>快速的查找到所有的相关文档，这也是<strong>倒排索引（Inverted Index）</strong>的核心思想。那么如何设计一个快速的(常量，或者1)定位词典的数据结构就显得尤其重要。简单来说，我们可以采用HashMap， TRIE， Binary Search Tree， Tenary Search Tree等各种数据结构来实现。</p>
<p>那么开源的搜索引擎包Lucene是怎么来设计的呢？Lucene采用了一种称为FST（Finite State Transducer）的结构来构建词典，这个结构保证了时间和空间复杂度的均衡，是Lucene的核心功能之一。</p>
<h3 id="关于FST（Finite-State-Transducer）"><a href="#关于FST（Finite-State-Transducer）" class="headerlink" title="关于FST（Finite State Transducer）"></a>关于FST（Finite State Transducer）</h3><p>FST类似一种TRIE树。</p>
<h4 id="使用FSM-Finite-State-Machines-作为数据结构"><a href="#使用FSM-Finite-State-Machines-作为数据结构" class="headerlink" title="使用FSM(Finite State Machines)作为数据结构"></a>使用FSM(Finite State Machines)作为数据结构</h4><p><strong>FSM(Finite State Machines)有限状态机</strong>: 表示有限个状态（State）集合以及这些状态之间<strong>转移</strong>和动作的数学模型。其中一个状态被标记为<strong>开始状态</strong>，0个或更多的状态被标记为<strong>final状态</strong>。<br>一个FSM同一时间只处于1个状态。FSM很通用，可以用来表示多种处理过程，下面的FSM描述了《小猫咪的一天》。   </p>
<p><img src="/images/lucene-fst/fst/fst-cauchy.png" alt="fsm 小猫咪的一天"></p>
<p>其中“睡觉”或者“吃饭”代表的是<strong>状态</strong>,而“提供食物”或者“东西移动”则代表了<strong>转移</strong>。图中这个FSM是对小猫活动的一个抽象（这里并没有刻意写开始状态或者final状态），小猫咪不能同时的即处于“玩耍”又处于“睡觉”状态，并且从一个状态到下一个状态的转换只有一个输入。“睡觉”状态并不知道是从什么状态转换过来的，可能是“玩耍”，也可能是”猫砂窝”。</p>
<p>如果《小猫咪的一天》这个FSM接收以下的输入:  </p>
<ul>
<li>提供食物</li>
<li>有大声音</li>
<li>安静</li>
<li>消化食物</li>
</ul>
<p>那么我们会明确的知道，小猫咪会这样依次变化状态： 睡觉-&gt;吃饭-&gt;躲藏-&gt;吃饭-&gt;猫砂窝. </p>
<a id="more"></a>
<p>以上只是一个现实中的例子，下面我们来看如何实现一个Ordered Sets,和Map结构。</p>
<h4 id="Ordered-Sets"><a href="#Ordered-Sets" class="headerlink" title="Ordered Sets"></a>Ordered Sets</h4><p>Ordered Sets是一个有序集合。通常一个有序集合可以用二叉树、B树实现。无序的集合使用hash table来实现. 这里，我们用一个<strong>确定无环有限状态接收机（Deterministric acyclic finite state acceptor, FSA）</strong>来实现。</p>
<p>FSA是一个FSM(有限状态机)的一种，特性如下:</p>
<ul>
<li>确定：意味着指定任何一个状态，只可能最多有一个转移可以遍历到?。</li>
<li>无环： 不可能重复遍历同一个状态</li>
<li>接收机：有限状态机只“接受”特定的输入序列，并终止于final状态。</li>
</ul>
<p>下面来看，我们如何来表示只有一个key：”<strong>jul</strong>“ 的集合。FSA是这样的：   </p>
<p><img src="/images/lucene-fst/fst/fst-set1.png" alt="fsm"></p>
<p>当查询这个FSA是否包含“jul”的时候，按字符依序输入。</p>
<ul>
<li>输入j，FSA从0-&gt;1</li>
<li>输入u, FSA从1-&gt;2</li>
<li>输入l，FSA从2-&gt;3</li>
</ul>
<p>这个时候，FSA处于final状态3，所以“jul”是在这个集合的。 </p>
<p>设想一下如果输入“jun”，在状态2的时候<strong>无法移动</strong>了，就知道不在这个集合里了。<br>设想如何输入“ju”, 在状态2的时候，已经没有输入了。而状态2并不是<strong>final状态</strong>，所以也不在这个集合里。<br>值得指出的是，查找这个key是否在集合内的时间复杂度，取决于key的长度，而不是集合的大小。<br>​<br>现在往FSA里再加一个key.  FSA此时包含keys:”jul”和“mar”。    </p>
<p><img src="/images/lucene-fst/fst/fst-set2.png" alt="fsm"></p>
<p>start状态0此时有了2个转移：<strong>j</strong>和<strong>m</strong>。因此，输入key:”mar”,首先会跟随m来转移。 final状态是“jul”和“mar”<strong>共享</strong>的。这使得我们能用<strong>更少的空间</strong>来表示<strong>更多的信息</strong>。 </p>
<p>当我们在这个FSA里加入“jun”，那么它和“jul”有共同的前缀“ju”: </p>
<p><img src="/images/lucene-fst/fst/fst-set3.png" alt="fsm"></p>
<p>这里变化很小，没有增加新的状态，只是多了一个转移而已。</p>
<p>下面来看一下由“october”，“november”,”december”构成的FSA.</p>
<p><img src="/images/lucene-fst/fst/fst-set3-suffixes.png" alt="fsm"></p>
<p>它们有共同的后缀“ber”，所以在FSA只出现了1次。 其中2个有共同的后缀”ember”，也只出现了1次。    </p>
<p>那么我们如何来遍历一个FSA表示的所有key呢，我们以前面的”jul”，“jun”,”mar”为例：</p>
<p><img src="/images/lucene-fst/fst/fst-set3.png" alt="fsm"></p>
<p><strong>遍历算法</strong>是这样的：</p>
<ul>
<li>初始状态0， key=””</li>
<li>-&gt;1, key=”j”</li>
<li>-&gt;2, key=”ju”</li>
<li>-&gt;3, key=”jul”, 找到jul</li>
<li>2&lt;-, key=”ju”</li>
<li>-&gt;3, key=”jun”, 找到jun</li>
<li>2&lt;-, key=”ju”</li>
<li>1&lt;-, key=”j”</li>
<li>0&lt;-, key=””</li>
<li>-&gt;4, key=”m”</li>
<li>-&gt;5, key=”ma”,</li>
<li>-&gt;3, key=”mar”,找到mar</li>
</ul>
<p>这个算法时间复杂度O(n),n是集合里所有的key的大小, 空间复杂度O(k),k是结合内最长的key字段length。</p>
<h4 id="Ordered-maps"><a href="#Ordered-maps" class="headerlink" title="Ordered maps"></a>Ordered maps</h4><p>Ordered maps就像一个普通的map，只不过它的key是有序的。我们来看一下如何使用<strong>确定无环状态转换器（Deterministic acyclic finite state transducer， FST）</strong>来实现它。</p>
<p>FST是也一个有限状态机（FSM）,具有这样的特性：  </p>
<ul>
<li>确定：意味着指定任何一个状态，只可能最多有一个转移可以遍历到。</li>
<li>无环： 不可能重复遍历同一个状态</li>
<li>transducer：接收特定的序列，终止于final状态，同时会<strong>输出一个值</strong>。</li>
</ul>
<p>FST和FSA很像，给定一个key除了能回答是否存在，还能输出一个<strong>关联的值</strong>。  </p>
<p>下面来看这样的一个输入：“jul:7”, 7是jul关联的值，就像是一个map的entry. </p>
<p><img src="/images/lucene-fst/fst/fst-map1.png" alt="fst"></p>
<p>这和对应的有序集合基本一样，除了第一个0-&gt;1的转换j关联了一个值7. 其他的转换u和l,<strong>默认关联</strong>的值是<strong>0</strong>,这里不予展现。  </p>
<p>那么当我们查找key:”jul”的时候，大概流程如下：</p>
<ul>
<li>初始状态0 </li>
<li>输入j, FST从0-&gt;1， value=7</li>
<li>输入u， FST从1-&gt;2， value=7+0</li>
<li>输入l，FST从2-&gt;3, value=7+0+0</li>
</ul>
<p>此时，FST处于final状态3，所以存在jul，并且给出output是7.</p>
<p>我们再看一下，加入mar:3之后，FST变成什么样：</p>
<p><img src="/images/lucene-fst/fst/fst-map2.png" alt="fst"></p>
<p>同样的很简单，<strong>需要注意</strong>的是mar自带的值3放在了第1个转移上。这只是为了算法更简单而已，事实上，可以放在其他转移上。  </p>
<p>如果共享前缀，FST会发生什么呢？这里我们继续加入jun:6。</p>
<p><img src="/images/lucene-fst/fst/fst-map3.png" alt="fst"></p>
<p>和sets一样，jun和jul共享状态3， 但是有一些变化。</p>
<ul>
<li>0-&gt;1转移，输出从7变成了6</li>
<li>2-&gt;3转移，输入l，输出值变成了1。</li>
</ul>
<p>这个输出变化是很重要的，因为他改变了查找jul输出值的过程。</p>
<ul>
<li>初始状态0</li>
<li>输入j, FST从0-&gt;1， value=6</li>
<li>输入u， FST从1-&gt;2， value=6+0</li>
<li>输入l，FST从2-&gt;3, value=6+0+1</li>
</ul>
<p>最终的值仍旧是7，但是走的路径却是不一样的。<br>那查找jun是不是也是正确的呢？</p>
<ul>
<li>初始状态0</li>
<li>输入j, FST从0 -&gt; 1， value=6</li>
<li>输入u，FST从1 -&gt; 2， value=6+0</li>
<li>输入n，FST从2 -&gt; 3, value=6+0+0</li>
</ul>
<p>从上可知，jun的查询也是正确的。FST保证了不同的转移有<strong>唯一</strong>的值，但同时也复用了大部分的数据结构。    </p>
<p>实现共享状态的<strong>关键点</strong>是：每一个key,都在FST中对应一个唯一的路径。因此，对于任何一个特定的key，总会有一些value的转移组合使得路径是唯一的。我们需要做的就是如何来在转移中<strong>分配</strong>这些组合。</p>
<p>key输出的共享机制同样适用于共同前缀和共同后缀。比如我们有tuesday:3和thursday:5这样的FST:   </p>
<p><img src="/images/lucene-fst/fst/fst-map2-suffixes.png" alt="fst"></p>
<p>2个key有共同的前缀<strong>t</strong>，共同后缀<strong>sday</strong>。关联的2个value同样有共同的前缀。3可以写做<strong>3+0</strong>，而5可以写作：<strong>3+2</strong>。 这样很好的让实现了关联value的共享。   </p>
<p>上面的这个例子，其实有点简单化，并且局限。假如这些关联的value并不是int呢？ 实际上，FST对于关联value(outputs)的类型是要求必须有以下操作（method）的。</p>
<ul>
<li>加（Addition）</li>
<li>减 (Subtraction)</li>
<li>取前缀 (对于整数来说，就是min)</li>
</ul>
<h3 id="FST的构建"><a href="#FST的构建" class="headerlink" title="FST的构建"></a>FST的构建</h3><p>前面，一直没有提到如何构建FST。构建相对于遍历来说，还是有些复杂的。<br>为了简单化，我们假设set或者map里的数据是按字典序加入的。这个假设是很沉重的限制，不过我们会讲如何来缓解它。</p>
<p>为了构建FSM，我们先来看看TRIE树是如何构建的。</p>
<h4 id="TRIE树的构建"><a href="#TRIE树的构建" class="headerlink" title="TRIE树的构建"></a>TRIE树的构建</h4><p>TRIE可以看做是一个FSA,唯一的一个不同是TRIE只共享前缀，而FSA不仅共享前缀还共享后缀。</p>
<p>假设我们有一个这样的Set: mon,tues,thurs。FSA是这样的： </p>
<p><img src="/images/lucene-fst/fst/fst-days3.png" alt="fst"></p>
<p>相应的TRIE则是这样的，只共享了前缀。</p>
<p><img src="/images/lucene-fst/fst/fst-days3-trie.png" alt="fst trie"></p>
<p>TRIE有重复的3个final状态3，8，11. 而8，11都是s转移，是可以合并的。</p>
<p>构建一个TRIE树是相当简单的。插入1个key，只需要做简单的查找就可以了。如果输入先结束，那么当前状态设置为final；如果无法转移了，那么就直接创建新的转移和状态。不要忘了最后一个创建的状态设置为final就可以了。</p>
<h4 id="FST的构建-1"><a href="#FST的构建-1" class="headerlink" title="FST的构建"></a>FST的构建</h4><p>构建FST在很大程度上和构建FSA是一样的，主要的不同点是，怎么样在转移上<strong>放置和共享outputs</strong>。   </p>
<p>仍旧使用前面提到的例子，mon,tues和thurs，并给他们关联相应的星期数值2，3和5.  </p>
<p>从第1个key, mon:2开始：</p>
<p><img src="/images/lucene-fst/fst/fst-days3-fst-1.png" alt="fst mon">   </p>
<p>这里虚线代表，在后续的insert过程中，FST可能有变化。    </p>
<p>需要关注的是，这里只是把2放在了第1个转移上。技术上说，下面这样分配也是正确的。</p>
<p><img src="/images/lucene-fst/fst/fst-days3-fst-1-alt.png" alt="fst mon alt">   </p>
<p>只不过，把output放在靠近start状态的算法更容易写而已。</p>
<p>下面继续把thurs:5插入：</p>
<p><img src="/images/lucene-fst/fst/fst-days3-fst-2.png" alt="fst mon thurs">   </p>
<p>就像FSA的insert一样，插入thurs之后，我们可以知道FST的mon部分（蓝色）就不会再变了。</p>
<p>由于mon和thurs没有共同的前缀，只是简单的2个map中的key. 所以他们的output value可以直接放置在start状态的第1个转移上。</p>
<p>下面，继续插入tues:3，</p>
<p><img src="/images/lucene-fst/fst/fst-days3-fst-3.png" alt="fst">   </p>
<p>这引起了新的变化。有一部分被<strong>冻住</strong>了，并且知道以后不会再修改了。output value也出现了重新的分配。因为tues的output是3，并且tues和thurs有共同的前缀t, 所以5和3的prefix操作得出的结果就是3. 状态0-&gt;状态4的value被分配为3，状态4-&gt;状态5设置为2。</p>
<p>我们再插入更多的key, 这次插入tye:99看发生什么情况：</p>
<p><img src="/images/lucene-fst/fst/fst-days3-fst-4.png" alt="fst">   </p>
<p>插入tye，导致”es”部分被冻住，同时由于共享前缀t, 状态4-&gt;状态9的输出是99-3=96。</p>
<p>最后一步，结束了，再执行一次冻住操作。</p>
<p>最终的FST长这样：</p>
<p><img src="/images/lucene-fst/fst/fst-days3-fst-5.png" alt="fst">   </p>
<h3 id="Lucene-FST"><a href="#Lucene-FST" class="headerlink" title="Lucene FST"></a>Lucene FST</h3><p>上一部分，对于FST的概念以及构建进行了详细的介绍。本部分将对Lucene FST的实现以及具体进行详细的分析。<br>Lucene关于FST相关的代码在package:<code>org.apache.lucene.util.fst</code>。    </p>
<p>从<code>org.apache.lucene.util.fst.Builder</code>看起，这个是构建FST的Builder：</p>
<p><img src="/images/lucene-fst/fst/lucene-fst-builder.png" alt="fst builder lucene">   </p>
<p>Builder通过泛型T，从而可以构建包含不同类型的FST。我们重点关注属性。</p>
<p>从其中插入数据<code>add()</code>方法看起： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** Add the next input/output pair.  The provided input</span></div><div class="line">   *  must be sorted after the previous one according to</div><div class="line">   *  &#123;<span class="doctag">@link</span> IntsRef#compareTo&#125;.  It's also OK to add the same</div><div class="line">   *  input twice in a row with different outputs, as long</div><div class="line">   *  as &#123;<span class="doctag">@link</span> Outputs&#125; implements the &#123;<span class="doctag">@link</span> Outputs#merge&#125;</div><div class="line">   *  method. Note that input is fully consumed after this</div><div class="line">   *  method is returned (so caller is free to reuse), but</div><div class="line">   *  output is not.  So if your outputs are changeable (eg</div><div class="line">   *  &#123;<span class="doctag">@link</span> ByteSequenceOutputs&#125; or &#123;<span class="doctag">@link</span></div><div class="line">   *  IntSequenceOutputs&#125;) then you cannot reuse across</div><div class="line">   *  calls. */</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(IntsRef input, T output)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line"></div><div class="line">    ...</div><div class="line">    <span class="comment">// prefixLenPlus1是计算出input和lastInput具有公共前缀的位置</span></div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> prefixLenPlus1 = pos1+<span class="number">1</span>;</div><div class="line"></div><div class="line">     <span class="comment">// 1.新插入的节点放到frontier数组，UnCompileNode表明是新插入的，以后还可能会变化，还未放入FST内。</span></div><div class="line">    <span class="keyword">if</span> (frontier.length &lt; input.length+<span class="number">1</span>) &#123;</div><div class="line">      <span class="keyword">final</span> UnCompiledNode&lt;T&gt;[] next = ArrayUtil.grow(frontier, input.length+<span class="number">1</span>);</div><div class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> idx=frontier.length;idx&lt;next.length;idx++) &#123;</div><div class="line">        next[idx] = <span class="keyword">new</span> UnCompiledNode&lt;&gt;(<span class="keyword">this</span>, idx);</div><div class="line">      &#125;</div><div class="line">      frontier = next;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// minimize/compile states from previous input's</span></div><div class="line">    <span class="comment">// orphan'd suffix</span></div><div class="line"></div><div class="line">    <span class="comment">// 2.从prefixLenPlus1, 进行freeze冰冻操作, 添加并构建最小FST</span></div><div class="line">    freezeTail(prefixLenPlus1);</div><div class="line"></div><div class="line">    <span class="comment">// init tail states for current input</span></div><div class="line">    <span class="comment">// 3.将当前input剩下的部分插入，构建arc转移（前缀是共用的，不用添加新的状态）。</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> idx=prefixLenPlus1;idx&lt;=input.length;idx++) &#123;</div><div class="line">      frontier[idx-<span class="number">1</span>].addArc(input.ints[input.offset + idx - <span class="number">1</span>],</div><div class="line">                             frontier[idx]);</div><div class="line">      frontier[idx].inputCount++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">final</span> UnCompiledNode&lt;T&gt; lastNode = frontier[input.length];</div><div class="line">    <span class="keyword">if</span> (lastInput.length() != input.length || prefixLenPlus1 != input.length + <span class="number">1</span>) &#123;</div><div class="line">      lastNode.isFinal = <span class="keyword">true</span>;</div><div class="line">      lastNode.output = NO_OUTPUT;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// push conflicting outputs forward, only as far as</span></div><div class="line">    <span class="comment">// needed</span></div><div class="line">    <span class="comment">// 4.如果有冲突的话，重新分配output值</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> idx=<span class="number">1</span>;idx&lt;prefixLenPlus1;idx++) &#123;</div><div class="line">      <span class="keyword">final</span> UnCompiledNode&lt;T&gt; node = frontier[idx];</div><div class="line">      <span class="keyword">final</span> UnCompiledNode&lt;T&gt; parentNode = frontier[idx-<span class="number">1</span>];</div><div class="line"></div><div class="line">      <span class="keyword">final</span> T lastOutput = parentNode.getLastOutput(input.ints[input.offset + idx - <span class="number">1</span>]);</div><div class="line">      <span class="function"><span class="keyword">assert</span> <span class="title">validOutput</span><span class="params">(lastOutput)</span></span>;</div><div class="line"></div><div class="line">      <span class="keyword">final</span> T commonOutputPrefix;</div><div class="line">      <span class="keyword">final</span> T wordSuffix;</div><div class="line"></div><div class="line">      <span class="keyword">if</span> (lastOutput != NO_OUTPUT) &#123;</div><div class="line">        <span class="comment">// 使用common方法，计算output的共同前缀</span></div><div class="line">        commonOutputPrefix = fst.outputs.common(output, lastOutput);</div><div class="line">        <span class="function"><span class="keyword">assert</span> <span class="title">validOutput</span><span class="params">(commonOutputPrefix)</span></span>;</div><div class="line">        <span class="comment">// 使用subtract方法，计算重新分配的output</span></div><div class="line">        wordSuffix = fst.outputs.subtract(lastOutput, commonOutputPrefix);</div><div class="line">        <span class="function"><span class="keyword">assert</span> <span class="title">validOutput</span><span class="params">(wordSuffix)</span></span>;</div><div class="line">        parentNode.setLastOutput(input.ints[input.offset + idx - <span class="number">1</span>], commonOutputPrefix);</div><div class="line">        node.prependOutput(wordSuffix);</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        commonOutputPrefix = wordSuffix = NO_OUTPUT;</div><div class="line">      &#125;</div><div class="line">      output = fst.outputs.subtract(output, commonOutputPrefix);</div><div class="line">      <span class="function"><span class="keyword">assert</span> <span class="title">validOutput</span><span class="params">(output)</span></span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ...</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>通过注释，我们看到input是经过排序的，也就是ordered。否则生成的就不是最小的FST。另外如果NO_OUTPUT就退化为FSA了，不用执行第4步重新分配output了。</p>
<p>其中<code>freezeTail</code> 方法就是将不再变化的部分进行冰冻，又叫compile，把UnCompileNode，给构建进FST里。进入到FST是先进行compileNode, 然后addNode进去的。</p>
<p>总结以下，加入节点过程：</p>
<ul>
<li><ol>
<li>新插入input放入frontier，这里还没有加入FST</li>
</ol>
</li>
<li><ol>
<li>依据当前input, 对上次插入数据进行freezeTail操作, 放入FST内</li>
</ol>
</li>
<li><ol>
<li>构建input的转移（Arc）关系</li>
</ol>
</li>
<li><ol>
<li>解决Output冲突，重新分配output，保证路径统一(NO_OUTPUT,不执行)</li>
</ol>
</li>
</ul>
<p>最后在<code>finish</code>方法里，执行<code>freezeTail(0)</code>, 把所有的input构建进FST内。</p>
<p>另外，值得注意的是Lucene里定义的<strong>Outputs</strong>类型：</p>
<p><img src="/images/lucene-fst/fst/lucene-fst-outputs.png" alt="fst">  </p>
<p>其中3个method是Outputs接口定义的，有11个不同类型的实现:</p>
<ul>
<li><code>T add(T prefix, T output);</code> 加</li>
<li><code>T subtract(T output, T inc);</code> 减</li>
<li><code>T common(T output1, T output2)</code> 前缀</li>
</ul>
<p>完全满足我们上个部分的限制，可见就是基于之前算法的一个完整的实现。    </p>
<p>除了在Term词典这块有应用，FST在整个lucene内部使用的也是很广泛的，基本把hashmap记性了替换。<br>场景大概有以下：  </p>
<ul>
<li>自动联想：suggester</li>
<li>charFilter: mappingcharFilter</li>
<li>同义词过滤器</li>
<li>hunspell拼写检查词典</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>FST，不但能<strong>共享前缀</strong>还能<strong>共享后缀</strong>。不但能判断查找的key是否存在，还能给出响应的输入output。 它在时间复杂度和空间复杂度上都做了最大程度的优化，使得Lucene能够将Term Dictionary完全加载到内存，快速的定位Term找到响应的output（posting倒排列表）。</p>
<hr>
<p>参考文档：   </p>
<p><a href="http://www.cs.uvm.edu/~xwu/wie/CourseSlides/Schips-BurstTries.pdf" target="_blank" rel="external">Burst Tries</a><br><a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.24.3698" target="_blank" rel="external">Direct Construction of Minimal Acyclic Subsequential Transducers</a><br><a href="https://blog.burntsushi.net/transducers/" target="_blank" rel="external">Index 1,600,000,000 Keys with Automata and Rust</a><br><a href="https://en.wikipedia.org/wiki/DFA_minimization" target="_blank" rel="external">DFA minimization WikiPedia</a><br><a href="http://www.cs.put.poznan.pl/dweiss/site/publications/download/fsacomp.pdf" target="_blank" rel="external">Smaller Representation of Finite State Automata</a><br><a href="http://blog.mikemccandless.com/2010/12/using-finite-state-transducers-in.html" target="_blank" rel="external">Using Finite State Transducers in Lucene</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;搜索引擎为什么能查询速度那么快？&quot;&gt;&lt;a href=&quot;#搜索引擎为什么能查询速度那么快？&quot; class=&quot;headerlink&quot; title=&quot;搜索引擎为什么能查询速度那么快？&quot;&gt;&lt;/a&gt;搜索引擎为什么能查询速度那么快？&lt;/h3&gt;&lt;p&gt;核心是在于如何快速的依据&lt;strong&gt;查询词&lt;/strong&gt;快速的查找到所有的相关文档，这也是&lt;strong&gt;倒排索引（Inverted Index）&lt;/strong&gt;的核心思想。那么如何设计一个快速的(常量，或者1)定位词典的数据结构就显得尤其重要。简单来说，我们可以采用HashMap， TRIE， Binary Search Tree， Tenary Search Tree等各种数据结构来实现。&lt;/p&gt;
&lt;p&gt;那么开源的搜索引擎包Lucene是怎么来设计的呢？Lucene采用了一种称为FST（Finite State Transducer）的结构来构建词典，这个结构保证了时间和空间复杂度的均衡，是Lucene的核心功能之一。&lt;/p&gt;
&lt;h3 id=&quot;关于FST（Finite-State-Transducer）&quot;&gt;&lt;a href=&quot;#关于FST（Finite-State-Transducer）&quot; class=&quot;headerlink&quot; title=&quot;关于FST（Finite State Transducer）&quot;&gt;&lt;/a&gt;关于FST（Finite State Transducer）&lt;/h3&gt;&lt;p&gt;FST类似一种TRIE树。&lt;/p&gt;
&lt;h4 id=&quot;使用FSM-Finite-State-Machines-作为数据结构&quot;&gt;&lt;a href=&quot;#使用FSM-Finite-State-Machines-作为数据结构&quot; class=&quot;headerlink&quot; title=&quot;使用FSM(Finite State Machines)作为数据结构&quot;&gt;&lt;/a&gt;使用FSM(Finite State Machines)作为数据结构&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;FSM(Finite State Machines)有限状态机&lt;/strong&gt;: 表示有限个状态（State）集合以及这些状态之间&lt;strong&gt;转移&lt;/strong&gt;和动作的数学模型。其中一个状态被标记为&lt;strong&gt;开始状态&lt;/strong&gt;，0个或更多的状态被标记为&lt;strong&gt;final状态&lt;/strong&gt;。&lt;br&gt;一个FSM同一时间只处于1个状态。FSM很通用，可以用来表示多种处理过程，下面的FSM描述了《小猫咪的一天》。   &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/lucene-fst/fst/fst-cauchy.png&quot; alt=&quot;fsm 小猫咪的一天&quot;&gt;&lt;/p&gt;
&lt;p&gt;其中“睡觉”或者“吃饭”代表的是&lt;strong&gt;状态&lt;/strong&gt;,而“提供食物”或者“东西移动”则代表了&lt;strong&gt;转移&lt;/strong&gt;。图中这个FSM是对小猫活动的一个抽象（这里并没有刻意写开始状态或者final状态），小猫咪不能同时的即处于“玩耍”又处于“睡觉”状态，并且从一个状态到下一个状态的转换只有一个输入。“睡觉”状态并不知道是从什么状态转换过来的，可能是“玩耍”，也可能是”猫砂窝”。&lt;/p&gt;
&lt;p&gt;如果《小猫咪的一天》这个FSM接收以下的输入:  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;提供食物&lt;/li&gt;
&lt;li&gt;有大声音&lt;/li&gt;
&lt;li&gt;安静&lt;/li&gt;
&lt;li&gt;消化食物&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;那么我们会明确的知道，小猫咪会这样依次变化状态： 睡觉-&amp;gt;吃饭-&amp;gt;躲藏-&amp;gt;吃饭-&amp;gt;猫砂窝. &lt;/p&gt;
    
    </summary>
    
      <category term="lucene" scheme="https://www.shenyanchao.cn/categories/lucene/"/>
    
    
      <category term="lucene" scheme="https://www.shenyanchao.cn/tags/lucene/"/>
    
      <category term="FST" scheme="https://www.shenyanchao.cn/tags/FST/"/>
    
      <category term="FSM" scheme="https://www.shenyanchao.cn/tags/FSM/"/>
    
      <category term="FSA" scheme="https://www.shenyanchao.cn/tags/FSA/"/>
    
  </entry>
  
  <entry>
    <title>利用MAT来分析JAVA内存泄露</title>
    <link href="https://www.shenyanchao.cn/blog/2018/10/29/mat-for-java/"/>
    <id>https://www.shenyanchao.cn/blog/2018/10/29/mat-for-java/</id>
    <published>2018-10-29T06:53:46.000Z</published>
    <updated>2018-12-20T11:59:51.866Z</updated>
    
    <content type="html"><![CDATA[<h3 id="如何DUMP出堆栈"><a href="#如何DUMP出堆栈" class="headerlink" title="如何DUMP出堆栈"></a>如何DUMP出堆栈</h3><h4 id="手动dump"><a href="#手动dump" class="headerlink" title="手动dump"></a>手动dump</h4><pre><code>jmap -dump:format=b,file=&lt;dumpfile.hprof&gt; &lt;pid&gt;
</code></pre><h4 id="JVM参数自动dump"><a href="#JVM参数自动dump" class="headerlink" title="JVM参数自动dump"></a>JVM参数自动dump</h4><pre><code>-XX:+HeapDumpOnOutOfMemoryError
-XX:HeapDumpPath=${heap.dump.path}
</code></pre><h3 id="下载并调整MAT-Eclipse-Memory-Analyze-Tool"><a href="#下载并调整MAT-Eclipse-Memory-Analyze-Tool" class="headerlink" title="下载并调整MAT(Eclipse Memory Analyze Tool)"></a>下载并调整MAT(Eclipse Memory Analyze Tool)</h3><p>下载地址： <a href="https://www.eclipse.org/mat/downloads.php" target="_blank" rel="external">https://www.eclipse.org/mat/downloads.php</a></p>
<p><img src="/images/blog/mat/mat-for-java.jpg" alt="mat"></p>
<p>依据不同的操作系统下载响应版本。</p>
<a id="more"></a>
<h3 id="解析dump出的文件"><a href="#解析dump出的文件" class="headerlink" title="解析dump出的文件"></a>解析dump出的文件</h3><p>通常情况下，dump出的文件是很大的。需要修改一下MemoryAnalyzer.ini，调大<code>-Xmx</code>参数,至少要比要分析的文件相等。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">-startup</div><div class="line">../Eclipse/plugins/org.eclipse.equinox.launcher_1.5.0.v20180512-1130.jar</div><div class="line">--launcher.library</div><div class="line">../Eclipse/plugins/org.eclipse.equinox.launcher.cocoa.macosx.x86_64_1.1.700.v20180518-1200</div><div class="line">-vmargs</div><div class="line">-Xmx10G</div><div class="line">-Dorg.eclipse.swt.internal.carbon.smallFonts</div><div class="line">-XstartOnFirstThread</div></pre></td></tr></table></figure>
<h3 id="无界面执行（LINUX）"><a href="#无界面执行（LINUX）" class="headerlink" title="无界面执行（LINUX）"></a>无界面执行（LINUX）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./ParseHeapDump.sh $&#123;dump.prof&#125; org.eclipse.mat.api:suspects</div></pre></td></tr></table></figure>
<p>还支持另外两个：</p>
<p>org.eclipse.mat.api:overview<br>org.eclipse.mat.api:top_components</p>
<p>执行之后，产生多个zip版html。不过这个版本，没有直接分析出来的好用，有些功能有缺失。</p>
<hr>
<p>其他线上问题常见分析工具：</p>
<p><a href="https://github.com/blueshen/useful-scripts" target="_blank" rel="external">https://github.com/blueshen/useful-scripts</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;如何DUMP出堆栈&quot;&gt;&lt;a href=&quot;#如何DUMP出堆栈&quot; class=&quot;headerlink&quot; title=&quot;如何DUMP出堆栈&quot;&gt;&lt;/a&gt;如何DUMP出堆栈&lt;/h3&gt;&lt;h4 id=&quot;手动dump&quot;&gt;&lt;a href=&quot;#手动dump&quot; class=&quot;headerlink&quot; title=&quot;手动dump&quot;&gt;&lt;/a&gt;手动dump&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;jmap -dump:format=b,file=&amp;lt;dumpfile.hprof&amp;gt; &amp;lt;pid&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;JVM参数自动dump&quot;&gt;&lt;a href=&quot;#JVM参数自动dump&quot; class=&quot;headerlink&quot; title=&quot;JVM参数自动dump&quot;&gt;&lt;/a&gt;JVM参数自动dump&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;-XX:+HeapDumpOnOutOfMemoryError
-XX:HeapDumpPath=${heap.dump.path}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;下载并调整MAT-Eclipse-Memory-Analyze-Tool&quot;&gt;&lt;a href=&quot;#下载并调整MAT-Eclipse-Memory-Analyze-Tool&quot; class=&quot;headerlink&quot; title=&quot;下载并调整MAT(Eclipse Memory Analyze Tool)&quot;&gt;&lt;/a&gt;下载并调整MAT(Eclipse Memory Analyze Tool)&lt;/h3&gt;&lt;p&gt;下载地址： &lt;a href=&quot;https://www.eclipse.org/mat/downloads.php&quot;&gt;https://www.eclipse.org/mat/downloads.php&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/blog/mat/mat-for-java.jpg&quot; alt=&quot;mat&quot;&gt;&lt;/p&gt;
&lt;p&gt;依据不同的操作系统下载响应版本。&lt;/p&gt;
    
    </summary>
    
      <category term="JVM" scheme="https://www.shenyanchao.cn/categories/JVM/"/>
    
    
      <category term="java" scheme="https://www.shenyanchao.cn/tags/java/"/>
    
      <category term="mat" scheme="https://www.shenyanchao.cn/tags/mat/"/>
    
      <category term="OOM" scheme="https://www.shenyanchao.cn/tags/OOM/"/>
    
  </entry>
  
  <entry>
    <title>微服务下的API设计原则</title>
    <link href="https://www.shenyanchao.cn/blog/2018/08/23/the-principle-of-api-design-in-mircoservice/"/>
    <id>https://www.shenyanchao.cn/blog/2018/08/23/the-principle-of-api-design-in-mircoservice/</id>
    <published>2018-08-23T09:05:00.000Z</published>
    <updated>2018-10-23T08:57:54.889Z</updated>
    
    <content type="html"><![CDATA[<h1 id="微服务下的API设计原则"><a href="#微服务下的API设计原则" class="headerlink" title="微服务下的API设计原则"></a>微服务下的API设计原则</h1><p>目的：<br>规范团队乃至公司的API设计。<br>主要参考： <a href="https://developer.github.com/v3/" target="_blank" rel="external">Github API</a></p>
<h2 id="1-为了安全，请使用HTTPS"><a href="#1-为了安全，请使用HTTPS" class="headerlink" title="1. 为了安全，请使用HTTPS"></a>1. 为了安全，请使用HTTPS</h2><p>与API设计无关、为了安全请使用HTTPS。公网API,强制使用HTTPS。内网API可酌情选择。</p>
<h2 id="2-API-地址和版本"><a href="#2-API-地址和版本" class="headerlink" title="2. API 地址和版本"></a>2. API 地址和版本</h2><p>在 <code>url</code> 中指定 API 的版本是个很好地做法。<br>如果 API 变化比较大，可以把API设计为子域名，比如 <code>https://api.ke.com/v3</code>；<br>也可以简单地把版本放在路径中，比如 <code>https://ke.com/api/v1</code>。<br><strong>不建议放入Header</strong>，不直观。</p>
<h2 id="3-schema请使用JSON"><a href="#3-schema请使用JSON" class="headerlink" title="3. schema请使用JSON"></a>3. schema请使用JSON</h2><p>对于响应返回的格式，JSON 因为它的可读性、紧凑性以及多种语言支持等优点，成为了 HTTP API 最常用的返回格式。因此，最好采用<strong>JSON</strong>作为返回内容的格式。</p>
<p><strong>不推荐其他格式</strong>，如果必须使用，比如 <code>xml</code>，应该在请求头部 <code>Accept</code> 中指定。<br>对于不支持的格式，服务端需要返回正确的 <code>status code</code>，并给出详细的说明。</p>
<a id="more"></a>
<h2 id="4-以资源为中心的URL设计"><a href="#4-以资源为中心的URL设计" class="headerlink" title="4. 以资源为中心的URL设计"></a>4. 以资源为中心的URL设计</h2><p>资源是 <code>Restful API</code> 的核心元素，所有的操作都是针对特定资源进行的。而资源就是 <code>URL</code>（Uniform Resoure Locator）表示的，所以简洁、清晰、结构化的 URL 设计是至关重要的。Github 可以说是这方面的典范，下面我们就拿 <code>repository</code> 来说明。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">/users/:username/repos</div><div class="line">/users/:org/repos</div><div class="line">/repos/:owner/:repo</div><div class="line">/repos/:owner/:repo/tags</div><div class="line">/repos/:owner/:repo/branches/:branch</div></pre></td></tr></table></figure>
<p>我们可以看到几个特性：</p>
<ul>
<li>资源分为单个文档和集合，尽量使用复数来表示资源，单个资源通过添加 id 或者 name 等来表示</li>
<li>一个资源可以有多个不同的 URL</li>
<li>资源可以嵌套，通过类似目录路径的方式来表示，以体现它们之间的关系</li>
</ul>
<p><strong>NOTE</strong>: 根据RFC3986定义，URL是大小写敏感的。<strong>建议全部使用小写字母</strong>。</p>
<h2 id="5-使用正确的HTTP-Method"><a href="#5-使用正确的HTTP-Method" class="headerlink" title="5. 使用正确的HTTP Method"></a>5. 使用正确的HTTP Method</h2><p>有了资源的 URL 设计，所有针对资源的操作都是使用 HTTP 方法指定的。比较常用的方法有：</p>
<table>
<thead>
<tr>
<th>METHOD</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>HEAD</td>
<td>只获取某个资源的头部信息。比如只想了解某个文件的大小，某个资源的修改日期等</td>
</tr>
<tr>
<td>GET</td>
<td>获取资源</td>
</tr>
<tr>
<td>POST</td>
<td>创建资源</td>
</tr>
<tr>
<td>PATCH</td>
<td>更新资源的部分属性。因为 PATCH 比较新，而且规范比较复杂，所以真正实现的比较少，一般都是用 POST 替代</td>
</tr>
<tr>
<td>PUT</td>
<td>替换资源，客户端需要提供新建资源的所有属性。如果新内容为空，要设置 <code>Content-Length</code> 为 0，以区别错误信息</td>
</tr>
<tr>
<td>DELETE</td>
<td>删除资源</td>
</tr>
</tbody>
</table>
<p>比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">GET /repos/:owner/:repo/issues</div><div class="line">GET /repos/:owner/:repo/issues/:number</div><div class="line">POST /repos/:owner/:repo/issues</div><div class="line">PATCH /repos/:owner/:repo/issues/:number</div><div class="line">DELETE /repos/:owner/:repo</div></pre></td></tr></table></figure>
<p>建议：依据公司的实际情况，不可能所有的服务都能符合RESTFUL标准。请重点学习使用<code>GET,POST,DELETE</code></p>
<h3 id="不符合-CRUD-的情况"><a href="#不符合-CRUD-的情况" class="headerlink" title="不符合 CRUD 的情况"></a>不符合 CRUD 的情况</h3><p>在实际资源操作中，总会有一些不符合 <code>CRUD</code>（Create-Read-Update-Delete） 的情况，一般有几种处理方法。</p>
<h4 id="使用-POST"><a href="#使用-POST" class="headerlink" title="使用 POST"></a>使用 POST</h4><p>为需要的动作增加一个 endpoint，使用 POST 来执行动作，比如 <code>POST /resend</code> 重新发送邮件。</p>
<h4 id="增加控制参数"><a href="#增加控制参数" class="headerlink" title="增加控制参数"></a>增加控制参数</h4><p>添加动作相关的参数，通过修改参数来控制动作。比如一个博客网站，会有把写好的文章“发布”的功能，可以用上面的 <code>POST /articles/{:id}/publish</code> 方法，也可以在文章中增加 <code>published:boolean</code> 字段，发布的时候就是更新该字段 <code>PUT /articles/{:id}?published=true</code></p>
<h4 id="把动作转换成资源"><a href="#把动作转换成资源" class="headerlink" title="把动作转换成资源"></a>把动作转换成资源</h4><p>把动作转换成可以执行 <code>CRUD</code> 操作的资源， github 就是用了这种方法。</p>
<p>比如“喜欢”一个 gist，就增加一个 <code>/gists/:id/star</code> 子资源，然后对其进行操作：“喜欢”使用 <code>PUT /gists/:id/star</code>，“取消喜欢”使用 <code>DELETE /gists/:id/star</code>。</p>
<p>另外一个例子是 <code>Fork</code>，这也是一个动作，但是在 gist 下面增加 <code>forks</code>资源，就能把动作变成 <code>CRUD</code> 兼容的：<code>POST /gists/:id/forks</code> 可以执行用户 fork 的动作。</p>
<h2 id="6-Query-让查询更自由"><a href="#6-Query-让查询更自由" class="headerlink" title="6. Query 让查询更自由"></a>6. Query 让查询更自由</h2><p>比如查询某个 repo 下面 issues 的时候，可以通过以下参数来控制返回哪些结果：</p>
<ul>
<li>state：issue 的状态，可以是 <code>open</code>，<code>closed</code>，<code>all</code></li>
<li>since：在指定时间点之后更新过的才会返回</li>
<li>assignee：被 assign 给某个 user 的 issues</li>
<li>sort：选择排序的值，可以是 <code>created</code>、<code>updated</code>、<code>comments</code></li>
<li>direction：排序的方向，升序（asc）还是降序（desc）</li>
<li>……</li>
</ul>
<h2 id="7-分页-Pagination"><a href="#7-分页-Pagination" class="headerlink" title="7. 分页 Pagination"></a>7. 分页 Pagination</h2><p>当返回某个资源的列表时，如果要返回的数目特别多，比如 github 的 <code>/users</code>，就需要使用分页分批次按照需要来返回特定数量的结果。</p>
<p>分页的实现会用到上面提到的 url query，通过两个参数来控制要返回的资源结果：</p>
<ul>
<li>size：每页返回多少资源，如果没提供会使用预设的默认值；这个数量也是有一个最大值，不然用户把它设置成一个非常大的值（比如 <code>99999999</code>）也失去了设计的初衷</li>
<li>page：要获取哪一页的资源，默认是第一页</li>
</ul>
<p>返回的资源列表为 <code>[(page-1)*size, page*size)</code>。</p>
<h2 id="8-选择合适的HTTP状态码"><a href="#8-选择合适的HTTP状态码" class="headerlink" title="8. 选择合适的HTTP状态码"></a>8. 选择合适的HTTP状态码</h2><p>HTTP 应答中，需要带一个很重要的字段：<code>status code</code>。它说明了请求的大致情况，是否正常完成、需要进一步处理、出现了什么错误，对于客户端非常重要。状态码都是三位的整数，大概分成了几个区间：</p>
<ul>
<li><code>2XX</code>：请求正常处理并返回</li>
<li><code>3XX</code>：重定向，请求的资源位置发生变化</li>
<li><code>4XX</code>：客户端发送的请求有错误</li>
<li><code>5XX</code>：服务器端错误</li>
</ul>
<p>在 HTTP API 设计中，经常用到的状态码以及它们的意义如下表：</p>
<table>
<thead>
<tr>
<th>状态码</th>
<th>Label</th>
<th>重点关注</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>200</td>
<td>OK</td>
<td>Y</td>
<td>请求成功接收并处理，一般响应中都会有 body</td>
</tr>
<tr>
<td>201</td>
<td>Created</td>
<td></td>
<td>请求已完成，并导致了一个或者多个资源被创建，最常用在 POST 创建资源的时候</td>
</tr>
<tr>
<td>202</td>
<td>Accepted</td>
<td></td>
<td>请求已经接收并开始处理，但是处理还没有完成。一般用在异步处理的情况，响应 body 中应该告诉客户端去哪里查看任务的状态</td>
</tr>
<tr>
<td>204</td>
<td>No Content</td>
<td></td>
<td>请求已经处理完成，但是没有信息要返回，经常用在 PUT 更新资源的时候（客户端提供资源的所有属性，因此不需要服务端返回）。如果有重要的 metadata，可以放到头部返回</td>
</tr>
<tr>
<td>301</td>
<td>Moved Permanently</td>
<td>Y</td>
<td>请求的资源已经永久性地移动到另外一个地方，后续所有的请求都应该直接访问新地址。服务端会把新地址写在 <code>Location</code> 头部字段，方便客户端使用。允许客户端把 POST 请求修改为 GET。</td>
</tr>
<tr>
<td>304</td>
<td>Not Modified</td>
<td>Y</td>
<td>请求的资源和之前的版本一样，没有发生改变。用来缓存资源，和条件性请求（conditional request）一起出现</td>
</tr>
<tr>
<td>307</td>
<td>Temporary Redirect</td>
<td></td>
<td>目标资源暂时性地移动到新的地址，客户端需要去新地址进行操作，但是<strong>不能</strong>修改请求的方法。</td>
</tr>
<tr>
<td>308</td>
<td>Permanent Redirect</td>
<td></td>
<td>和 301 类似，除了客户端<strong>不能</strong>修改原请求的方法</td>
</tr>
<tr>
<td>400</td>
<td>Bad Request</td>
<td>Y</td>
<td>客户端发送的请求有错误（请求语法错误，body 数据格式有误，body 缺少必须的字段等），导致服务端无法处理</td>
</tr>
<tr>
<td>401</td>
<td>Unauthorized</td>
<td>Y</td>
<td>请求的资源需要认证，客户端没有提供认证信息或者认证信息不正确</td>
</tr>
<tr>
<td>403</td>
<td>Forbidden</td>
<td>Y</td>
<td>服务器端接收到并理解客户端的请求，但是客户端的权限不足。比如，普通用户想操作只有管理员才有权限的资源。为了安全考虑，避免攻击，对外服务，可将这个状态码改写为<strong>404</strong>返回给客户端</td>
</tr>
<tr>
<td>404</td>
<td>Not Found</td>
<td>Y</td>
<td>客户端要访问的资源不存在，链接失效或者客户端伪造 URL 的时候回遇到这个情况</td>
</tr>
<tr>
<td>405</td>
<td>Method Not Allowed</td>
<td></td>
<td>服务端接收到了请求，而且要访问的资源也存在，但是不支持对应的方法。服务端<strong>必须</strong>返回 <code>Allow</code> 头部，告诉客户端哪些方法是允许的</td>
</tr>
<tr>
<td>415</td>
<td>Unsupported Media Type</td>
<td></td>
<td>服务端不支持客户端请求的资源格式，一般是因为客户端在 <code>Content-Type</code> 或者 <code>Content-Encoding</code> 中申明了希望的返回格式，但是服务端没有实现。比如，客户端希望收到 <code>xml</code>返回，但是服务端支持 <code>Json</code></td>
</tr>
<tr>
<td>429</td>
<td>Too Many Requests</td>
<td>Y</td>
<td>客户端在规定的时间里发送了太多请求，在进行限流的时候会用到</td>
</tr>
<tr>
<td>500</td>
<td>Internal Server Error</td>
<td>Y</td>
<td>服务器内部错误，导致无法完成请求的内容</td>
</tr>
<tr>
<td>503</td>
<td>Service Unavailable</td>
<td>Y</td>
<td>服务器因为负载过高或者维护，暂时无法提供服务。服务器端应该返回 <code>Retry-After</code> 头部，告诉客户端过一段时间再来重试</td>
</tr>
</tbody>
</table>
<p>上面这些状态码覆盖了 API 设计中大部分的情况，如果对某个状态码不清楚或者希望查看更完整的列表，可以参考 <a href="https://httpstatuses.com/" target="_blank" rel="external">HTTP Status Code</a> 这个网站，或者 <a href="https://tools.ietf.org/html/rfc7231#section-6" target="_blank" rel="external">RFC7231 Response Status Codes</a> 的内容。<br>在实际应用中，<strong>不建议再使用更多的状态码</strong>。</p>
<h2 id="9-错误处理码设计"><a href="#9-错误处理码设计" class="headerlink" title="9. 错误处理码设计"></a>9. 错误处理码设计</h2><p>除了使用好HTTP状态码，必须有良好的错误码设计。一个良好的状态码设计应同事给出<code>状态码</code>和对应<code>错误消息</code>。<br>HTTP请求返回格式(建议)：</p>
<pre><code>{
    &quot;code&quot;:XXX,
    &quot;message&quot;:&quot;ABCDE...&quot;,
    &quot;data&quot;:{
        ...
    }
}
</code></pre><p>在正常请求时，约定<code>code=0,message=&quot;ok&quot;</code>。</p>
<p>错误时，错误码规则为<code>ABBBBCCCC</code>，共9位。</p>
<p>A:错误级别。如1代表系统级错误，2代表服务级错误；<br>B:项目或模块名称代码；9999个项目或模块，够用了；<br>C:具体错误编号。单个项目/模块有999种错误应该够用；</p>
<p>A错误级别码：</p>
<table>
<thead>
<tr>
<th>级别码</th>
<th>错误说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>依赖组件级错误</td>
</tr>
<tr>
<td>2</td>
<td>服务级错误</td>
</tr>
<tr>
<td>3</td>
<td></td>
</tr>
<tr>
<td>4</td>
<td>请求错误</td>
</tr>
<tr>
<td>5</td>
<td>系统级错误</td>
</tr>
<tr>
<td>…</td>
<td>-</td>
</tr>
</tbody>
</table>
<p>BBBB项目代码：</p>
<table>
<thead>
<tr>
<th>级别码</th>
<th>错误说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>0001</td>
<td>search-ershou</td>
</tr>
<tr>
<td>0002</td>
<td>basic-search</td>
</tr>
<tr>
<td>…</td>
<td>-</td>
</tr>
</tbody>
</table>
<p>CCCC错误编号：</p>
<table>
<thead>
<tr>
<th>错误编号</th>
<th>错误说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>1000</td>
<td>权限认证相关错误</td>
</tr>
<tr>
<td>2000</td>
<td>连接类错误</td>
</tr>
<tr>
<td>3000</td>
<td>超时类错误</td>
</tr>
<tr>
<td>4000</td>
<td>参数错误</td>
</tr>
<tr>
<td>…</td>
</tr>
</tbody>
</table>
<h2 id="10-验证和授权"><a href="#10-验证和授权" class="headerlink" title="10. 验证和授权"></a>10. 验证和授权</h2><p>一般来说，让任何人随意访问公开的 API 是不好的做法。验证和授权是两件事情：</p>
<ul>
<li>验证（Authentication）是为了确定用户是其申明的身份，比如提供账户的密码。不然的话，任何人伪造成其他身份（比如其他用户或者管理员）是非常危险的</li>
<li>授权（Authorization）是为了保证用户有对请求资源特定操作的权限。比如用户的私人信息只能自己能访问，其他人无法看到；有些特殊的操作只能管理员可以操作，其他用户有只读的权限等等</li>
</ul>
<p>如果没有通过验证（提供的用户名和密码不匹配，token 不正确等），需要返回 <a href="https://httpstatuses.com/401" target="_blank" rel="external"><strong>401 Unauthorized</strong></a>状态码，并在 body 中说明具体的错误信息；而没有被授权访问的资源操作，需要返回 <a href="https://httpstatuses.com/403" target="_blank" rel="external"><strong>403 Forbidden</strong></a> 状态码，还有详细的错误信息。</p>
<p><strong>NOTE</strong>：Github API 对某些用户未被授权访问的资源操作返回 <a href="https://httpstatuses.com/404" target="_blank" rel="external"><strong>404 Not Found</strong></a>，目的是为了防止私有资源的泄露（比如黑客可以自动化试探用户的私有资源，返回 403 的话，就等于告诉黑客用户有这些私有的资源）。</p>
<h2 id="11-限流rate-limit"><a href="#11-限流rate-limit" class="headerlink" title="11. 限流rate limit"></a>11. 限流rate limit</h2><p>如果对访问的次数不加控制，很可能会造成 API 被滥用，甚至被 <a href="https://en.wikipedia.org/wiki/Denial-of-service_attack" target="_blank" rel="external">DDos 攻击</a>。根据使用者不同的身份对其进行限流，可以防止这些情况，减少服务器的压力。</p>
<p>对用户的请求限流之后，要有方法告诉用户它的请求使用情况，<code>Github API</code> 使用的三个相关的头部可以借鉴：</p>
<ul>
<li><code>X-RateLimit-Limit</code>: 用户每个小时允许发送请求的最大值</li>
<li><code>X-RateLimit-Remaining</code>：当前时间窗口剩下的可用请求数目</li>
<li><code>X-RateLimit-Rest</code>: 时间窗口重置的时候，到这个时间点可用的请求数量就会变成 X-RateLimit-Limit的值</li>
</ul>
<p>如果允许没有登录的用户使用 API（可以让用户试用），可以把 <code>X-RateLimit-Limit</code> 的值设置得很小，比如 Github 使用的 <code>60</code>。没有登录的用户是按照请求的 IP 来确定的，而登录的用户按照认证后的信息来确定身份。<br>对于超过流量的请求，可以返回 <a href="https://httpstatuses.com/429" target="_blank" rel="external"><strong>429 Too many requests</strong></a> 状态码，并附带错误信息。而 <code>Github API</code> 返回的是 <a href="https://httpstatuses.com/403" target="_blank" rel="external"><strong>403 Forbidden</strong></a>，虽然没有 <code>429</code> 更准确，也是可以理解的。</p>
<h2 id="12-Hypermedia-API"><a href="#12-Hypermedia-API" class="headerlink" title="12. Hypermedia API"></a>12. Hypermedia API</h2><p>Restful API 的设计最好做到 Hypermedia：在返回结果中提供相关资源的链接。这种设计也被称为 <a href="http://en.wikipedia.org/wiki/HATEOAS" target="_blank" rel="external">HATEOAS</a>。这样做的好处是，用户可以根据返回结果就能得到后续操作需要访问的地址。<br>比如访问 <a href="https://api.github.com/" target="_blank" rel="external">api.github.com</a>，就可以看到 Github API 支持的资源操作。<br>Spring技术栈，可以使用<a href="https://spring.io/projects/spring-hateoas" target="_blank" rel="external">Spring Hateoas</a>；由于需要在返回body内增加内容，内部服务使用起来颇有难度，不建议。外部服务强烈推荐。</p>
<h2 id="13-编写优秀的文档"><a href="#13-编写优秀的文档" class="headerlink" title="13. 编写优秀的文档"></a>13. 编写优秀的文档</h2><p>API 最终是给人使用的，不管是公司内部，还是公开的 API 都是一样。即使我们遵循了上面提到的所有规范，设计的 API 非常优雅，用户还是不知道怎么使用我们的 API。最后一步，但非常重要的一步是：为你的 API 编写优秀的文档。</p>
<p>对每个请求以及返回的参数给出说明，最好给出一个详细而完整地示例，提醒用户需要注意的地方……反正目标就是用户可以根据你的文档就能直接使用API，而不是要发邮件给你，或者跑到你的座位上问你一堆问题。<br>文档生成：<strong>建议使用<a href="https://swagger.io/" target="_blank" rel="external">SWAGGER</a></strong><br>与Spring集成：使用<a href="http://springfox.github.io/springfox/" target="_blank" rel="external">SpringFox</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;微服务下的API设计原则&quot;&gt;&lt;a href=&quot;#微服务下的API设计原则&quot; class=&quot;headerlink&quot; title=&quot;微服务下的API设计原则&quot;&gt;&lt;/a&gt;微服务下的API设计原则&lt;/h1&gt;&lt;p&gt;目的：&lt;br&gt;规范团队乃至公司的API设计。&lt;br&gt;主要参考： &lt;a href=&quot;https://developer.github.com/v3/&quot;&gt;Github API&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-为了安全，请使用HTTPS&quot;&gt;&lt;a href=&quot;#1-为了安全，请使用HTTPS&quot; class=&quot;headerlink&quot; title=&quot;1. 为了安全，请使用HTTPS&quot;&gt;&lt;/a&gt;1. 为了安全，请使用HTTPS&lt;/h2&gt;&lt;p&gt;与API设计无关、为了安全请使用HTTPS。公网API,强制使用HTTPS。内网API可酌情选择。&lt;/p&gt;
&lt;h2 id=&quot;2-API-地址和版本&quot;&gt;&lt;a href=&quot;#2-API-地址和版本&quot; class=&quot;headerlink&quot; title=&quot;2. API 地址和版本&quot;&gt;&lt;/a&gt;2. API 地址和版本&lt;/h2&gt;&lt;p&gt;在 &lt;code&gt;url&lt;/code&gt; 中指定 API 的版本是个很好地做法。&lt;br&gt;如果 API 变化比较大，可以把API设计为子域名，比如 &lt;code&gt;https://api.ke.com/v3&lt;/code&gt;；&lt;br&gt;也可以简单地把版本放在路径中，比如 &lt;code&gt;https://ke.com/api/v1&lt;/code&gt;。&lt;br&gt;&lt;strong&gt;不建议放入Header&lt;/strong&gt;，不直观。&lt;/p&gt;
&lt;h2 id=&quot;3-schema请使用JSON&quot;&gt;&lt;a href=&quot;#3-schema请使用JSON&quot; class=&quot;headerlink&quot; title=&quot;3. schema请使用JSON&quot;&gt;&lt;/a&gt;3. schema请使用JSON&lt;/h2&gt;&lt;p&gt;对于响应返回的格式，JSON 因为它的可读性、紧凑性以及多种语言支持等优点，成为了 HTTP API 最常用的返回格式。因此，最好采用&lt;strong&gt;JSON&lt;/strong&gt;作为返回内容的格式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;不推荐其他格式&lt;/strong&gt;，如果必须使用，比如 &lt;code&gt;xml&lt;/code&gt;，应该在请求头部 &lt;code&gt;Accept&lt;/code&gt; 中指定。&lt;br&gt;对于不支持的格式，服务端需要返回正确的 &lt;code&gt;status code&lt;/code&gt;，并给出详细的说明。&lt;/p&gt;
    
    </summary>
    
      <category term="微服务" scheme="https://www.shenyanchao.cn/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    
      <category term="微服务" scheme="https://www.shenyanchao.cn/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="API" scheme="https://www.shenyanchao.cn/tags/API/"/>
    
      <category term="设计" scheme="https://www.shenyanchao.cn/tags/%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>Spring Redis 注解式Cache那些事</title>
    <link href="https://www.shenyanchao.cn/blog/2018/07/23/spring-cache-redis-annotation/"/>
    <id>https://www.shenyanchao.cn/blog/2018/07/23/spring-cache-redis-annotation/</id>
    <published>2018-07-23T09:05:00.000Z</published>
    <updated>2018-12-20T11:58:02.490Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><blockquote>
<p>spring-data-redis使得Spring项目可以快速简单的通过RedisTemplate来操作Redis。而spring-boot-starter-data-redis更是让redis集成更加的方便。</p>
</blockquote>
<h3 id="SpringBoot如何与Redis集成，作为cache"><a href="#SpringBoot如何与Redis集成，作为cache" class="headerlink" title="SpringBoot如何与Redis集成，作为cache"></a>SpringBoot如何与Redis集成，作为cache</h3><p>application.yml里如下配置：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="attr">spring:</span></div><div class="line"><span class="attr">  redis:</span></div><div class="line"><span class="attr">    host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></div><div class="line">    	port: <span class="number">6379</span></div><div class="line">    	database: <span class="number">0</span></div><div class="line">    	timeout: <span class="number">1000</span></div><div class="line">    	pool:</div><div class="line">      		max-idle: <span class="number">200</span></div><div class="line">      		min-idle: <span class="number">0</span></div><div class="line">      		max-active: <span class="number">200</span></div><div class="line">      		max-wait: <span class="number">1000</span></div></pre></td></tr></table></figure>
<p>spring boot可以自动组装相关配置，注意其中使用到了jedis pool，用于提升性能，非必须。<br>通过以下的annotation加入方法名上，可以无侵入的使用cache。</p>
<ul>
<li>@Cacheable   缓存</li>
<li>@CachePut    设置缓存</li>
<li>@CacheEvict  失效或更新缓存</li>
<li><p>@Caching   组合操作</p>
<p>以上annotation不做详细展开。</p>
<a id="more"></a>
<p>做到上面似乎已经可以了，但有一些问题需要我们来解决。</p>
</li>
</ul>
<ul>
<li>a.redis连接报错\超时怎么办？此时应该是可降级的。</li>
<li>b.使用连接池，连接不可用如何破？</li>
</ul>
<p>下面贴一个比较成熟的做法，继承<code>CachingConfigurerSupport</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="meta">@EnableCaching</span> <span class="comment">//启用</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> <span class="keyword">extends</span> <span class="title">CachingConfigurerSupport</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// 过期时间</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> expire = <span class="number">600</span>;</div><div class="line"></div><div class="line">    <span class="comment">// application.yml配置参数有限，注入并扩展用。</span></div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="keyword">private</span> RedisProperties redisProperties;</div><div class="line"></div><div class="line">    <span class="comment">//此处自定义jedis pool配置，设置TestOnBrrow等等</span></div><div class="line">    <span class="meta">@Bean</span></div><div class="line">    <span class="function"><span class="keyword">public</span> JedisPoolConfig <span class="title">jedisPoolConfig</span><span class="params">()</span> </span>&#123;</div><div class="line">        JedisPoolConfig jedisPoolConfig = <span class="keyword">new</span> JedisPoolConfig();</div><div class="line">        RedisProperties.Pool pool = redisProperties.getPool();</div><div class="line">        jedisPoolConfig.setMaxIdle(pool.getMaxIdle());</div><div class="line">        jedisPoolConfig.setMaxTotal(pool.getMaxActive());</div><div class="line">        jedisPoolConfig.setMinIdle(pool.getMinIdle());</div><div class="line">        jedisPoolConfig.setMaxWaitMillis(pool.getMaxWait());</div><div class="line">        jedisPoolConfig.setTestOnBorrow(<span class="keyword">true</span>);</div><div class="line">        jedisPoolConfig.setTestWhileIdle(<span class="keyword">true</span>);</div><div class="line">        <span class="keyword">return</span> jedisPoolConfig;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">   <span class="comment">//生成redisConnectionFactory，使用自定义的jedis pool</span></div><div class="line">    <span class="meta">@Bean</span></div><div class="line">    <span class="function"><span class="keyword">public</span> RedisConnectionFactory <span class="title">redisConnectionFactory</span><span class="params">(JedisPoolConfig jedisPoolConfig)</span> </span>&#123;</div><div class="line">        JedisConnectionFactory jedisConnectionFactory = <span class="keyword">new</span> JedisConnectionFactory();</div><div class="line">        jedisConnectionFactory.setHostName(redisProperties.getHost());</div><div class="line">        jedisConnectionFactory.setPort(redisProperties.getPort());</div><div class="line">        jedisConnectionFactory.setDatabase(redisProperties.getDatabase());</div><div class="line">        jedisConnectionFactory.setTimeout(redisProperties.getTimeout());</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != redisProperties.getPassword()) &#123;</div><div class="line">            jedisConnectionFactory.setPassword(redisProperties.getPassword());</div><div class="line">        &#125;</div><div class="line">        jedisConnectionFactory.setPoolConfig(jedisPoolConfig);</div><div class="line">        <span class="keyword">return</span> jedisConnectionFactory;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 设置cacheManager相关，主要涉及默认过期时间。</span></div><div class="line">    <span class="meta">@Bean</span></div><div class="line">    <span class="function"><span class="keyword">public</span> CacheManager <span class="title">cacheManager</span><span class="params">(RedisTemplate redisTemplate)</span> </span>&#123;</div><div class="line">        RedisCacheManager cacheManager = <span class="keyword">new</span> RedisCacheManager(redisTemplate);</div><div class="line">        <span class="comment">//设置缓存过期时间，可单独对某个cache制定过期时间</span></div><div class="line">        cacheManager.setDefaultExpiration(expire);</div><div class="line">        <span class="comment">//设置redis key是否使用前缀，默认前缀是cacheName</span></div><div class="line">        cacheManager.setUsePrefix(<span class="keyword">true</span>);</div><div class="line">        <span class="keyword">return</span> cacheManager;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//定义redisTemplate，主要是定义key\value的序列化器</span></div><div class="line">    <span class="meta">@Bean</span></div><div class="line">    <span class="function"><span class="keyword">public</span> RedisTemplate&lt;String, String&gt; <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span> </span>&#123;</div><div class="line">        StringRedisTemplate template = <span class="keyword">new</span> StringRedisTemplate(redisConnectionFactory);</div><div class="line">        template.setValueSerializer(getValueSerializer());</div><div class="line">        template.afterPropertiesSet();</div><div class="line">        <span class="keyword">return</span> template;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> RedisSerializer <span class="title">getValueSerializer</span><span class="params">()</span> </span>&#123;</div><div class="line">        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = <span class="keyword">new</span> Jackson2JsonRedisSerializer(Object.class);</div><div class="line">        ObjectMapper om = <span class="keyword">new</span> ObjectMapper();</div><div class="line">        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</div><div class="line">        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</div><div class="line">        jackson2JsonRedisSerializer.setObjectMapper(om);</div><div class="line">        <span class="keyword">return</span> jackson2JsonRedisSerializer;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 设置redis key生成策略</span></div><div class="line">    <span class="meta">@Bean</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> KeyGenerator <span class="title">keyGenerator</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RequestKeyGenerator();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 重点：设置和redis交互报错时的错误处理器。</span></div><div class="line">    <span class="meta">@Bean</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> CacheErrorHandler <span class="title">errorHandler</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CallbackCacheErrorHandler();</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>下面看一下<code>CallbackCacheErrorHandler</code>    :</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallbackCacheErrorHandler</span> <span class="keyword">implements</span> <span class="title">CacheErrorHandler</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(CallbackCacheErrorHandler.class);</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleCacheGetError</span><span class="params">(RuntimeException exception, Cache cache, Object key)</span> </span>&#123;</div><div class="line">        LOGGER.error(<span class="string">"cache get error, cacheName:&#123;&#125;, key:&#123;&#125;, msg:"</span>, cache.getName(), key, exception);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleCachePutError</span><span class="params">(RuntimeException exception, Cache cache, Object key, Object value)</span> </span>&#123;</div><div class="line">        LOGGER.error(<span class="string">"cache put error, cacheName:&#123;&#125;, key:&#123;&#125;, msg:"</span>, cache.getName(), key, exception);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleCacheEvictError</span><span class="params">(RuntimeException exception, Cache cache, Object key)</span> </span>&#123;</div><div class="line">        LOGGER.error(<span class="string">"cache evict error, cacheName:&#123;&#125;, key:&#123;&#125;, msg:"</span>, cache.getName(), key, exception);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleCacheClearError</span><span class="params">(RuntimeException exception, Cache cache)</span> </span>&#123;</div><div class="line">        LOGGER.error(<span class="string">"cache clear error, cacheName:&#123;&#125;, msg:"</span>, cache.getName(), exception);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>此处当报错的时候只进行了日志记录，当然如果有其他需求，都可以在这里扩展。自此，spring boot与redis集成大功告成，一切都是那么的完美。</p>
<h3 id="关于RedisCacheManager是否setUsePrefix的坑"><a href="#关于RedisCacheManager是否setUsePrefix的坑" class="headerlink" title="关于RedisCacheManager是否setUsePrefix的坑"></a>关于RedisCacheManager是否<code>setUsePrefix</code>的坑</h3><p>首先，我们要知道是否使用<code>prefix</code>的区别是什么？<br>区别如下：</p>
<ul>
<li><ol>
<li>使用<code>prefix</code>的时候，redis cache的key都会默认添加上cacheName，用于区分不同的cache。</li>
</ol>
</li>
<li><ol>
<li>使用<code>prefix</code>的时候，当清除或者失效所有的key的时候，使用的是key prefix*获取所有的key,然后依次清楚。而不使用<code>prefix</code>的时候，需要清除或者失效所有key的时候，则是从一个维护了所有key的zset中获取的，这个zset通常叫做<code>${cacheName}~keys</code>。</li>
</ol>
</li>
</ul>
<p>下面通过源代码来证实一下：<br>RedisCache.java内<code>RedisWriteThroughCallback</code>负责往redis设置缓存：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></td><td class="code"><pre><div class="line">	static class RedisWriteThroughCallback extends AbstractRedisCacheCallback&lt;byte[]&gt; &#123;</div><div class="line"></div><div class="line">	public RedisWriteThroughCallback(BinaryRedisCacheElement element, RedisCacheMetadata metadata) &#123;</div><div class="line">		super(element, metadata);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public byte[] doInRedis(BinaryRedisCacheElement element, RedisConnection connection) throws DataAccessException &#123;</div><div class="line"></div><div class="line">		try &#123;</div><div class="line">          //加锁</div><div class="line">			lock(connection);</div><div class="line"></div><div class="line">			try &#123;</div><div class="line"></div><div class="line">				byte[] value = connection.get(element.getKeyBytes());</div><div class="line"></div><div class="line">				if (value != null) &#123;</div><div class="line">					return value;</div><div class="line">				&#125;</div><div class="line"></div><div class="line">				if (!isClusterConnection(connection)) &#123;</div><div class="line"></div><div class="line">					connection.watch(element.getKeyBytes());</div><div class="line">					// 开始事务</div><div class="line">					connection.multi();</div><div class="line">				&#125;</div><div class="line"></div><div class="line">				value = element.get();</div><div class="line"></div><div class="line">				if (value.length == 0) &#123;</div><div class="line">					connection.del(element.getKeyBytes());</div><div class="line">				&#125; else &#123;</div><div class="line">				   // 设置缓存key-value</div><div class="line">					connection.set(element.getKeyBytes(), value);</div><div class="line">					// 设置失效日期</div><div class="line">					processKeyExpiration(element, connection);</div><div class="line">					// 维护key到已知zset内</div><div class="line">					maintainKnownKeys(element, connection);</div><div class="line">				&#125;</div><div class="line"></div><div class="line">				if (!isClusterConnection(connection)) &#123;</div><div class="line">					connection.exec();</div><div class="line">				&#125;</div><div class="line"></div><div class="line">				return value;</div><div class="line">			&#125; catch (RuntimeException e) &#123;</div><div class="line">				if (!isClusterConnection(connection)) &#123;</div><div class="line">					connection.discard();</div><div class="line">				&#125;</div><div class="line">				throw e;</div><div class="line">			&#125;</div><div class="line">		&#125; finally &#123;</div><div class="line">		   // 释放锁</div><div class="line">			unlock(connection);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"> protected void maintainKnownKeys(RedisCacheElement element, RedisConnection connection) &#123;</div><div class="line"></div><div class="line">		if (!element.hasKeyPrefix()) &#123; //不使用prefix</div><div class="line">          // 则zadd到已知的key集合内</div><div class="line">			connection.zAdd(cacheMetadata.getSetOfKnownKeysKey(), 0, element.getKeyBytes());</div><div class="line"></div><div class="line">			if (!element.isEternal()) &#123;</div><div class="line">				connection.expire(cacheMetadata.getSetOfKnownKeysKey(), element.getTimeToLive());</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>从上面分析得知，设置缓存的时候有以下几步：</p>
<ul>
<li>1.设置key-value</li>
<li>2.设置key的过期时间</li>
<li>3.维护key到已知key的zset列表</li>
</ul>
<p>清理所有key的时候，是怎么操作的呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</div><div class="line">	redisOperations.execute(cacheMetadata.usesKeyPrefix() ? <span class="keyword">new</span> RedisCacheCleanByPrefixCallback(cacheMetadata)</div><div class="line">			: <span class="keyword">new</span> RedisCacheCleanByKeysCallback(cacheMetadata));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看出依据是否使用前缀，使用不同的回调方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * <span class="doctag">@author</span> Christoph Strobl</div><div class="line"> * <span class="doctag">@since</span> 1.5</div><div class="line"> */</div><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisCacheCleanByKeysCallback</span> <span class="keyword">extends</span> <span class="title">LockingRedisCacheCallback</span>&lt;<span class="title">Void</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PAGE_SIZE = <span class="number">128</span>;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> RedisCacheMetadata metadata;</div><div class="line"></div><div class="line">	RedisCacheCleanByKeysCallback(RedisCacheMetadata metadata) &#123;</div><div class="line">		<span class="keyword">super</span>(metadata);</div><div class="line">		<span class="keyword">this</span>.metadata = metadata;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">/*</span></div><div class="line">	 * (non-Javadoc)</div><div class="line">	 * @see org.springframework.data.redis.cache.RedisCache.LockingRedisCacheCallback#doInLock(org.springframework.data.redis.connection.RedisConnection)</div><div class="line">	 */</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> Void <span class="title">doInLock</span><span class="params">(RedisConnection connection)</span> </span>&#123;</div><div class="line"></div><div class="line">		<span class="keyword">int</span> offset = <span class="number">0</span>;</div><div class="line">		<span class="keyword">boolean</span> finished = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">		do &#123;</div><div class="line">			<span class="comment">// need to paginate the keys</span></div><div class="line">			Set&lt;<span class="keyword">byte</span>[]&gt; keys = connection.zRange(metadata.getSetOfKnownKeysKey(), (offset) * PAGE_SIZE,</div><div class="line">					(offset + <span class="number">1</span>) * PAGE_SIZE - <span class="number">1</span>);  <span class="comment">//使用zrange遍历，删除</span></div><div class="line">			finished = keys.size() &lt; PAGE_SIZE;</div><div class="line">			offset++;</div><div class="line">			<span class="keyword">if</span> (!keys.isEmpty()) &#123;</div><div class="line">				connection.del(keys.toArray(<span class="keyword">new</span> <span class="keyword">byte</span>[keys.size()][]));</div><div class="line">			&#125;</div><div class="line">		&#125; <span class="keyword">while</span> (!finished);</div><div class="line"></div><div class="line">		connection.del(metadata.getSetOfKnownKeysKey());</div><div class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * <span class="doctag">@author</span> Christoph Strobl</div><div class="line"> * <span class="doctag">@since</span> 1.5</div><div class="line"> */</div><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisCacheCleanByPrefixCallback</span> <span class="keyword">extends</span> <span class="title">LockingRedisCacheCallback</span>&lt;<span class="title">Void</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] REMOVE_KEYS_BY_PATTERN_LUA = <span class="keyword">new</span> StringRedisSerializer().serialize(</div><div class="line">			<span class="string">"local keys = redis.call('KEYS', ARGV[1]); local keysCount = table.getn(keys); if(keysCount &gt; 0) then for _, key in ipairs(keys) do redis.call('del', key); end; end; return keysCount;"</span>);</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] WILD_CARD = <span class="keyword">new</span> StringRedisSerializer().serialize(<span class="string">"*"</span>);</div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> RedisCacheMetadata metadata;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">RedisCacheCleanByPrefixCallback</span><span class="params">(RedisCacheMetadata metadata)</span> </span>&#123;</div><div class="line">		<span class="keyword">super</span>(metadata);</div><div class="line">		<span class="keyword">this</span>.metadata = metadata;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">/*</span></div><div class="line">	 * (non-Javadoc)</div><div class="line">	 * @see org.springframework.data.redis.cache.RedisCache.LockingRedisCacheCallback#doInLock(org.springframework.data.redis.connection.RedisConnection)</div><div class="line">	 */</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> Void <span class="title">doInLock</span><span class="params">(RedisConnection connection)</span> <span class="keyword">throws</span> DataAccessException </span>&#123;</div><div class="line"></div><div class="line">		<span class="keyword">byte</span>[] prefixToUse = Arrays.copyOf(metadata.getKeyPrefix(), metadata.getKeyPrefix().length + WILD_CARD.length);</div><div class="line">		System.arraycopy(WILD_CARD, <span class="number">0</span>, prefixToUse, metadata.getKeyPrefix().length, WILD_CARD.length);</div><div class="line"></div><div class="line">		<span class="keyword">if</span> (isClusterConnection(connection)) &#123;</div><div class="line"></div><div class="line">			<span class="comment">// load keys to the client because currently Redis Cluster connections do not allow eval of lua scripts.</span></div><div class="line">			Set&lt;<span class="keyword">byte</span>[]&gt; keys = connection.keys(prefixToUse);  <span class="comment">//集群模式下，使用keys获取所有的key</span></div><div class="line">			<span class="keyword">if</span> (!keys.isEmpty()) &#123;</div><div class="line">				connection.del(keys.toArray(<span class="keyword">new</span> <span class="keyword">byte</span>[keys.size()][]));</div><div class="line">			&#125;</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">		   <span class="comment">// 非集群模式下，使用LUA脚本，keys删除。</span></div><div class="line">			connection.eval(REMOVE_KEYS_BY_PATTERN_LUA, ReturnType.INTEGER, <span class="number">0</span>, prefixToUse);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从以上源码可以看出使用prefix的区别。总结下，坑在哪儿，应该如何根据业务来选择。</p>
<ul>
<li>坑1：不使用<code>prefix</code>,需要额外的zset来保存已知key集合，风险点是zset有可能很大，占用空间，如果被置换出去，功能则不一致</li>
<li>坑2：使用<code>prefix</code>, 没有额外的zset。但是失效或者清理所有key的时候，使用<code>keys *</code>可能导致redis被拖死，清理时间内无响应。</li>
<li>坑3：设置缓存，使用了multi，对redis压力不小，高并发下尤其明显，需要注意。</li>
</ul>
<h3 id="关于Redis-Cache默认使用lock的问题"><a href="#关于Redis-Cache默认使用lock的问题" class="headerlink" title="关于Redis Cache默认使用lock的问题"></a>关于Redis Cache默认使用lock的问题</h3><p>在高并发下，发现spring redis cache的put效率并不高，经过排查发现put操作有lock机制，切lock时间无法更改。</p>
<p>如上<code>RedisWriteThroughCallback</code>所示，有lock和unlock操作，其实就是往redis写一个key作为lock, 删除这个key作为unlock。这个操作在分布式系统中，可以保证其一致性，但是也损失了性能。尤其在仅作为缓存使用的场景，key对应的value具备幂等性，完全可以忽略。</p>
<p>源码重点在这个<code>waitForLock</code>方法里：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">waitForLock</span><span class="params">(RedisConnection connection)</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">boolean</span> retry;</div><div class="line">	<span class="keyword">boolean</span> foundLock = <span class="keyword">false</span>;</div><div class="line">	do &#123;</div><div class="line">		retry = <span class="keyword">false</span>;</div><div class="line">		<span class="keyword">if</span> (connection.exists(cacheMetadata.getCacheLockKey())) &#123;</div><div class="line">			foundLock = <span class="keyword">true</span>;</div><div class="line">			<span class="keyword">try</span> &#123;</div><div class="line">				Thread.sleep(WAIT_FOR_LOCK_TIMEOUT); <span class="comment">//此处WAIT_FOR_LOCK_TIMEOUT=300ms</span></div><div class="line">			&#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</div><div class="line">				Thread.currentThread().interrupt();</div><div class="line">			&#125;</div><div class="line">			retry = <span class="keyword">true</span>;</div><div class="line">		&#125;</div><div class="line">	&#125; <span class="keyword">while</span> (retry);</div><div class="line"></div><div class="line">	<span class="keyword">return</span> foundLock;</div><div class="line">&#125;</div><div class="line"></div><div class="line">  <span class="comment">// 加锁</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">(RedisConnection connection)</span> </span>&#123;</div><div class="line">	waitForLock(connection);</div><div class="line">	connection.set(cacheMetadata.getCacheLockKey(), <span class="string">"locked"</span>.getBytes());</div><div class="line">&#125;</div><div class="line"> <span class="comment">// 解锁</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">(RedisConnection connection)</span> </span>&#123;</div><div class="line">	connection.del(cacheMetadata.getCacheLockKey());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看出每次加锁，如果lock已经存在的情况下，会额外sleep 300ms,这在高并发、高性能的缓存场景是<strong>极其低效</strong>的。并且在极端情况下，unlock删除key没成功，将会导致所有key都无法设置或更新,并陷入死循环。spring内部也没有提供相关的行为覆盖机制，这是一个较大的坑。</p>
<h3 id="Spring-Data-Redis-2-0-RC1的优化"><a href="#Spring-Data-Redis-2-0-RC1的优化" class="headerlink" title="Spring-Data-Redis 2.0 RC1的优化"></a>Spring-Data-Redis 2.0 RC1的优化</h3><p><a href="https://jira.spring.io/browse/DATAREDIS-481" target="_blank" rel="external">官方DATAREDIS-481</a>注意到了Lock的优化，并对cache manager做了颠覆性的升级。<br>下面跟着我来看看，spring-data-redis 2.0之后如何使用注解式cache.<br>由于底层依赖的<a href="https://github.com/xetorthio/jedis" target="_blank" rel="external">Jedis</a>,自从发布2.9.0版本之后，升级缓慢，目前也仅支持到2.8.x和3.x.x版本，所以Spring推荐使用<a href="https://github.com/lettuce-io/lettuce-core" target="_blank" rel="external">lettuce</a>.</p>
<p>先看application.yml里如何写：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="attr">spring:</span></div><div class="line"><span class="attr">    redis:</span></div><div class="line"><span class="attr">      host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></div><div class="line"><span class="attr">      database:</span> <span class="number">0</span></div><div class="line"><span class="attr">      port:</span> <span class="number">6379</span></div><div class="line"><span class="attr">      timeout:</span> <span class="number">1000</span></div><div class="line"><span class="attr">      lettuce:</span></div><div class="line"><span class="attr">        pool:</span></div><div class="line"><span class="attr">          max-active:</span> <span class="number">500</span></div><div class="line"><span class="attr">          min-idle:</span> <span class="number">0</span></div><div class="line"><span class="attr">          max-idle:</span> <span class="number">500</span></div><div class="line"><span class="attr">          max-wait:</span> <span class="number">1000</span></div></pre></td></tr></table></figure>
<p>开始使用lettuce了，jedis提示deprecated了。<br>pool提供的参数有限，如果想自己定制，参见如下设置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line">  	<span class="comment">//继承CachingConfigurerSupport</span></div><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="meta">@EnableCaching</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> <span class="keyword">extends</span> <span class="title">CachingConfigurerSupport</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">//注入默认参数</span></div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="keyword">private</span> RedisProperties redisProperties;</div><div class="line">    <span class="comment">//默认超时</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">long</span> expire = <span class="number">600L</span>;</div><div class="line"></div><div class="line">    <span class="meta">@Bean</span></div><div class="line">    <span class="function"><span class="keyword">public</span> RedisConnectionFactory <span class="title">redisConnectionFactory</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">//commons-pool2包</span></div><div class="line">        GenericObjectPoolConfig poolConfig = <span class="keyword">new</span> GenericObjectPoolConfig();</div><div class="line">        poolConfig.setMaxIdle(<span class="number">500</span>);</div><div class="line">        poolConfig.setMinIdle(<span class="number">0</span>);</div><div class="line">        poolConfig.setMaxTotal(<span class="number">500</span>);</div><div class="line">        poolConfig.setMaxWaitMillis(<span class="number">1000</span>);</div><div class="line">        poolConfig.setTestOnBorrow(<span class="keyword">true</span>);   <span class="comment">//额外设置</span></div><div class="line"></div><div class="line">        <span class="comment">// 基本连接信息：host port database password</span></div><div class="line">        RedisStandaloneConfiguration redisStandaloneConfiguration = <span class="keyword">new</span> RedisStandaloneConfiguration();</div><div class="line">        redisStandaloneConfiguration.setHostName(redisProperties.getHost());</div><div class="line">        redisStandaloneConfiguration.setPort(redisProperties.getPort());</div><div class="line">        redisStandaloneConfiguration.setDatabase(redisProperties.getDatabase());</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != redisProperties.getPassword())&#123;</div><div class="line">            redisStandaloneConfiguration.setPassword(RedisPassword.of(redisProperties.getPassword()));</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//这里单独配置超时时间，连接池管理</span></div><div class="line">        LettuceClientConfiguration lettuceClientConfiguration = LettucePoolingClientConfiguration.builder()</div><div class="line">                .commandTimeout(Duration.ofMillis(<span class="number">200</span>)).shutdownTimeout(Duration.ofMillis(<span class="number">200</span>)).poolConfig</div><div class="line">                        (poolConfig)</div><div class="line">                .build();</div><div class="line">        LettuceConnectionFactory lettuceConnectionFactory = <span class="keyword">new</span> LettuceConnectionFactory</div><div class="line">                (redisStandaloneConfiguration, lettuceClientConfiguration);</div><div class="line">        lettuceConnectionFactory.setValidateConnection(<span class="keyword">true</span>);</div><div class="line">        <span class="keyword">return</span> lettuceConnectionFactory;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Bean</span></div><div class="line">    <span class="function"><span class="keyword">public</span> CacheManager <span class="title">cacheManager</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span> </span>&#123;</div><div class="line">        <span class="comment">// 默认配置使用prefix、单独设置valueSerializer、过期时间</span></div><div class="line">        RedisCacheConfiguration redisCacheConfiguration =</div><div class="line">                RedisCacheConfiguration.defaultCacheConfig().serializeValuesWith(</div><div class="line">                        RedisSerializationContext.SerializationPair.fromSerializer(getValueSerializer()))</div><div class="line">                        .entryTtl(Duration.ofSeconds</div><div class="line">                                (expire)).disableCachingNullValues();</div><div class="line">        <span class="comment">// 使用redisConnectionFactory直接创建无锁的cm</span></div><div class="line">        RedisCacheManager cm = RedisCacheManager.builder(RedisCacheWriter.nonLockingRedisCacheWriter(redisConnectionFactory)).cacheDefaults(redisCacheConfiguration).transactionAware().build();</div><div class="line">        <span class="keyword">return</span> cm;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> RedisSerializer <span class="title">getValueSerializer</span><span class="params">()</span> </span>&#123;</div><div class="line">        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = <span class="keyword">new</span> Jackson2JsonRedisSerializer(Object.class);</div><div class="line">        ObjectMapper om = <span class="keyword">new</span> ObjectMapper();</div><div class="line">        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</div><div class="line">        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</div><div class="line">        jackson2JsonRedisSerializer.setObjectMapper(om);</div><div class="line">        <span class="keyword">return</span> jackson2JsonRedisSerializer;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Bean</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> CacheErrorHandler <span class="title">errorHandler</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RedisCacheErrorHandler();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> KeyGenerator <span class="title">keyGenerator</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyKeyGenerator()</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>从上面可以看出，基本操作是一致的，但是RedisCacheManager创建更加优雅，不在直接依赖redisTemplate。<br>关于是否使用prefix问题，<code>RedisCacheConfiguration.defaultCacheConfig()</code>中代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="title">RedisCacheConfiguration</span><span class="params">(Duration ttl, Boolean cacheNullValues, Boolean usePrefix,</span></span></div><div class="line">		CacheKeyPrefix keyPrefix, SerializationPair&lt;String&gt; keySerializationPair,</div><div class="line">		SerializationPair&lt;?&gt; valueSerializationPair, ConversionService conversionService) &#123;</div><div class="line"></div><div class="line">	<span class="keyword">this</span>.ttl = ttl;</div><div class="line">	<span class="keyword">this</span>.cacheNullValues = cacheNullValues;</div><div class="line">	<span class="keyword">this</span>.usePrefix = usePrefix;</div><div class="line">	<span class="keyword">this</span>.keyPrefix = keyPrefix;</div><div class="line">	<span class="keyword">this</span>.keySerializationPair = keySerializationPair;</div><div class="line">	<span class="keyword">this</span>.valueSerializationPair = (SerializationPair&lt;Object&gt;) valueSerializationPair;</div><div class="line">	<span class="keyword">this</span>.conversionService = conversionService;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RedisCacheConfiguration <span class="title">defaultCacheConfig</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">	DefaultFormattingConversionService conversionService = <span class="keyword">new</span> DefaultFormattingConversionService();</div><div class="line"></div><div class="line">	registerDefaultConverters(conversionService);</div><div class="line">   <span class="comment">// 默认usePrefix为true,是推荐的</span></div><div class="line">	<span class="keyword">return</span> <span class="keyword">new</span> RedisCacheConfiguration(Duration.ZERO, <span class="keyword">true</span>, <span class="keyword">true</span>, CacheKeyPrefix.simple(),</div><div class="line">			SerializationPair.fromSerializer(<span class="keyword">new</span> StringRedisSerializer()),</div><div class="line">			SerializationPair.fromSerializer(<span class="keyword">new</span> JdkSerializationRedisSerializer()), conversionService);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当然也是可以覆盖禁用的，使用<code>disableKeyPrefix</code>, 但明确提出，你需要特别注意，不建议使用。</p>
<p>关于是否使用lock的问题，新版本也提供了可选方案。通过<code>RedisCacheWriter</code>来实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> RedisCacheWriter <span class="title">nonLockingRedisCacheWriter</span><span class="params">(RedisConnectionFactory connectionFactory)</span> </span>&#123;</div><div class="line"></div><div class="line">	Assert.notNull(connectionFactory, <span class="string">"ConnectionFactory must not be null!"</span>);</div><div class="line"></div><div class="line">	<span class="keyword">return</span> <span class="keyword">new</span> DefaultRedisCacheWriter(connectionFactory);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> RedisCacheWriter <span class="title">lockingRedisCacheWriter</span><span class="params">(RedisConnectionFactory connectionFactory)</span> </span>&#123;</div><div class="line"></div><div class="line">	Assert.notNull(connectionFactory, <span class="string">"ConnectionFactory must not be null!"</span>);</div><div class="line"></div><div class="line">	<span class="keyword">return</span> <span class="keyword">new</span> DefaultRedisCacheWriter(connectionFactory, Duration.ofMillis(<span class="number">50</span>));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看出lockingRedisCacheWriter将会有sleep 50ms来处理锁,nonlocking则没有加锁等待，给用户提供了更好的处理方案。</p>
<p>关于全部失效或者清理key的问题，2.0版本处理方案如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clean</span><span class="params">(String name, <span class="keyword">byte</span>[] pattern)</span> </span>&#123;</div><div class="line"></div><div class="line">	Assert.notNull(name, <span class="string">"Name must not be null!"</span>);</div><div class="line">	Assert.notNull(pattern, <span class="string">"Pattern must not be null!"</span>);</div><div class="line"></div><div class="line">	execute(name, connection -&gt; &#123;</div><div class="line"></div><div class="line">		<span class="keyword">boolean</span> wasLocked = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line"></div><div class="line">			<span class="keyword">if</span> (isLockingCacheWriter()) &#123;</div><div class="line">				doLock(name, connection);</div><div class="line">				wasLocked = <span class="keyword">true</span>;</div><div class="line">			&#125;</div><div class="line">         <span class="comment">// 这里仍旧是使用的keys操作</span></div><div class="line">			<span class="keyword">byte</span>[][] keys = Optional.ofNullable(connection.keys(pattern)).orElse(Collections.emptySet())</div><div class="line">					.toArray(<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>][]);</div><div class="line"></div><div class="line">			<span class="keyword">if</span> (keys.length &gt; <span class="number">0</span>) &#123;</div><div class="line">				connection.del(keys);</div><div class="line">			&#125;</div><div class="line">		&#125; <span class="keyword">finally</span> &#123;</div><div class="line"></div><div class="line">			<span class="keyword">if</span> (wasLocked &amp;&amp; isLockingCacheWriter()) &#123;</div><div class="line">				doUnlock(name, connection);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">return</span> <span class="string">"OK"</span>;</div><div class="line">	&#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里仍旧使用的是<code>keys</code>命令，坑仍在。后续使用<code>scan</code>操作也许是更好的选择，但最终还是要依据自己的业务需求来定制。</p>
<p>总结：</p>
<blockquote>
<p><strong>开源项目的坑无处不在，即使是spring</strong>。<br>无论是什么版本，使用<code>prefix</code>是更好的选择，也是趋势所在。<br>keys操作对性能的影响始终未能彻底消除，建议使用key expire机制来规避。（生产环境keys操作也是尽可能要避免的）。<br>redis缓存key的大小，无论是性能还是存储的影响都很大，强烈建议在业务允许范围内尽可能减小key的大小(比如使用MD5,有一定碰撞率)。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言：&quot;&gt;&lt;a href=&quot;#前言：&quot; class=&quot;headerlink&quot; title=&quot;前言：&quot;&gt;&lt;/a&gt;前言：&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;spring-data-redis使得Spring项目可以快速简单的通过RedisTemplate来操作Redis。而spring-boot-starter-data-redis更是让redis集成更加的方便。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;SpringBoot如何与Redis集成，作为cache&quot;&gt;&lt;a href=&quot;#SpringBoot如何与Redis集成，作为cache&quot; class=&quot;headerlink&quot; title=&quot;SpringBoot如何与Redis集成，作为cache&quot;&gt;&lt;/a&gt;SpringBoot如何与Redis集成，作为cache&lt;/h3&gt;&lt;p&gt;application.yml里如下配置：&lt;/p&gt;
&lt;figure class=&quot;highlight yml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;spring:&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;  redis:&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;    host:&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;127.0&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;.0&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;.1&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    	port: &lt;span class=&quot;number&quot;&gt;6379&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    	database: &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    	timeout: &lt;span class=&quot;number&quot;&gt;1000&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    	pool:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      		max-idle: &lt;span class=&quot;number&quot;&gt;200&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      		min-idle: &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      		max-active: &lt;span class=&quot;number&quot;&gt;200&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;      		max-wait: &lt;span class=&quot;number&quot;&gt;1000&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;spring boot可以自动组装相关配置，注意其中使用到了jedis pool，用于提升性能，非必须。&lt;br&gt;通过以下的annotation加入方法名上，可以无侵入的使用cache。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;@Cacheable   缓存&lt;/li&gt;
&lt;li&gt;@CachePut    设置缓存&lt;/li&gt;
&lt;li&gt;@CacheEvict  失效或更新缓存&lt;/li&gt;
&lt;li&gt;&lt;p&gt;@Caching   组合操作&lt;/p&gt;
&lt;p&gt;以上annotation不做详细展开。&lt;/p&gt;
    
    </summary>
    
      <category term="spring" scheme="https://www.shenyanchao.cn/categories/spring/"/>
    
    
      <category term="spring" scheme="https://www.shenyanchao.cn/tags/spring/"/>
    
      <category term="redis" scheme="https://www.shenyanchao.cn/tags/redis/"/>
    
      <category term="cache" scheme="https://www.shenyanchao.cn/tags/cache/"/>
    
  </entry>
  
  <entry>
    <title>关于接口定义的一些想法</title>
    <link href="https://www.shenyanchao.cn/blog/2016/03/20/about-interface-define/"/>
    <id>https://www.shenyanchao.cn/blog/2016/03/20/about-interface-define/</id>
    <published>2016-03-20T02:43:00.000Z</published>
    <updated>2018-12-13T12:27:12.993Z</updated>
    
    <content type="html"><![CDATA[<p>最近公司内项目，需要开发接口给ios,android客户端去调用。因此，做了一些思考，主要是关于如何更好的定义接口以及联调。</p>
<h3 id="使用RESTFul接口"><a href="#使用RESTFul接口" class="headerlink" title="使用RESTFul接口"></a>使用RESTFul接口</h3><p>RESTFul接口作为一个通行的标准，当然是优先使用的。项目都是基于Spring的，因此采用的是Spring MVC.</p>
<h3 id="解决接口联调的苦难"><a href="#解决接口联调的苦难" class="headerlink" title="解决接口联调的苦难"></a>解决接口联调的苦难</h3><p>作为一个技术人员，写文档是一大令人头疼的事情。况且即使把文档写好了，也可能导致在以后的修修补补中，导致不一致的情况。<br>因此，考虑采用文档自动生成的方式。最终选用了<a href="www.swagger.io">Swagger</a>来自动为Spring MVC生成文档。</p>
<ul>
<li>swagger-maven-plugin</li>
<li>swagger-ui</li>
</ul>
<h3 id="项目中遇到的一些教训"><a href="#项目中遇到的一些教训" class="headerlink" title="项目中遇到的一些教训"></a>项目中遇到的一些教训</h3><p>作为技术负责人</p>
<ul>
<li>提前制定接口，方便联调</li>
<li>提前规划返回接口类型，统一字段名称。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近公司内项目，需要开发接口给ios,android客户端去调用。因此，做了一些思考，主要是关于如何更好的定义接口以及联调。&lt;/p&gt;
&lt;h3 id=&quot;使用RESTFul接口&quot;&gt;&lt;a href=&quot;#使用RESTFul接口&quot; class=&quot;headerlink&quot; title=&quot;
    
    </summary>
    
      <category term="java" scheme="https://www.shenyanchao.cn/categories/java/"/>
    
    
      <category term="spring" scheme="https://www.shenyanchao.cn/tags/spring/"/>
    
      <category term="restful" scheme="https://www.shenyanchao.cn/tags/restful/"/>
    
      <category term="interface" scheme="https://www.shenyanchao.cn/tags/interface/"/>
    
  </entry>
  
  <entry>
    <title>Restful Spring MVC</title>
    <link href="https://www.shenyanchao.cn/blog/2015/11/03/restful-springmvc/"/>
    <id>https://www.shenyanchao.cn/blog/2015/11/03/restful-springmvc/</id>
    <published>2015-11-03T05:53:00.000Z</published>
    <updated>2018-10-23T08:57:11.266Z</updated>
    
    <content type="html"><![CDATA[<p>Spring MVC本身对Restful支持非常好。它的<code>@RequestMapping</code>、<code>@RequestParam</code>、<code>@PathVariable</code>、<code>@ResponseBody</code>注解很好的支持了REST。<a href="http://static.springsource.org/spring/docs/3.0.0.M3/reference/html/ch18s02.html" target="_blank" rel="external">18.2 Creating RESTful services</a></p>
<h3 id="1-RequestMapping"><a href="#1-RequestMapping" class="headerlink" title="1. @RequestMapping"></a>1. <code>@RequestMapping</code></h3><p>Spring uses the @RequestMapping method annotation to define the URI Template for the request. 类似于struts的action-mapping。 可以指定POST或者GET。</p>
<h3 id="2-PathVariable"><a href="#2-PathVariable" class="headerlink" title="2. @PathVariable"></a>2. <code>@PathVariable</code></h3><p>The @PathVariable method parameter annotation is used to indicate that a method parameter should be bound to the value of a URI template variable. 用于抽取URL中的信息作为参数。（注意，不包括请求字符串，那是<code>@RequestParam</code>做的事情。）</p>
<pre><code>@RequestMapping(&quot;/owners/{ownerId}&quot;, method=RequestMethod.GET)
public String findOwner(@PathVariable String ownerId, Model model) {
        // ...
}
</code></pre><p>如果变量名与pathVariable名不一致，那么需要指定：</p>
<pre><code>@RequestMapping(&quot;/owners/{ownerId}&quot;, method=RequestMethod.GET)
public String findOwner(@PathVariable(&quot;ownerId&quot;) String theOwner, Model model) {
    // implementation omitted
}
</code></pre><blockquote>
<p><strong>Tip</strong></p>
<p>method parameters that are decorated with the @PathVariable annotation can be of any simple type such as int, long, Date… Spring automatically converts to the appropriate type and throws a TypeMismatchException if the type is not correct.</p>
</blockquote>
<a id="more"></a>
<h3 id="3-RequestParam"><a href="#3-RequestParam" class="headerlink" title="3. @RequestParam"></a>3. <code>@RequestParam</code></h3><p>官方文档居然没有对这个注解进行说明，估计是遗漏了（真不应该啊）。这个注解跟<code>@PathVariable</code>功能差不多，只是参数值的来源不一样而已。它的取值来源是请求参数（querystring或者post表单字段）。</p>
<p>对了，因为它的来源可以是POST字段，所以它支持更丰富和复杂的类型信息。比如文件对象:</p>
<pre><code>@RequestMapping(&quot;/imageUpload&quot;)
public String processImageUpload(@RequestParam(&quot;name&quot;) String name,
                @RequestParam(&quot;description&quot;) String description,
                @RequestParam(&quot;image&quot;) MultipartFile image) throws IOException {
    this.imageDatabase.storeImage(name, image.getInputStream(),
                                    (int) image.getSize(), description);
    return &quot;redirect:imageList&quot;;
}
</code></pre><p>还可以设置defaultValue：</p>
<pre><code>@RequestMapping(&quot;/imageUpload&quot;)
public String processImageUpload(@RequestParam(value=&quot;name&quot;, defaultValue=&quot;arganzheng&quot;) String name,
                @RequestParam(&quot;description&quot;) String description,
                @RequestParam(&quot;image&quot;) MultipartFile image) throws IOException {
    this.imageDatabase.storeImage(name, image.getInputStream(),
                                    (int) image.getSize(), description);
    return &quot;redirect:imageList&quot;;
}
</code></pre><h3 id="4-RequestBody和-ResponseBody"><a href="#4-RequestBody和-ResponseBody" class="headerlink" title="4. @RequestBody和@ResponseBody"></a>4. <code>@RequestBody</code>和<code>@ResponseBody</code></h3><p>这两个注解其实用到了Spring的一个非常灵活的设计——<code>HttpMessageConverter</code> <a href="http://static.springsource.org/spring/docs/3.0.0.M3/reference/html/ch18s03.html#rest-message-conversion" target="_blank" rel="external">18.3.2 HTTP Message Conversion</a></p>
<p>与<code>@RequestParam</code>不同，<code>@RequestBody</code>和<code>@ResponseBody</code>是针对整个HTTP请求或者返回消息的。前者只是针对HTTP请求消息中的一个 name=value 键值对(名称很贴切)。</p>
<p><code>HtppMessageConverter</code>负责将HTTP请求消息(HTTP request message)转化为对象，或者将对象转化为HTTP响应体(HTTP response body)。</p>
<pre><code>public interface HttpMessageConverter&lt;T&gt; {

    // Indicate whether the given class is supported by this converter.
    boolean supports(Class&lt;? extends T&gt; clazz);

    // Return the list of MediaType objects supported by this converter.
    List&lt;MediaType&gt; getSupportedMediaTypes();

    // Read an object of the given type form the given input message, and returns it.
    T read(Class&lt;T&gt; clazz, HttpInputMessage inputMessage) throws IOException,
                                                                    HttpMessageNotReadableException;

    // Write an given object to the given output message.
    void write(T t, HttpOutputMessage outputMessage) throws IOException,
                                                            HttpMessageNotWritableException;

}
</code></pre><p>Spring MVC对<code>HttpMessageConverter</code>有多种默认实现，基本上不需要自己再自定义<code>HttpMessageConverter</code><br>&gt;</p>
<ul>
<li>StringHttpMessageConverter - converts strings</li>
<li>FormHttpMessageConverter - converts form data to/from a MultiValueMap<string, string=""></string,></li>
<li>ByteArrayMessageConverter - converts byte arrays</li>
<li>SourceHttpMessageConverter - convert to/from a javax.xml.transform.Source</li>
<li>RssChannelHttpMessageConverter - convert to/from RSS feeds</li>
<li>MappingJacksonHttpMessageConverter - convert to/from JSON using Jackson’s ObjectMapper</li>
<li>etc…</li>
</ul>
<p>然而对于RESTful应用，用的最多的当然是<code>MappingJacksonHttpMessageConverter</code>。</p>
<p>但是<code>MappingJacksonHttpMessageConverter</code>不是默认的<code>HttpMessageConverter</code>：</p>
<pre><code>public class AnnotationMethodHandlerAdapter extends WebContentGenerator
implements HandlerAdapter, Ordered, BeanFactoryAware {

    ...

    public AnnotationMethodHandlerAdapter() {
        // no restriction of HTTP methods by default
        super(false);

        // See SPR-7316
        StringHttpMessageConverter stringHttpMessageConverter = new StringHttpMessageConverter();
        stringHttpMessageConverter.setWriteAcceptCharset(false);
        this.messageConverters = new HttpMessageConverter[]{new ByteArrayHttpMessageConverter(), stringHttpMessageConverter,
        new SourceHttpMessageConverter(), new XmlAwareFormHttpMessageConverter()};
    }
}
</code></pre><p>如上：默认的<code>HttpMessageConverter</code>是<code>ByteArrayHttpMessageConverter</code>、<code>stringHttpMessageConverter</code>、<code>SourceHttpMessageConverter</code>和<code>XmlAwareFormHttpMessageConverter</code>转换器。所以需要配置一下：</p>
<pre><code>&lt;bean class=&quot;org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter&quot;&gt;
    &lt;property name=&quot;messageConverters&quot;&gt;
    &lt;list&gt;
        &lt;bean class=&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt;
        &lt;property name=&quot;supportedMediaTypes&quot;&gt;
            &lt;list&gt;
            &lt;value&gt;text/plain;charset=GBK&lt;/value&gt;
            &lt;/list&gt;
        &lt;/property&gt;
        &lt;/bean&gt;
        &lt;bean class=&quot;org.springframework.http.converter.json.MappingJacksonHttpMessageConverter&quot; /&gt;
    &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre><p>配置好了之后，就可以享受<code>@Requestbody</code>和<code>@ResponseBody</code>对JONS转换的便利之处了：</p>
<pre><code>@RequestMapping(value = &quot;api&quot;, method = RequestMethod.POST)
@ResponseBody
public boolean addApi(@RequestBody
    Api api, @RequestParam(value = &quot;afterApiId&quot;, required = false)
    Integer afterApiId) {
        Integer id = apiMetadataService.addApi(api);
        return id &gt; 0;
}

@RequestMapping(value = &quot;api/{apiId}&quot;, method = RequestMethod.GET)
@ResponseBody
public Api getApi(@PathVariable(&quot;apiId&quot;)
    int apiId) {
        return apiMetadataService.getApi(apiId, Version.primary);
}
</code></pre><p>一般情况下我们是不需要自定义<code>HttpMessageConverter</code>，不过对于Restful应用，有时候我们需要返回jsonp数据：</p>
<pre><code>package me.arganzheng.study.springmvc.util;

import java.io.IOException;
import java.io.PrintStream;

import org.codehaus.jackson.map.ObjectMapper;
import org.codehaus.jackson.map.annotate.JsonSerialize.Inclusion;
import org.springframework.http.HttpOutputMessage;
import org.springframework.http.converter.HttpMessageNotWritableException;
import org.springframework.http.converter.json.MappingJacksonHttpMessageConverter;
import org.springframework.web.context.request.RequestAttributes;
import org.springframework.web.context.request.RequestContextHolder;
import org.springframework.web.context.request.ServletRequestAttributes;

public class MappingJsonpHttpMessageConverter extends MappingJacksonHttpMessageConverter {

    public MappingJsonpHttpMessageConverter() {
    ObjectMapper objectMapper = new ObjectMapper();
    objectMapper.setSerializationConfig(objectMapper.getSerializationConfig().withSerializationInclusion(Inclusion.NON_NULL));
    setObjectMapper(objectMapper);
    }

    @Override
    protected void writeInternal(Object o, HttpOutputMessage outputMessage) throws IOException, HttpMessageNotWritableException {
    String jsonpCallback = null;

    RequestAttributes reqAttrs = RequestContextHolder.currentRequestAttributes();
    if(reqAttrs instanceof ServletRequestAttributes){
        jsonpCallback = ((ServletRequestAttributes)reqAttrs).getRequest().getParameter(&quot;jsonpCallback&quot;);
    }

    if(jsonpCallback != null){
        new PrintStream(outputMessage.getBody()).print(jsonpCallback + &quot;(&quot;);
    }

    super.writeInternal(o, outputMessage);

    if(jsonpCallback != null){
        new PrintStream(outputMessage.getBody()).println(&quot;);&quot;);
    }
    }
}
</code></pre><p>如果请求的参数中带有<code>jsonpCallback</code>，那么会返回jsonp格式数据。比如：<br><a href="http://open.buy.qq.com/meta/api/1.xhtml?jsonpCallback=clientFunction。" target="_blank" rel="external">http://open.buy.qq.com/meta/api/1.xhtml?jsonpCallback=clientFunction。</a><br>会返回<code>clientFunction(…);</code></p>
<h3 id="5-CookieValue"><a href="#5-CookieValue" class="headerlink" title="5. @CookieValue"></a>5. <code>@CookieValue</code></h3><p><code>@CookieValue</code>用于将请求的Cookie数据映射到功能处理方法的参数上。</p>
<pre><code>public String test(@CookieValue(value=&quot;JSESSIONID&quot;, defaultValue=&quot;&quot;) String sessionId){
    ...
}
</code></pre><p>如上配置将自动将JSESSIONID值入参到sessionId参数上，defaultValue表示Cookie中没有JSESSIONID时默认为空。</p>
<pre><code>public String test2(@CookieValue(value=&quot;JSESSIONID&quot;, defaultValue=&quot;&quot;) Cookie sessionId){
    ...
}
</code></pre><p>传入参数类型也可以是javax.servlet.http.Cookie类型。</p>
<p><strong>TIPS</strong> 如果是使用cookies值来保持回话状态的话，推荐使用Spring的<a href="http://docs.spring.io/spring/docs/3.0.0.M3/reference/html/ch04s04.html" target="_blank" rel="external">Bean Scopes</a>机制，具体参见笔者的另一篇文章：<a href="http://blog.arganzheng.me/posts/spring-bean-scopes.html" target="_blank" rel="external">Spring的Bean Scopes</a>。非常方便。</p>
<h3 id="6-RequestHeader"><a href="#6-RequestHeader" class="headerlink" title="6. @RequestHeader"></a>6. <code>@RequestHeader</code></h3><p><code>@RequestHeader</code>用于将请求的头信息区数据映射到功能处理方法的参数上。</p>
<pre><code>@RequestMapping(value=&quot;/header&quot;)
public String test(
   @RequestHeader(&quot;User-Agent&quot;) String userAgent,
   @RequestHeader(value=&quot;Accept&quot;) String[] accepts)
</code></pre><p>如上配置将自动将请求头“User-Agent”值入参到userAgent参数上，并将“Accept”请求头值入参到accepts参数上。</p>
<h3 id="7-返回多种表现形式-Returning-multiple-representations"><a href="#7-返回多种表现形式-Returning-multiple-representations" class="headerlink" title="7. 返回多种表现形式(Returning multiple representations)"></a>7. 返回多种表现形式(Returning multiple representations)</h3><p>对于Restful服务，一个资源往往有多种表现形式，比如最常见的就是返回xml和json格式数据，还有就是RSS和ATOM。怎样让客户端告诉Restful服务，我希望得到什么样表现形式的资源呢？</p>
<p>一般来说client可以通过以下三者方式来通知Server它希望拿到的资源格式：</p>
<ol>
<li>使用不同URI来表示同个资源的不同表现形式。一般使用不同的文件拓展名。如<a href="http://blog.arganzheng.me/users/argan.xml表示返回xml格式数据，而http://blog.arganzheng.me/users/aganzheng.json表示返回json格式" target="_blank" rel="external">http://blog.arganzheng.me/users/argan.xml表示返回xml格式数据，而http://blog.arganzheng.me/users/aganzheng.json表示返回json格式</a>.</li>
<li>使用一个请求参数告诉服务器希望得到的资源格式。如format=json。</li>
<li>使用同个URI，但是通过Accept HTTP request header来告诉server它理解的media types。例如同样请求<a href="http://blog.arganzheng.me/users/argan，如果带上`text/xml`" target="_blank" rel="external">http://blog.arganzheng.me/users/argan，如果带上`text/xml`</a> accept header表示请求一个XML资源，带上<code>application/pdf</code>则表示期望收到pdf格式资源。</li>
</ol>
<p>这其实就是Spring MVC默认的三个<code>ContentNegotiationStrategy</code>，即所谓的PPA Strategy（path extension, then parameter, then Accept header) ，顺序也是先path extension，然后parameter(默认是format参数)，然后才是accept头。</p>
<p>Spring提供了<a href="http://static.springsource.org/spring/docs/3.0.x/javadoc-api/org/springframework/web/servlet/view/ContentNegotiatingViewResolver.html" target="_blank" rel="external"><code>ContentNegotiatingViewResolver</code></a>来解决这个问题：</p>
<pre><code>public class ContentNegotiatingViewResolver extends WebApplicationObjectSupport implements ViewResolver, Ordered {

    private static final Log logger = LogFactory.getLog(ContentNegotiatingViewResolver.class);

    private static final String ACCEPT_HEADER = &quot;Accept&quot;;

    private static final boolean jafPresent =
        ClassUtils.isPresent(&quot;javax.activation.FileTypeMap&quot;, ContentNegotiatingViewResolver.class.getClassLoader());

    private static final UrlPathHelper urlPathHelper = new UrlPathHelper();


    private int order = Ordered.HIGHEST_PRECEDENCE;

    private boolean favorPathExtension = true;

    private boolean favorParameter = false;

    private String parameterName = &quot;format&quot;;

    private boolean useNotAcceptableStatusCode = false;

    private boolean ignoreAcceptHeader = false;

    private boolean useJaf = true;

    private ConcurrentMap&lt;String, MediaType&gt; mediaTypes = new ConcurrentHashMap&lt;String, MediaType&gt;();

    private List&lt;View&gt; defaultViews;

    private MediaType defaultContentType;

    private List&lt;ViewResolver&gt; viewResolvers;


    // ignore some setter and getter...

    public void setMediaTypes(Map&lt;String, String&gt; mediaTypes) {
      Assert.notNull(mediaTypes, &quot;&apos;mediaTypes&apos; must not be null&quot;);
      for (Map.Entry&lt;String, String&gt; entry : mediaTypes.entrySet()) {
        String extension = entry.getKey().toLowerCase(Locale.ENGLISH);
        MediaType mediaType = MediaType.parseMediaType(entry.getValue());
        this.mediaTypes.put(extension, mediaType);
      }
    }

    public void setDefaultViews(List&lt;View&gt; defaultViews) {
      this.defaultViews = defaultViews;
    }

    public void setDefaultContentType(MediaType defaultContentType) {
      this.defaultContentType = defaultContentType;
    }

    public void setViewResolvers(List&lt;ViewResolver&gt; viewResolvers) {
      this.viewResolvers = viewResolvers;
    }


    @Override
    protected void initServletContext(ServletContext servletContext) {
      if (this.viewResolvers == null) {
        Map&lt;String, ViewResolver&gt; matchingBeans =
            BeanFactoryUtils.beansOfTypeIncludingAncestors(getApplicationContext(), ViewResolver.class);
        this.viewResolvers = new ArrayList&lt;ViewResolver&gt;(matchingBeans.size());
        for (ViewResolver viewResolver : matchingBeans.values()) {
          if (this != viewResolver) {
            this.viewResolvers.add(viewResolver);
          }
        }
      }
      if (this.viewResolvers.isEmpty()) {
        logger.warn(&quot;Did not find any ViewResolvers to delegate to; please configure them using the &quot; +
            &quot;&apos;viewResolvers&apos; property on the ContentNegotiatingViewResolver&quot;);
      }
      OrderComparator.sort(this.viewResolvers);
    }

    public View resolveViewName(String viewName, Locale locale) throws Exception {
      RequestAttributes attrs = RequestContextHolder.getRequestAttributes();
      Assert.isInstanceOf(ServletRequestAttributes.class, attrs);
      List&lt;MediaType&gt; requestedMediaTypes = getMediaTypes(((ServletRequestAttributes) attrs).getRequest());
      if (requestedMediaTypes != null) {
        List&lt;View&gt; candidateViews = getCandidateViews(viewName, locale, requestedMediaTypes);
        View bestView = getBestView(candidateViews, requestedMediaTypes);
        if (bestView != null) {
          return bestView;
        }
      }
      if (this.useNotAcceptableStatusCode) {
        if (logger.isDebugEnabled()) {
          logger.debug(&quot;No acceptable view found; returning 406 (Not Acceptable) status code&quot;);
        }
        return NOT_ACCEPTABLE_VIEW;
      }
      else {
        logger.debug(&quot;No acceptable view found; returning null&quot;);
        return null;
      }
    }


    protected List&lt;MediaType&gt; getMediaTypes(HttpServletRequest request) {
      if (this.favorPathExtension) {
        String requestUri = urlPathHelper.getRequestUri(request);
        String filename = WebUtils.extractFullFilenameFromUrlPath(requestUri);
        MediaType mediaType = getMediaTypeFromFilename(filename);
        if (mediaType != null) {
          if (logger.isDebugEnabled()) {
            logger.debug(&quot;Requested media type is &apos;&quot; + mediaType + &quot;&apos; (based on filename &apos;&quot; + filename + &quot;&apos;)&quot;);
          }
          return Collections.singletonList(mediaType);
        }
      }
      if (this.favorParameter) {
        if (request.getParameter(this.parameterName) != null) {
          String parameterValue = request.getParameter(this.parameterName);
          MediaType mediaType = getMediaTypeFromParameter(parameterValue);
          if (mediaType != null) {
            if (logger.isDebugEnabled()) {
              logger.debug(&quot;Requested media type is &apos;&quot; + mediaType + &quot;&apos; (based on parameter &apos;&quot; +
                  this.parameterName + &quot;&apos;=&apos;&quot; + parameterValue + &quot;&apos;)&quot;);
            }
            return Collections.singletonList(mediaType);
          }
        }
      }
      if (!this.ignoreAcceptHeader) {
        String acceptHeader = request.getHeader(ACCEPT_HEADER);
        if (StringUtils.hasText(acceptHeader)) {
          try {
                      List&lt;MediaType&gt; mediaTypes = MediaType.parseMediaTypes(acceptHeader);
                      MediaType.sortByQualityValue(mediaTypes);
                      if (logger.isDebugEnabled()) {
                          logger.debug(&quot;Requested media types are &quot; + mediaTypes + &quot; (based on Accept header)&quot;);
                      }
                      return mediaTypes;
          }
          catch (IllegalArgumentException ex) {
            if (logger.isDebugEnabled()) {
              logger.debug(&quot;Could not parse accept header [&quot; + acceptHeader + &quot;]: &quot; + ex.getMessage());
            }
            return null;
          }
        }
      }
      if (this.defaultContentType != null) {
        if (logger.isDebugEnabled()) {
          logger.debug(&quot;Requested media types is &quot; + this.defaultContentType +
              &quot; (based on defaultContentType property)&quot;);
        }
        return Collections.singletonList(this.defaultContentType);
      }
      else {
        return Collections.emptyList();
      }
    }


    protected MediaType getMediaTypeFromFilename(String filename) {
      String extension = StringUtils.getFilenameExtension(filename);
      if (!StringUtils.hasText(extension)) {
        return null;
      }
      extension = extension.toLowerCase(Locale.ENGLISH);
      MediaType mediaType = this.mediaTypes.get(extension);
      if (mediaType == null &amp;&amp; this.useJaf &amp;&amp; jafPresent) {
        mediaType = ActivationMediaTypeFactory.getMediaType(filename);
        if (mediaType != null) {
          this.mediaTypes.putIfAbsent(extension, mediaType);
        }
      }
      return mediaType;
    }


    protected MediaType getMediaTypeFromParameter(String parameterValue) {
      return this.mediaTypes.get(parameterValue.toLowerCase(Locale.ENGLISH));
    }

    private List&lt;View&gt; getCandidateViews(String viewName, Locale locale, List&lt;MediaType&gt; requestedMediaTypes)
        throws Exception {

      List&lt;View&gt; candidateViews = new ArrayList&lt;View&gt;();
      for (ViewResolver viewResolver : this.viewResolvers) {
        View view = viewResolver.resolveViewName(viewName, locale);
        if (view != null) {
          candidateViews.add(view);
        }
        for (MediaType requestedMediaType : requestedMediaTypes) {
          List&lt;String&gt; extensions = getExtensionsForMediaType(requestedMediaType);
          for (String extension : extensions) {
            String viewNameWithExtension = viewName + &quot;.&quot; + extension;
            view = viewResolver.resolveViewName(viewNameWithExtension, locale);
            if (view != null) {
              candidateViews.add(view);
            }
          }

        }
      }
      if (!CollectionUtils.isEmpty(this.defaultViews)) {
        candidateViews.addAll(this.defaultViews);
      }
      return candidateViews;
    }

    private List&lt;String&gt; getExtensionsForMediaType(MediaType requestedMediaType) {
      List&lt;String&gt; result = new ArrayList&lt;String&gt;();
      for (Entry&lt;String, MediaType&gt; entry : this.mediaTypes.entrySet()) {
        if (requestedMediaType.includes(entry.getValue())) {
          result.add(entry.getKey());
        }
      }
      return result;
    }

    private View getBestView(List&lt;View&gt; candidateViews, List&lt;MediaType&gt; requestedMediaTypes) {
      MediaType bestRequestedMediaType = null;
      View bestView = null;
      for (MediaType requestedMediaType : requestedMediaTypes) {
        for (View candidateView : candidateViews) {
          if (StringUtils.hasText(candidateView.getContentType())) {
            MediaType candidateContentType = MediaType.parseMediaType(candidateView.getContentType());
            if (requestedMediaType.includes(candidateContentType)) {
              bestRequestedMediaType = requestedMediaType;
              bestView = candidateView;
              break;
            }
          }
        }
        if (bestView != null) {
          if (logger.isDebugEnabled()) {
            logger.debug(&quot;Returning [&quot; + bestView + &quot;] based on requested media type &apos;&quot; +
                bestRequestedMediaType + &quot;&apos;&quot;);
          }
          break;
        }
      }
      return bestView;

    }

    ...

}
</code></pre><p>可以看到<code>ContentNegotiationViewResolver</code>有点类似于ComposeCommand（参见Command模式 by GoF），它本身实现了ViewResolver接口，所以它是一个ViewResolver，但是它组合了一堆的ViewResolver，根据一定的规则（前面讨论的content negotiation）将视图请求转发给最match的ViewResolver。</p>
<p>所以关键在两点：</p>
<h4 id="1-content-negotiation策略-ContentNegotiationStrategy"><a href="#1-content-negotiation策略-ContentNegotiationStrategy" class="headerlink" title="1. content negotiation策略 (ContentNegotiationStrategy)"></a>1. content negotiation策略 (<code>ContentNegotiationStrategy</code>)</h4><blockquote>
<p>This view resolver uses the requested media type to select a suitable View for a request. This media type is determined by using the following criteria:</p>
<ol>
<li>If the requested path has a file extension and if the setFavorPathExtension(boolean) property is true, the mediaTypes property is inspected for a matching media type.</li>
<li>If the request contains a parameter defining the extension and if the setFavorParameter(boolean) property is true, the mediaTypes property is inspected for a matching media type. The default name of the parameter is format and it can be configured using the parameterName property.</li>
<li>If there is no match in the mediaTypes property and if the Java Activation Framework (JAF) is both enabled and present on the classpath, FileTypeMap.getContentType(String) is used instead.</li>
<li>If the previous steps did not result in a media type, and ignoreAcceptHeader is false, the request Accept header is used.</li>
</ol>
<p>Once the requested media type has been determined, this resolver queries each delegate view resolver for a View and determines if the requested media type is compatible with the view’s content type). The most compatible view is returned.</p>
</blockquote>
<p>这个就是上面提到的Spring MVC默认的三个<code>ContentNegotiationStrategy</code>，即所谓的PPA Strategy（path extension, then parameter, then Accept header) ，顺序也是先path extension，然后parameter(默认是format参数)，然后才是accept头。</p>
<p>关于<code>ContentNegotiationStrategy</code>，可以参考笔者的另一篇文章：<a href="http://blog.arganzheng.me/posts/content-negotiation-using-spring-mvc.html" target="_blank" rel="external">content negotiation using spring mvc</a>。有具体的实际案例。</p>
<h5 id="2-供选择的SingleViewResolver"><a href="#2-供选择的SingleViewResolver" class="headerlink" title="2. 供选择的SingleViewResolver"></a>2. 供选择的SingleViewResolver</h5><p>&gt;</p>
<ol>
<li>The ContentNegotiatingViewResolver does not resolve views itself, but delegates to other ViewResolvers. By default, these other view resolvers are picked up automatically from the application context, though they can also be set explicitly by using the viewResolvers property. Note that in order for this view resolver to work properly, the order property needs to be set to a higher precedence than the others (the default is Ordered.HIGHEST_PRECEDENCE.)<br>&gt;<br> 说明：即<code>private List&lt;ViewResolver&gt; viewResolvers;</code>属性。需要注意的是Spring会自动加载和注册所有其他的ViewResolver到<code>ContentNegotiationViewResolover</code>的<code>viewResolvers</code>属性。但是你需要告诉Spring MVC，你希望controller返回的view都是由<code>ContentNegotiationViewResolover</code>来解析，而不是其他定义的ViewResolver。这是通过order配置项来决定。你应该给<code>ContentNegotiationViewResolover</code>配置最高的order(其实默认就是最高了)。<br>&gt;</li>
<li>Additionally, this view resolver exposes the defaultViews property, allowing you to override the views provided by the view resolvers. Note that these default views are offered as candicates, and still need have the content type requested (via file extension, parameter, or Accept header, described above). You can also set the default content type directly, which will be returned when the other mechanisms (Accept header, file extension or parameter) do not result in a match.<br>&gt;<br> 说明：即<code>private List&lt;View&gt; defaultViews;</code>和<code>private MediaType defaultContentType;</code>属性。</li>
</ol>
<p>关于<code>ContentNegotiatingViewResolver</code>，下面两篇文章都不错，值得一看：</p>
<ol>
<li><a href="http://blog.eyallupu.com/2009/07/content-negotiation-using-spring-mvcs.html" target="_blank" rel="external">Content Negotiation using Spring MVC’s ContentNegotiatingViewResolver</a>:使用了<code>viewResolvers</code>配置。</li>
<li><a href="http://blog.springsource.com/2009/03/16/adding-an-atom-view-to-an-application-using-springs-rest-support/" target="_blank" rel="external">ADDING AN ATOM VIEW TO AN APPLICATION USING SPRING’S REST SUPPORT</a>:使用了<code>ViewResolvers</code>配置。</li>
<li><a href="http://www.mkyong.com/spring-mvc/spring-3-mvc-contentnegotiatingviewresolver-example/" target="_blank" rel="external">Spring 3 MVC ContentNegotiatingViewResolver Example</a>:使用了<code>defaultViews</code>配置。</li>
</ol>
<p>注意：<code>@ResponseBody</code>是为了单个View准备的，即它只能转换成一种格式，对于<code>ContentNegotiatingViewResolver</code>，需要多个<strong>Single</strong>ViewResolver来接收。</p>
<h3 id="8-客户端调用-Accessing-RESTful-services-on-the-Client"><a href="#8-客户端调用-Accessing-RESTful-services-on-the-Client" class="headerlink" title="8. 客户端调用 Accessing RESTful services on the Client"></a>8. 客户端调用 <a href="http://static.springsource.org/spring/docs/3.0.0.M3/reference/html/ch18s03.html#rest-resttemplate" target="_blank" rel="external">Accessing RESTful services on the Client</a></h3><p>Spring MVC不仅大大的简化了服务端RESTful服务的开发和开放，还提供了一些辅助类来方便客户端调用REST服务。</p>
<p>以前Client如果要调用REST服务，一般是使用HttpClient来发送HTTP请求：</p>
<pre><code>String uri = &quot;http://example.com/hotels/1/bookings&quot;;

PostMethod post = new PostMethod(uri);
String request = // create booking request content
post.setRequestEntity(new StringRequestEntity(request));

httpClient.executeMethod(post);

if (HttpStatus.SC_CREATED == post.getStatusCode()) {
  Header location = post.getRequestHeader(&quot;Location&quot;);
  if (location != null) {
    System.out.println(&quot;Created new booking at :&quot; + location.getValue());
  }
}
</code></pre><p>太过底层，而且代码比较冗长，一般都要手动封装一下（即类似于SDK，封装了签名和HTTP发送和接受细节）。我们看一下Spring MVC是怎么解决这个问题的。</p>
<h4 id="RestTemplate"><a href="#RestTemplate" class="headerlink" title="RestTemplate"></a><a href="http://blog.springsource.org/2009/03/27/rest-in-spring-3-resttemplate/" target="_blank" rel="external">RestTemplate</a></h4><p>RestTemplate是client-site HTTP access的核心类。正如它的名称所示，<code>RestTemplate</code>非常类似于<code>JdbcTemplate</code>, <code>JmsTemplate</code>等XXXTemplate。这意味着<code>RestTemplate</code>是线程安全的并且可以通过callback来定制它的行为。</p>
<p><strong>TIPS</strong> Spring提供的Template类非常灵活和好用，种类也很丰富。当你需要做一些事情的时候可以先考虑一下有没有相应的template可以用。</p>
<p>RestTemplate默认使用<code>java.net</code>包下的基础类来创建HTTP请求。你可以实现<code>ClientHttpRequestFactory</code>接口，提供你自己的Http请求工厂类。Spring提供了<code>CommonsClientHttpRequestFactory</code>，这个工厂类使用Jakarta Commons HttpClient来创建HTTP请求。这样就可以使用HttpClient提供的认证和链接池功能了。</p>
<p><a href="http://static.springsource.org/spring/docs/3.0.x/javadoc-api/org/springframework/web/client/RestTemplate.html" target="_blank" rel="external">RestTemplate提供的方法如下</a>：</p>
<blockquote>
<p><strong>HTTP Method</strong>    <strong>RestTemplate Method</strong></p>
<ul>
<li>DELETE    delete(String url, String… urlVariables)</li>
<li>GET    getForObject(String url, Class<t> responseType, String… urlVariables)</t></li>
<li>HEAD    headForHeaders(String url, String… urlVariables)</li>
<li>OPTIONS    optionsForAllow(String url, String… urlVariables)</li>
<li>POST    postForLocation(String url, Object request, String… urlVariables)</li>
<li>PUT    put(String url, Object request, String…urlVariables)</li>
<li>ANY    exchange(String, HttpMethod, HttpEntity, Class, Object…)<pre><code>execute(String, HttpMethod, RequestCallback, ResponseExtractor, Object...)
</code></pre></li>
</ul>
</blockquote>
<p>方法名称很有规律，都是这个pattern——<code>${HTTP Method}${WhatIsReturne}</code>。例如getForObject() will perform a GET, convert the HTTP response into an object type of your choice, and returns that object. postForLocation will do a POST, converting the given object into a HTTP request, and returns the response HTTP Location header where the newly created object can be found. As you can see, these methods try to enforce REST best practices.</p>
<p>其中getForObject()、postForLocation()和put()方法接收或者返回的参数通过<code>HttpMessageConverter</code>来转换为Http Request或者Http Response。这点与前面介绍服务端RESTful的<code>@RequestBody</code>和<code>@ResponseBody</code>是一样的，Spring MVC默认会注册常用的Converter，你也可以自定义。</p>
<p>另外，每个方法的第一个参数都是一个url string，但是这个URI可以带有变量(还记得<code>@PathVariable</code>吗:)哦。参数有两种方式绑定值：</p>
<ol>
<li><p>作为字符串变量数组(String variable arguments array)</p>
<pre><code>String result = restTemplate.getForObject(&quot;http://example.com/hotels/{hotel}/bookings/{booking}&quot;, String.class, &quot;42&quot;, &quot;21&quot;);
</code></pre><p> 会转换为一个对<code>http://example.com/hotels/42/bookings/21</code>的GET请求。</p>
</li>
<li><p>或者Map对象(Map)</p>
<p>The map variant expands the template based on variable name, and is therefore more useful when using many variables, or when a single variable is used multiple times.</p>
<pre><code>Map&lt;String, String&gt; vars = new HashMap&lt;String, String&gt;();
vars.put(&quot;hotel&quot;, &quot;42&quot;);
vars.put(&quot;booking&quot;, &quot;21&quot;);
String result = restTemplate.getForObject(&quot;http://example.com/hotels/{hotel}/bookings/{booking}&quot;, String.class, vars);
会转换为一个对`http://example.com/hotels/42/rooms/42`的GET请求。
</code></pre></li>
</ol>
<p>关于RestTemplate使用的具体例子可以参考这篇文章<a href="http://blog.springsource.org/2009/03/27/rest-in-spring-3-resttemplate/" target="_blank" rel="external"><br>REST IN SPRING 3: RESTTEMPLATE</a>。写的非常好，强烈推荐！</p>
<h3 id="9-支持RESTful的URL"><a href="#9-支持RESTful的URL" class="headerlink" title="9. 支持RESTful的URL"></a>9. 支持RESTful的URL</h3><p>在开发功能模块之前，应该先把URL设计好。比查对 <strong>消息</strong> 这个资源的操作URL可以这么设计：</p>
<pre><code>http://arganzheng.me/messages/show/123456
http://arganzheng.me/messages/preview/123456
http://arganzheng.me/messages/delete/123456
http://arganzheng.me/messages/new
http://arganzheng.me/message/update
</code></pre><p>说明：可以看到我们的URL中有动作在里面，事实上纯粹的RESTful URL是把动作隐含在HTTP头中：GET、PUT、DELETE、POST。。不过这样对用户编码有要求，这个相对简单点。</p>
<p>要支持这种URL，web.xml需要这么配置：</p>
<pre><code>&lt;!-- REST servlet-mapping --&gt;
&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;DispatcherServlet&lt;srvlet-name&gt;
    &lt;url-pattern&gt;/&lt;/url-pattern&gt;
&lt;srvlet-mapping&gt;
</code></pre><p>但是这样的话有个问题，就是静态文件也被mapping了，会导致找不到资源。Spring提供了一个resources配置项支持静态文件的处理<a href="http://static.springsource.org/spring/docs/3.1.x/spring-framework-reference/html/mvc.html#mvc-config-static-resources" target="_blank" rel="external">16.14.5 Configuring Serving of Resources</a>：</p>
<pre><code>&lt;!-- Forwards requests to the &quot;/&quot; resource to the &quot;welcome&quot; view --&gt;
  &lt;mvc:view-controller path=&quot;/&quot; view-name=&quot;index&quot;/&gt;

  &lt;!-- Handles HTTP GET requests for /resources/** by efficiently serving up static resources in the ${webappRoot}/resources/ directory --&gt;
  &lt;mvc:resources mapping=&quot;/resources/**&quot; location=&quot;/resources/&quot; /&gt;
  &lt;!-- 注意：配置了mvc:resources就必须配置这个选项，否则handler mapping都失效了
      @see  http://stackoverflow.com/questions/7910845/the-handler-mapping-from-the-mvcresource-override-other-mappings-which-defined
  --&gt;
  &lt;mvc:annotation-driven /&gt;
</code></pre><p>这样所有请求：<code>http://arganzheng.me/resources/**</code>会映射到webapp下的resources目录，而不是找我们的controller处理。</p>
<p>但是有个奇怪的问题，就是配置这个之后，原来动态东西就不能访问到了，提示找不到对应的handler，解决方案是增加一个<code>&lt;mvc:annotation-driven /&gt;</code>配置。具体参见<a href="http://stackoverflow.com/questions/7910845/the-handler-mapping-from-the-mvcresource-override-other-mappings-which-defined" target="_blank" rel="external">The handler mapping from the mvc:resource override other mappings which defined with annotation</a>。</p>
<p>另外，静态的html页面一般不放在resources路面下，而是直接在根目录下，比如：<a href="http://arganzheng.me/index.html或者http://arganzheng.me/404.html。所以应该在web.xml中在配置一个url-mapping规则：" target="_blank" rel="external">http://arganzheng.me/index.html或者http://arganzheng.me/404.html。所以应该在web.xml中在配置一个url-mapping规则：</a></p>
<pre><code>&lt;!-- 避免被Spring DispatcherServlet接管 --&gt;
  &lt;servlet-mapping&gt;
      &lt;servlet-name&gt;default&lt;srvlet-name&gt;
      &lt;url-pattern&gt;*.html&lt;/url-pattern&gt;
  &lt;srvlet-mapping&gt;
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Spring MVC本身对Restful支持非常好。它的&lt;code&gt;@RequestMapping&lt;/code&gt;、&lt;code&gt;@RequestParam&lt;/code&gt;、&lt;code&gt;@PathVariable&lt;/code&gt;、&lt;code&gt;@ResponseBody&lt;/code&gt;注解很好的支持了REST。&lt;a href=&quot;http://static.springsource.org/spring/docs/3.0.0.M3/reference/html/ch18s02.html&quot;&gt;18.2 Creating RESTful services&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;1-RequestMapping&quot;&gt;&lt;a href=&quot;#1-RequestMapping&quot; class=&quot;headerlink&quot; title=&quot;1. @RequestMapping&quot;&gt;&lt;/a&gt;1. &lt;code&gt;@RequestMapping&lt;/code&gt;&lt;/h3&gt;&lt;p&gt;Spring uses the @RequestMapping method annotation to define the URI Template for the request. 类似于struts的action-mapping。 可以指定POST或者GET。&lt;/p&gt;
&lt;h3 id=&quot;2-PathVariable&quot;&gt;&lt;a href=&quot;#2-PathVariable&quot; class=&quot;headerlink&quot; title=&quot;2. @PathVariable&quot;&gt;&lt;/a&gt;2. &lt;code&gt;@PathVariable&lt;/code&gt;&lt;/h3&gt;&lt;p&gt;The @PathVariable method parameter annotation is used to indicate that a method parameter should be bound to the value of a URI template variable. 用于抽取URL中的信息作为参数。（注意，不包括请求字符串，那是&lt;code&gt;@RequestParam&lt;/code&gt;做的事情。）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@RequestMapping(&amp;quot;/owners/{ownerId}&amp;quot;, method=RequestMethod.GET)
public String findOwner(@PathVariable String ownerId, Model model) {
        // ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果变量名与pathVariable名不一致，那么需要指定：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@RequestMapping(&amp;quot;/owners/{ownerId}&amp;quot;, method=RequestMethod.GET)
public String findOwner(@PathVariable(&amp;quot;ownerId&amp;quot;) String theOwner, Model model) {
    // implementation omitted
}
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Tip&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;method parameters that are decorated with the @PathVariable annotation can be of any simple type such as int, long, Date… Spring automatically converts to the appropriate type and throws a TypeMismatchException if the type is not correct.&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="spring" scheme="https://www.shenyanchao.cn/categories/spring/"/>
    
    
      <category term="spring" scheme="https://www.shenyanchao.cn/tags/spring/"/>
    
      <category term="restful" scheme="https://www.shenyanchao.cn/tags/restful/"/>
    
      <category term="mvc" scheme="https://www.shenyanchao.cn/tags/mvc/"/>
    
  </entry>
  
  <entry>
    <title>关于C3P0容错和自动重连特性的研究</title>
    <link href="https://www.shenyanchao.cn/blog/2015/03/26/c3p0-config/"/>
    <id>https://www.shenyanchao.cn/blog/2015/03/26/c3p0-config/</id>
    <published>2015-03-26T05:07:00.000Z</published>
    <updated>2018-12-20T11:58:21.621Z</updated>
    
    <content type="html"><![CDATA[<p>最近常有数据库和网络设备升级和搬迁等事情，而各个应用都是基于数据库连接池做的，大部分都是基于C3P0，数据库或网络状况的变动都会导致客户端连接池中的connection失效，如何剔除这些blocked connection就和C3P0的各个配置息息相关。</p>
<h4 id="1）C3P0容错和自动重连与以下配置参数有关："><a href="#1）C3P0容错和自动重连与以下配置参数有关：" class="headerlink" title="1）C3P0容错和自动重连与以下配置参数有关："></a>1）C3P0容错和自动重连与以下配置参数有关：</h4><p><code>breakAfterAcquireFailure</code> ：true表示pool向数据库请求连接失败后标记整个pool为block并close，就算后端数据库恢复正常也不进行重连，客户端对pool的请求都拒绝掉。false表示不会标记 pool为block，新的请求都会尝试去数据库请求connection。默认为false。因此，如果想让数据库和网络故障恢复之后，pool能继续请求正常资源必须把此项配置设为false<br><a id="more"></a><br><code>idleConnectionTestPeriod</code> ：C3P0会有一个Task检测pool内的连接是否正常，此参数就是Task运行的频率。默认值为0，表示不进行检测。</p>
<p><code>testConnectionOnCheckout</code> ：true表示在每次从pool内checkout连接的时候测试其有效性，这是个同步操作，因此应用端的每次数据库调用，都会先通过测试sql测试其有效性，如果连接无效，会关闭此连接并剔除出pool，并尝试从pool内取其他连接，默认为false，此特性要慎用，会造成至少多一倍的数据库调用。</p>
<p><code>testConnectionOnCheckin</code> ：true表示每次把连接checkin到pool里的时候测试其有效性，因为是个事后操作，所以是异步的，应用端不需要等待测试结果，但同样会造成至少多一倍的数据库调用。</p>
<p><code>acquireRetryAttempts 和acquireRetryDelay</code> ：pool请求取连接失败后重试的次数和重试的频率。请求连接会发生在pool内连接少于min值或则等待请求数&gt;池内能提供的连接数</p>
<p><code>automaticTestTable 、connectionTesterClassName 、preferredTestQuery</code> ：表示测试方式，默认是采用DatabaseMetaData.getTables()来测试connection的有效性，但可以通过以上配置来定制化测试语句，通过其名字就很好理解其含义，无需过多解释</p>
<p><code>maxIdleTime 和 maxConnectionAge</code> ：表示connection的时效性，maxIdleTime和maxConnectionAge不同之处在于， maxIdleTime表示idle状态的connection能存活的最大时间，而 maxConnectionAge表示connection能存活的绝对时间</p>
<h4 id="2）应用端getConnection抛出exception时，-C3P0会测试其connection的有效性，并根据状态处理此connection，但应用端不会重调。"><a href="#2）应用端getConnection抛出exception时，-C3P0会测试其connection的有效性，并根据状态处理此connection，但应用端不会重调。" class="headerlink" title="2）应用端getConnection抛出exception时， C3P0会测试其connection的有效性，并根据状态处理此connection，但应用端不会重调。"></a>2）应用端getConnection抛出exception时， C3P0会测试其connection的有效性，并根据状态处理此connection，但应用端不会重调。</h4><h4 id="3）无论是网络问题还是远端数据库服务器，就算恢复正常后，客户端pool内其已存在的connection都会失效，要保证应用端调用无误，必须在checkout到应用端之前刷新这些无效connection"><a href="#3）无论是网络问题还是远端数据库服务器，就算恢复正常后，客户端pool内其已存在的connection都会失效，要保证应用端调用无误，必须在checkout到应用端之前刷新这些无效connection" class="headerlink" title="3）无论是网络问题还是远端数据库服务器，就算恢复正常后，客户端pool内其已存在的connection都会失效，要保证应用端调用无误，必须在checkout到应用端之前刷新这些无效connection"></a>3）无论是网络问题还是远端数据库服务器，就算恢复正常后，客户端pool内其已存在的connection都会失效，要保证应用端调用无误，必须在checkout到应用端之前刷新这些无效connection</h4><h4 id="4）breakAfterAcquireFailure-false是关键。"><a href="#4）breakAfterAcquireFailure-false是关键。" class="headerlink" title="4）breakAfterAcquireFailure=false是关键。"></a>4）breakAfterAcquireFailure=false是关键。</h4><p>如果 breakAfterAcquireFailure=true ，一旦pool向数据库请求连接失败，就会标记pool block并关闭pool，这样无论数据库是否恢复正常，应用端都无法从pool拿到连接</p>
<h4 id="5）要想保证网络和数据库瞬间的失效100-不会造成应用端getConnection失败必须开启testConnectionOnCheckout。但此特性的代价巨大，建议在应用端做容错。"><a href="#5）要想保证网络和数据库瞬间的失效100-不会造成应用端getConnection失败必须开启testConnectionOnCheckout。但此特性的代价巨大，建议在应用端做容错。" class="headerlink" title="5）要想保证网络和数据库瞬间的失效100%不会造成应用端getConnection失败必须开启testConnectionOnCheckout。但此特性的代价巨大，建议在应用端做容错。"></a>5）要想保证网络和数据库瞬间的失效100%不会造成应用端getConnection失败必须开启testConnectionOnCheckout。但此特性的代价巨大，建议在应用端做容错。</h4><h4 id="6）推荐使用-idleConnectionTestPeriod。可以根据应用调用频率权衡一个检查pool的频率，这样可以在保证性能损耗不大情况下，尽可能的保证pool内connection的有效性"><a href="#6）推荐使用-idleConnectionTestPeriod。可以根据应用调用频率权衡一个检查pool的频率，这样可以在保证性能损耗不大情况下，尽可能的保证pool内connection的有效性" class="headerlink" title="6）推荐使用 idleConnectionTestPeriod。可以根据应用调用频率权衡一个检查pool的频率，这样可以在保证性能损耗不大情况下，尽可能的保证pool内connection的有效性"></a>6）推荐使用 idleConnectionTestPeriod。可以根据应用调用频率权衡一个检查pool的频率，这样可以在保证性能损耗不大情况下，尽可能的保证pool内connection的有效性</h4><h4 id="7）若嫌DatabaseMetaData-getTables-性能不好，可以尝试通过配置automaticTestTable、connectionTesterClassName、preferredTestQuery来找到一个性能最好的测试语句，只要能验证connection有效就行"><a href="#7）若嫌DatabaseMetaData-getTables-性能不好，可以尝试通过配置automaticTestTable、connectionTesterClassName、preferredTestQuery来找到一个性能最好的测试语句，只要能验证connection有效就行" class="headerlink" title="7）若嫌DatabaseMetaData.getTables()性能不好，可以尝试通过配置automaticTestTable、connectionTesterClassName、preferredTestQuery来找到一个性能最好的测试语句，只要能验证connection有效就行"></a>7）若嫌DatabaseMetaData.getTables()性能不好，可以尝试通过配置automaticTestTable、connectionTesterClassName、preferredTestQuery来找到一个性能最好的测试语句，只要能验证connection有效就行</h4><p>综上所述，要想保证性能的前提下，本人推荐的配置组合如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">break</span>AfterAcquireFailure: <span class="literal">false</span></div><div class="line"><span class="built_in">test</span>ConnectionOnCheckout: <span class="literal">false</span></div><div class="line"><span class="built_in">test</span>ConnectionOnCheckin: <span class="literal">false</span></div><div class="line">idleConnectionTestPeriod: 60</div><div class="line">acquireRetryAttempts: 10</div><div class="line">acquireRetryDelay: 1000</div></pre></td></tr></table></figure>
<p>但需要注意的是以上的配置不能保证100%应用端getConnection无误，如果应用端不能发生getConnection错误，需要自行考虑容错和重试机制。</p>
<p>在以上配置下，当网络或数据库发生瞬间变动的情况下，会有如下事情发生：</p>
<ul>
<li><p>1）自动测试idleConnection的 task轮训检测pool，对每个connction通过DatabaseMetaData.getTables()来测试有效性，并剔除无效连接。</p>
</li>
<li><p>2）根据请求情况和配置，pool向数据库请求新连接并加入池内</p>
</li>
<li><p>3）应用端getConnection-&gt;是否发生异常-&gt;如果发生异常，检验其有效性，并剔除出pool-&gt;如果没有发生异常（自动检查task之前已检测），调用成功</p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近常有数据库和网络设备升级和搬迁等事情，而各个应用都是基于数据库连接池做的，大部分都是基于C3P0，数据库或网络状况的变动都会导致客户端连接池中的connection失效，如何剔除这些blocked connection就和C3P0的各个配置息息相关。&lt;/p&gt;
&lt;h4 id=&quot;1）C3P0容错和自动重连与以下配置参数有关：&quot;&gt;&lt;a href=&quot;#1）C3P0容错和自动重连与以下配置参数有关：&quot; class=&quot;headerlink&quot; title=&quot;1）C3P0容错和自动重连与以下配置参数有关：&quot;&gt;&lt;/a&gt;1）C3P0容错和自动重连与以下配置参数有关：&lt;/h4&gt;&lt;p&gt;&lt;code&gt;breakAfterAcquireFailure&lt;/code&gt; ：true表示pool向数据库请求连接失败后标记整个pool为block并close，就算后端数据库恢复正常也不进行重连，客户端对pool的请求都拒绝掉。false表示不会标记 pool为block，新的请求都会尝试去数据库请求connection。默认为false。因此，如果想让数据库和网络故障恢复之后，pool能继续请求正常资源必须把此项配置设为false&lt;br&gt;
    
    </summary>
    
      <category term="c3p0" scheme="https://www.shenyanchao.cn/categories/c3p0/"/>
    
    
      <category term="c3p0" scheme="https://www.shenyanchao.cn/tags/c3p0/"/>
    
      <category term="dhcp" scheme="https://www.shenyanchao.cn/tags/dhcp/"/>
    
  </entry>
  
  <entry>
    <title>如何在Solr中更好的处理同义词</title>
    <link href="https://www.shenyanchao.cn/blog/2014/11/25/better-synonym-handling-in-solr/"/>
    <id>https://www.shenyanchao.cn/blog/2014/11/25/better-synonym-handling-in-solr/</id>
    <published>2014-11-25T05:53:00.000Z</published>
    <updated>2018-12-24T06:36:28.255Z</updated>
    
    <content type="html"><![CDATA[<p>当使用Solr来构建搜索引擎的时候，你可能经常会遇到这样的场景：你有一个同义词列表，并且你想用户查询也能够命中到同义词。听起来很简单不是吗？为什么搜索“dog”的时候，不能命中包含“hound(猎犬)”或者“pooch(狗)”的文档呢？甚至包含“Rover(流浪者)”和“canis familiaris(犬)”?</p>
<p><img src="/images/blog/2014/File-Licking_the_staffy_pup.JPG" alt="solr plugin 小狗"></p>
<p>叫Rover或者其他名字，可能只是为了让小狗听起来很可爱。</p>
<p>事实证明，Solr的同义词扩展没有你想象的那么简单。但是我们有很多好的方法来搬石头砸自己的脚。</p>
<a id="more"></a>
<h3 id="The-SynonymFilterFactory"><a href="#The-SynonymFilterFactory" class="headerlink" title="The SynonymFilterFactory"></a>The SynonymFilterFactory</h3><p>Solr提供了一个听起来很酷的SynonymFilterFactory,它可以接收一个逗号分割的同义词文本。你甚至可以选择同义词是相互扩展还是特定方向的替换。</p>
<p>举例来说，你可以让“dog”，“hound”和“pooch”都扩展为“dog|hound|pooch”，或者你可以指定“dog”映射到“hound”，反过来却不可以，或者你可以把所有的词都转化为”dog“,Solr处理这部分是非常灵活的并且做的很棒。</p>
<p>当你考虑是把SynonymFilterFactory放在查询分析器还是索引分析器时，这个问题就变得很复杂啦。</p>
<h3 id="Index-time-vs-query-time"><a href="#Index-time-vs-query-time" class="headerlink" title="Index-time vs. query-time"></a>Index-time vs. query-time</h3><p>下图总结了查询时（query-time）和索引时（index-time）同义词扩展的基本差异。当然我们是为了解决solr中使用的问题，但是这2种方法适用于任何信息检索系统。</p>
<p><img src="/images/blog/2014/index_vs_query_expansion2.png" alt="Index-time vs. query-time expansion."></p>
<p>你的直观选择可能是将SynonymFilterFactory放在查询分析器内。理论上，这样做有以下优点：</p>
<ul>
<li>索引大小不会变化</li>
<li>同义词可以随时更换，不用更新索引</li>
<li>同义词实时生效，不需要重新索引</li>
</ul>
<p>然而，按<a href="http://wiki.apache.org/solr/AnalyzersTokenizersTokenFilters#solr.SynonymFilterFactory" target="_blank" rel="external">Solr Docs</a>所说，这是一个Very Bad Thing to Do(™)，显然的你应该把SynonymFilterFactory放在索引分析器里，而不是简单的依靠你的直觉来判断。文档里说，查询时的同义词扩展有以下的缺点：</p>
<ul>
<li>多字同义词并不能识别为短语查询</li>
<li>罕见同义词的IDF会被加权，导致不可想象的搜索结果</li>
<li>多字同义词不会匹配查询</li>
</ul>
<p>这有点复杂，因此也值得我们一一解决这些问题。</p>
<h3 id="多字同义词并不能识别为短语查询"><a href="#多字同义词并不能识别为短语查询" class="headerlink" title="多字同义词并不能识别为短语查询"></a>多字同义词并不能识别为短语查询</h3><p>在Health On the Net,我们的搜索引擎使用MeSH来做查询扩展，MeSH是一个为健康领域提供优质同义词的医疗本体。例如”breast cancer“的同义词：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">breast neoplasm</div><div class="line">breast neoplasms</div><div class="line">breast tumor</div><div class="line">breast tumors</div><div class="line">cancer of breast</div><div class="line">cancer of the breast</div></pre></td></tr></table></figure>
<p>因此在正常情况下，如果SynonymFilterFactory配置了<code>expand=&quot;true&quot;</code>,查询”breast cancer“就变成了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">+((breast breast breast breast breast cancer cancer) (cancer neoplasm neoplasms tumor tumors) breast breast)</div></pre></td></tr></table></figure>
<p>这将命中包含”breast neoplasms“,”cancer of the breast”等等的文档。</p>
<p>然而，这也意味着，如果你正在做一个短语查询（比如”breast cancer“）,如果想生效，你的文档必须字面上匹配类似”breast cancer breast breast“这样的字符。</p>
<p>啊？这里到底发生了什么？事实证明SynonymFilterFactory并没有按你所想来扩展多字同义词。直觉上，可能认为它表现为一个有限自动机，Solr构建出的结果可能类似这样(忽略复数)：</p>
<p><img src="/images/blog/2014/graph11.png" alt="Lucene FSA"></p>
<p>但是，它真正构建的是下面这样的：</p>
<p><img src="/images/blog/2014/graph22.png" alt="Lucene FSA"></p>
<p>简直是一碗意大利面。</p>
<p>你可怜的文档必须依序包含所有的4个部分。让人惊讶。</p>
<p>同样，DisMax和EDisMax查询分析器的mm(最小匹配)参数，并不能像你所想的那样工作。在上面的例子中，设置<code>mm=100%</code>将需要所有4个部分都匹配。</p>
<pre><code>+((breast breast breast breast breast cancer cancer) (cancer neoplasm neoplasms tumor tumors) breast breast)~4
</code></pre><h3 id="罕见同义词的IDF会被加权"><a href="#罕见同义词的IDF会被加权" class="headerlink" title="罕见同义词的IDF会被加权"></a>罕见同义词的IDF会被加权</h3><p>即使你没有多字同义词，Solr Docs也提到了第二个避免查询时扩展的原因：不正常的IDF加权。考虑我们的”dog”,”hound”,”pooch”例子，查询3个里面的任意一个都会被扩展为：</p>
<pre><code>+(dog hound pooch)
</code></pre><p>由于“hound”和”pooch“是比较少见的字，因此无论查询什么，包含这些字的文档会在查询结果中排名特别高。这对可怜的用户来说，简直是一个浩劫，为什么搜索”dog“的时候，会有那么多包含”hound“和”pooch“的怪异文档排名那么高。</p>
<p>索引时扩展通过给”dog”,”hound”,”pooch”赋予相同的IDF值，而不管原始文档是什么。</p>
<h3 id="多字同义词不会匹配查询"><a href="#多字同义词不会匹配查询" class="headerlink" title="多字同义词不会匹配查询"></a>多字同义词不会匹配查询</h3><p>最后，也是最严重的是，如果你对用户查询做任意类型的分词，SynonymFilterFactory并不会匹配多字同义词。这是因为分词器会将用户输入分开，然后才交给SynonymFilterFactory来转换。</p>
<p>比如，查询“cancer of the breast”会被StandardTokenizationFactory分词为[“cancer”,”of”,”the”,”breast]，并且只有独立的词才会传给SynonymFilterFactory。因此，在这种情况下，如果分词后的单个词，比如‘cancer“和”breast“都没有同义词的情况下，同义词扩展就压根不会发生。</p>
<h3 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h3><p>最初，我按照Solr的建议，使用索引时扩展，但是我发现索引时同义词扩展有它自己的问题。显然，除了有索引爆炸的问题，我还发现一个关于高亮的有趣的bug。</p>
<p>当我搜索”breast cancer“的时候，我发现高亮器会很神奇的把”breast cancer X Y“给高亮了，其中”X“和”Y“是文档中任何跟在”breast cancer“后面的2个字符。例如，它可能会高亮”breast cancer frauds are“或者”breast cancer is to“。</p>
<p><img src="/images/blog/2014/breast_cancer_highlighting2.png" alt="solr highlight bug"></p>
<p>看完这个<a href="https://issues.apache.org/jira/browse/SOLR-3390" target="_blank" rel="external">solr bug</a>,这和前面提到的Solr多字同义词扩展是一个原因。</p>
<p>使用查询时扩展，你的查询被转换为像意大利面般的图已经足够的怪异了。但是在索引时扩展，假如你的文档包含”breast cancer treatment options“,会变成什么样子呢。</p>
<p><img src="/images/blog/2014/graph33.png" alt=""></p>
<p>这就是Lucene认为的你文档的样子。同义词扩展给你带来了比你要求更多的东西，类似”Dada-esque“的结果！”Breast tumor the options“确实是这样的。</p>
<p>从根本上来说，Lucene认为一个查询”cancer of the breast“(4个Token)和你原始文档里的”breast cancer treatment options“(4个Token)是一样的。这是因为Tokens只是一个叠加另一个上面而已，丢失任何信息的部分都可以由它后面的部门来替代。</p>
<p>查询时扩展不会引起这个问题，因为Solr只扩展了查询，而不是文档。因此Lucene仍然认为查询的”cancer of the breast“只会匹配文档里的”breast cancer“。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>所有这些古怪的问题，让我得出这样的结论：Solr内建的同义词扩展机制是及其糟糕的。我必须找出一个更好的方法来让Solr按我想的来运行。</p>
<p>总之，无论是索引时扩展还是查询时扩展使用标准的SynonymFilterFactory都是不可行的，因为它们都有各自不同的问题。</p>
<p><strong>Index-time</strong></p>
<ul>
<li>索引爆炸</li>
<li>同义词不能立即生效，所有文档需重新索引</li>
<li>同义词不能立即删除</li>
<li>多字同义词导致多余的文字被高亮</li>
</ul>
<p><strong>Query-time</strong></p>
<ul>
<li>短语查询不支持</li>
<li>罕见同义词被认为加权了</li>
<li>多字同义词不匹配查询</li>
</ul>
<p>我开始假设理想的同义词扩展系统应该是基于查询时的，由于基于索引的扩展有那么多固有的缺点。同时，我也意识到在Solr实现同义词扩展之前，有一个更加根本的问题需要解决。</p>
<p>回到”dog“/“hound”/“pooch”的例子，对待3个词对等的是不明智的。在特定的查询中，”dog“可能并不与”hound“和”pooch“是一样的，比如 (e.g. “The Hound of the Baskervilles,” “The Itchy &amp; Scratchy &amp; Poochy Show”). 一视同仁感觉是错误的。</p>
<p>同样的，即使使用官方推荐的索引时扩展，IDF权重也被抛弃了。每个包含”dog“的文章现在也都包含”pooch“，这意味着我们将永久的丢失关于”pooch“的真实IDF值。</p>
<p>在一个理想的系统里，搜索”dog“，返回的结果应该包含所有存在”hound“和”pooch“的文档，但是应该将所有包含真实查询的文档排的更靠前面，包含”dog“的应该得到更高的分。同样的，搜索“hound”应该把包含“hound”的排的更靠前面，搜索“pooch”就应该将包含“pooch”的更靠前。所有的3个搜索都返回相同的文档集，但是结果排序不一样。</p>
<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>我的解决方法是，把同义词扩展从分析器的Tokenizer链移动到QueryParser。不是把查询变成如上面的纵横交错的图，而是把它分为2个部分：主查询和同义词查询。然后我为每个部分独立配置权重，指定每个部分内部为“should occur”。最后将二者使用“must occur”的布尔查询包装起来。</p>
<p>因此，搜索“dog”为被解析为类似这样：</p>
<pre><code>+((dog)^1.2 (hound pooch)^1.1)
</code></pre><p>1.2和1.1是独立的权重，可以配置。文档必须包含“dog”,”hound”或者“pooch”，但是“dog”更优先显示。</p>
<p>这样来处理同义词，带来了另一个有趣的副作用：它消除了短语查询不支持的问题。如果是“breast cancer”(带引号)，将会被解析为这样：</p>
<pre><code>+((&quot;breast cancer&quot;)^1.2 ((&quot;breast neoplasm&quot;) (&quot;breast tumor&quot;) (&quot;cancer ? breast&quot;) (&quot;cancer ? ? breast&quot;))^1.1)
</code></pre><p>(问号?的出现是由于停用词“of”和“the”)</p>
<p>这意味着查询带引号的“breast cancer”会匹配所有包含“breast neoplasm,” “breast tumor,” “cancer of the breast,” and “cancer of breast.“字符的文档。</p>
<p>我比原始的SynonymFilterFactory更进一步，针对一个特定的查询构建了所有可能的同义词组合查询。比如查询”dog bite“,同义词文件是：</p>
<pre><code>dog,hound,pooch
bite,nibble
</code></pre><p>… then the query will be expanded into:</p>
<p>查询将会被扩展为：</p>
<pre><code>dog bite
hound bite
pooch bite
dog nibble
hound nibble
pooch nibble
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当使用Solr来构建搜索引擎的时候，你可能经常会遇到这样的场景：你有一个同义词列表，并且你想用户查询也能够命中到同义词。听起来很简单不是吗？为什么搜索“dog”的时候，不能命中包含“hound(猎犬)”或者“pooch(狗)”的文档呢？甚至包含“Rover(流浪者)”和“canis familiaris(犬)”?&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/blog/2014/File-Licking_the_staffy_pup.JPG&quot; alt=&quot;solr plugin 小狗&quot;&gt;&lt;/p&gt;
&lt;p&gt;叫Rover或者其他名字，可能只是为了让小狗听起来很可爱。&lt;/p&gt;
&lt;p&gt;事实证明，Solr的同义词扩展没有你想象的那么简单。但是我们有很多好的方法来搬石头砸自己的脚。&lt;/p&gt;
    
    </summary>
    
      <category term="solr" scheme="https://www.shenyanchao.cn/categories/solr/"/>
    
    
      <category term="同义词" scheme="https://www.shenyanchao.cn/tags/%E5%90%8C%E4%B9%89%E8%AF%8D/"/>
    
      <category term="solr" scheme="https://www.shenyanchao.cn/tags/solr/"/>
    
      <category term="lucene" scheme="https://www.shenyanchao.cn/tags/lucene/"/>
    
  </entry>
  
  <entry>
    <title>使用mahout对Sogou语料库进行分类</title>
    <link href="https://www.shenyanchao.cn/blog/2014/11/14/use-mahout-to-classify-sogou-corpus/"/>
    <id>https://www.shenyanchao.cn/blog/2014/11/14/use-mahout-to-classify-sogou-corpus/</id>
    <published>2014-11-14T05:26:00.000Z</published>
    <updated>2018-12-24T06:52:54.060Z</updated>
    
    <content type="html"><![CDATA[<h3 id="软件版本"><a href="#软件版本" class="headerlink" title="软件版本"></a>软件版本</h3><ul>
<li>Ubuntu Linux</li>
<li><a href="http://mirror.bit.edu.cn/apache/mahout/0.9/mahout-distribution-0.9.tar.gz" target="_blank" rel="external">mahout-0.9</a>,本文写作的时候的最新版本</li>
<li><a href="http://download.labs.sogou.com/dl/sogoulabdown/SogouC.reduced.20061102.tar.gz" target="_blank" rel="external">Sogou语料库</a>精简版</li>
<li><a href="https://github.com/blueshen/ik-analyzer" target="_blank" rel="external">ik-analyzer</a>, 这个版本是专门为了在mahout中进行分词而单独做的版本，源码从官方拿来。只更改了停用词，以及适配lucene4.6.1版本。maven化更方便使用。</li>
</ul>
<h3 id="Sogou语料库处理"><a href="#Sogou语料库处理" class="headerlink" title="Sogou语料库处理"></a>Sogou语料库处理</h3><p>下载后的预料库，文档都是GB2312编码的。虽然mahout支持不同的编码方式，但是为了更方便的放到Hadoop里跑，还是建议先转化为标准的UTF-8.<br>语料库解压后，是sogou目录。我们执行以下代码进行转化，转换后的在utf/sogou目录下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">find sogou -type d -exec mkdir -p utf/&#123;&#125; \;</div><div class="line">find sogou -type f -exec iconv -f GB2312 -t UTF-8 &#123;&#125; -o utf/&#123;&#125; \;</div></pre></td></tr></table></figure>
<h3 id="使用mahout生成sequence-file"><a href="#使用mahout生成sequence-file" class="headerlink" title="使用mahout生成sequence file"></a>使用mahout生成sequence file</h3><p>进入utf/sogou目录，执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mahout seqdirectory -i sogou -o sogou-seq -c UTF-8 -ow</div></pre></td></tr></table></figure>
<p>生成的sequence file存放在sogou-seq目录内。<br>可以通过seqdumper命令查看：<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mahout seqdumper -i sogou-seq/part-m-00000 | more</div></pre></td></tr></table></figure></p>
<p><img src="/images/blog/2014/sogou-seqfile.png" alt="搜狗seqfile"></p>
<p>如果是在hadoop上跑，可以这样看。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hadoop fs -text sogou-seq/part-m-00000 | more</div></pre></td></tr></table></figure>
<h3 id="使用seq2sparse生成Vectors"><a href="#使用seq2sparse生成Vectors" class="headerlink" title="使用seq2sparse生成Vectors"></a>使用seq2sparse生成Vectors</h3><p>执行命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mahout seq2sparse -i sogou-seq  -o sogou-vectors -lnorm -nv -wt tfidf -a org.wltea.analyzer.lucene.IKAnalyzer -ow</div></pre></td></tr></table></figure>
<p>查看生成的vector<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mahout vectordump -i sogou-vectors/tfidf-vectors/part-r-00000 | more</div></pre></td></tr></table></figure></p>
<p><img src="/images/blog/2014/sogou-vector.png" alt="搜狗 vector"> </p>
<p>需要注意的是<code>org.wltea.analyzer.lucene.IKAnalyzer</code>，是上面提到的ik-analyzer里的。需要将ik-analyzer打包，然后将打出的包，放入$MAHOUT_HOME/lib内。默认是英文的，使用的是<code>org.apache.lucene.analysis.standard.StandardAnalyzer</code>，空格分割明显不适用中文。</p>
<h3 id="切分训练集和测试集"><a href="#切分训练集和测试集" class="headerlink" title="切分训练集和测试集"></a>切分训练集和测试集</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mahout split -i sogou-vectors/tfidf-vectors/ --trainingOutput sogou-train-vectors --testOutput sogou-test-vectors --randomSelectionPct 40 --overwrite --sequenceFiles -xm sequential</div></pre></td></tr></table></figure>
<h3 id="使用Native-Bayes训练model"><a href="#使用Native-Bayes训练model" class="headerlink" title="使用Native Bayes训练model"></a>使用Native Bayes训练model</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mahout trainnb -i sogou-train-vectors -el -o sogou-model -li sogou-labelindex -ow -c</div></pre></td></tr></table></figure>
<h3 id="使用测试集来查看效果"><a href="#使用测试集来查看效果" class="headerlink" title="使用测试集来查看效果"></a>使用测试集来查看效果</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mahout testnb -i sogou-test-vectors -m sogou-model -l sogou-labelindex -ow -o sogou-testing -c</div></pre></td></tr></table></figure>
<p><img src="/images/blog/2014/sogou-result.png" alt="mahout"></p>
<p>可以看出87%的正确率还是不错的。</p>
<hr>
<p>参考文档：</p>
<p><a href="http://mahout.apache.org/users/classification/twenty-newsgroups.html" target="_blank" rel="external">http://mahout.apache.org/users/classification/twenty-newsgroups.html</a><br><a href="http://www.sogou.com/labs/dl/c.html" target="_blank" rel="external">http://www.sogou.com/labs/dl/c.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;软件版本&quot;&gt;&lt;a href=&quot;#软件版本&quot; class=&quot;headerlink&quot; title=&quot;软件版本&quot;&gt;&lt;/a&gt;软件版本&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Ubuntu Linux&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://mirror.bit.edu.cn/apache/mahout/0.9/mahout-distribution-0.9.tar.gz&quot;&gt;mahout-0.9&lt;/a&gt;,本文写作的时候的最新版本&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://download.labs.sogou.com/dl/sogoulabdown/SogouC.reduced.20061102.tar.gz&quot;&gt;Sogou语料库&lt;/a&gt;精简版&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/blueshen/ik-analyzer&quot;&gt;ik-analyzer&lt;/a&gt;, 这个版本是专门为了在mahout中进行分词而单独做的版本，源码从官方拿来。只更改了停用词，以及适配lucene4.6.1版本。maven化更方便使用。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;Sogou语料库处理&quot;&gt;&lt;a href=&quot;#Sogou语料库处理&quot; class=&quot;headerlink&quot; title=&quot;Sogou语料库处理&quot;&gt;&lt;/a&gt;Sogou语料库处理&lt;/h3&gt;&lt;p&gt;下载后的预料库，文档都是GB2312编码的。虽然mahout支持不同的编码方式，但是为了更方便的放到Hadoop里跑，还是建议先转化为标准的UTF-8.&lt;br&gt;语料库解压后，是sogou目录。我们执行以下代码进行转化，转换后的在utf/sogou目录下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;find sogou -type d -exec mkdir -p utf/&amp;#123;&amp;#125; \;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;find sogou -type f -exec iconv -f GB2312 -t UTF-8 &amp;#123;&amp;#125; -o utf/&amp;#123;&amp;#125; \;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;使用mahout生成sequence-file&quot;&gt;&lt;a href=&quot;#使用mahout生成sequence-file&quot; class=&quot;headerlink&quot; title=&quot;使用mahout生成sequence file&quot;&gt;&lt;/a&gt;使用mahout生成sequence file&lt;/h3&gt;&lt;p&gt;进入utf/sogou目录，执行：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;mahout seqdirectory -i sogou -o sogou-seq -c UTF-8 -ow&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;生成的sequence file存放在sogou-seq目录内。&lt;br&gt;可以通过seqdumper命令查看：&lt;br&gt;
    
    </summary>
    
      <category term="mahout" scheme="https://www.shenyanchao.cn/categories/mahout/"/>
    
    
      <category term="mahout" scheme="https://www.shenyanchao.cn/tags/mahout/"/>
    
      <category term="sogou" scheme="https://www.shenyanchao.cn/tags/sogou/"/>
    
      <category term="ik-analyzer" scheme="https://www.shenyanchao.cn/tags/ik-analyzer/"/>
    
      <category term="ubuntu" scheme="https://www.shenyanchao.cn/tags/ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>Linux中文件编码转换</title>
    <link href="https://www.shenyanchao.cn/blog/2014/11/13/encode-convert-in-linux/"/>
    <id>https://www.shenyanchao.cn/blog/2014/11/13/encode-convert-in-linux/</id>
    <published>2014-11-13T08:20:00.000Z</published>
    <updated>2018-12-24T06:39:00.719Z</updated>
    
    <content type="html"><![CDATA[<p>　在工作中，经常会遇到使用操作系统不一样的环境，从而导致在不同环境下的文件编辑的编码是不一样的，Windows默认是GBK编码格式，Linux默认是UTF-8的格式，这样就会出现把GBK编码的文件拷贝到Linux下出现乱码情况，很是让人头疼，下面给大家介绍下GBK-&gt;UTF-8文件编码批量转换。</p>
<p>Linux命令-enca 查看文件的编码</p>
<p>Enca语法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Usage:  enca [-L LANGUAGE] [OPTION]... [FILE]...</div><div class="line">        enconv [-L LANGUAGE] [OPTION]... [FILE]...</div><div class="line">        Detect encoding of text files and convert them if required.</div></pre></td></tr></table></figure>
<p>Enca用法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ enca -L zh_CN file 检查文件的编码</div><div class="line">$ enca -L zh_CN -x UTF-8 file 将文件编码转换为&quot;UTF-8&quot;编码</div><div class="line">$ enca -L zh_CN -x UTF-8 file1 file2 如果不想覆盖原文件可以这样</div></pre></td></tr></table></figure>
<p>除了有检查文件编码的功能以外，”enca”还有一个好处就是如果文件本来就是你要转换的那种编码，它不会报错，还是会print出结果来， 而”iconv”则会报错。这对于脚本编写是比较方便的事情。<br><a id="more"></a><br>转换单个文件的编码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ enca -L none -x utf-8  index.html</div></pre></td></tr></table></figure>
<p>转换多个文件的编码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ enca -x utf-8 *</div></pre></td></tr></table></figure>
<p>Linux文件名编码批量转换–convmv</p>
<p>Convmv语法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ convmv -f 源编码 -t 新编码 [选项] 文件名</div></pre></td></tr></table></figure>
<p>Convmv 常用参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">-r 递归处理子文件夹</div><div class="line">–notest 真正进行操作，请注意在默认情况下是不对文件进行真实操作的，而只是试验。</div><div class="line">–list 显示所有支持的编码</div><div class="line">–unescap 可以做一下转义，比如把%20变成空格</div></pre></td></tr></table></figure>
<p>示例</p>
<p>转换一个文件由GBK转换成UTF-8</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">convmv -f GBK -t UTF-8 --notest utf8 filename</div></pre></td></tr></table></figure>
<p>GBK-&gt;UTF-8文件编码批量转换脚本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ find default -type f -exec convmv -f GBK -t UTF-8 --notest utf8 &#123;&#125; -o utf/&#123;&#125; \;</div></pre></td></tr></table></figure>
<p>使用iconv 转换</p>
<p>Iconv语法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">iconv -f encoding -t encoding inputfile</div></pre></td></tr></table></figure>
<p>示例</p>
<p>单个文件转换</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ iconv -f GBK -t UTF-8 file1 -o file2</div></pre></td></tr></table></figure>
<p>批量转换</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ find default -type d -exec mkdir -p utf/&#123;&#125; \;</div><div class="line">$ find default -type f -exec iconv -f GBK -t UTF-8 &#123;&#125; -o utf/&#123;&#125; \;</div></pre></td></tr></table></figure>
<p>这两行命令将default目录下的文件由GBK编码转换为UTF-8编码，目录结构不变，转码后的文件保存在utf/default目录下。</p>
<hr>
<p>原文:<a href="http://blog.csdn.net/a280606790/article/details/8504133" target="_blank" rel="external">http://blog.csdn.net/a280606790/article/details/8504133</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　在工作中，经常会遇到使用操作系统不一样的环境，从而导致在不同环境下的文件编辑的编码是不一样的，Windows默认是GBK编码格式，Linux默认是UTF-8的格式，这样就会出现把GBK编码的文件拷贝到Linux下出现乱码情况，很是让人头疼，下面给大家介绍下GBK-&amp;gt;UTF-8文件编码批量转换。&lt;/p&gt;
&lt;p&gt;Linux命令-enca 查看文件的编码&lt;/p&gt;
&lt;p&gt;Enca语法&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;Usage:  enca [-L LANGUAGE] [OPTION]... [FILE]...&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        enconv [-L LANGUAGE] [OPTION]... [FILE]...&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        Detect encoding of text files and convert them if required.&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Enca用法&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;$ enca -L zh_CN file 检查文件的编码&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;$ enca -L zh_CN -x UTF-8 file 将文件编码转换为&amp;quot;UTF-8&amp;quot;编码&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;$ enca -L zh_CN -x UTF-8 file1 file2 如果不想覆盖原文件可以这样&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;除了有检查文件编码的功能以外，”enca”还有一个好处就是如果文件本来就是你要转换的那种编码，它不会报错，还是会print出结果来， 而”iconv”则会报错。这对于脚本编写是比较方便的事情。&lt;br&gt;
    
    </summary>
    
      <category term="linux" scheme="https://www.shenyanchao.cn/categories/linux/"/>
    
    
      <category term="enca" scheme="https://www.shenyanchao.cn/tags/enca/"/>
    
      <category term="iconv" scheme="https://www.shenyanchao.cn/tags/iconv/"/>
    
      <category term="convmv" scheme="https://www.shenyanchao.cn/tags/convmv/"/>
    
      <category term="编码" scheme="https://www.shenyanchao.cn/tags/%E7%BC%96%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Hadoop1.2.1安装部署</title>
    <link href="https://www.shenyanchao.cn/blog/2014/11/13/install-hadoop/"/>
    <id>https://www.shenyanchao.cn/blog/2014/11/13/install-hadoop/</id>
    <published>2014-11-13T05:24:00.000Z</published>
    <updated>2018-12-24T06:45:51.644Z</updated>
    
    <content type="html"><![CDATA[<h3 id="安装需求"><a href="#安装需求" class="headerlink" title="安装需求"></a>安装需求</h3><ul>
<li>Java 1.6</li>
<li>ssh,sshd正常安装</li>
</ul>
<p>确保可以ssh到localhost，并且不需要密码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh localhost</div></pre></td></tr></table></figure>
<p> 如果报错，connect to host localhost port 22:Connection refused。说明ssh-server未安装或者未启动。<br> 运行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ps -ef | grep sshd</div></pre></td></tr></table></figure>
<p>查看sshd进程是否存在，如果不存在，说明没有安装。那么进行安装。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install openssh-server</div></pre></td></tr></table></figure>
<p>然后再执行<code>ssh localhost</code>,如果不能无密码登陆，需要做一下操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ssh-keygen -t dsa -P &apos;&apos; -f ~/.ssh/id_dsa</div><div class="line">cat ~/.ssh/id_dsa.pub &gt;&gt; ~/.ssh/authorized_keys</div></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="相关软件"><a href="#相关软件" class="headerlink" title="相关软件"></a>相关软件</h3><p>Ubuntu Linux为例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install ssh</div><div class="line">sudo apt-get install rsync</div></pre></td></tr></table></figure>
<h3 id="Hadoop下载"><a href="#Hadoop下载" class="headerlink" title="Hadoop下载"></a>Hadoop下载</h3><p>从<a href="http://hadoop.apache.org/releases.html" target="_blank" rel="external">Hadoop官网</a>下载一个稳定版，这里就是1.2.1版本啦。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">wget http://mirror.bit.edu.cn/apache/hadoop/common/hadoop-1.2.1/hadoop-1.2.1.tar.gz</div></pre></td></tr></table></figure>
<h3 id="启动Hadoop"><a href="#启动Hadoop" class="headerlink" title="启动Hadoop"></a>启动Hadoop</h3><p> 1.解压<code>tar -xzvf hadoop-1.2.1.tar.gz</code>，进入conf/hadoop-env.sh，设置JAVA_HOME为你的JDK目录。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">export JAVA_HOME=/path/to/java/home</div></pre></td></tr></table></figure>
<p> 2.进入/hadoop-1.2.1目录，运行<code>bin\hadoop</code>,会显示hadoop的使用说明信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">  Usage: hadoop [--config confdir] COMMAND</div><div class="line">  where COMMAND is one of:</div><div class="line">  namenode -format     format the DFS filesystem</div><div class="line">  secondarynamenode    run the DFS secondary namenode</div><div class="line">  namenode             run the DFS namenode</div><div class="line">  datanode             run a DFS datanode</div><div class="line">  dfsadmin             run a DFS admin client</div><div class="line">  mradmin              run a Map-Reduce admin client</div><div class="line">  fsck                 run a DFS filesystem checking utility</div><div class="line">  fs                   run a generic filesystem user client</div><div class="line">  balancer             run a cluster balancing utility</div><div class="line">  oiv                  apply the offline fsimage viewer to an fsimage</div><div class="line">  fetchdt              fetch a delegation token from the NameNode</div><div class="line">  jobtracker           run the MapReduce job Tracker node</div><div class="line">  pipes                run a Pipes job</div><div class="line">  tasktracker          run a MapReduce task Tracker node</div><div class="line">  historyserver        run job history servers as a standalone daemon</div><div class="line">  job                  manipulate MapReduce jobs</div><div class="line">  queue                get information regarding JobQueues</div><div class="line">  version              print the version</div><div class="line">  jar &lt;jar&gt;            run a jar file</div><div class="line">  distcp &lt;srcurl&gt; &lt;desturl&gt; copy file or directories recursively</div><div class="line">  distcp2 &lt;srcurl&gt; &lt;desturl&gt; DistCp version 2</div><div class="line">  archive -archiveName NAME -p &lt;parent path&gt; &lt;src&gt;* &lt;dest&gt; create a hadoop archive</div><div class="line">  classpath            prints the class path needed to get the</div><div class="line">                       Hadoop jar and the required libraries</div><div class="line">  daemonlog            get/set the log level for each daemon</div><div class="line"> or</div><div class="line">  CLASSNAME            run the class named CLASSNAME</div><div class="line">Most commands print help when invoked w/o parameters.</div></pre></td></tr></table></figure>
<p>  你可以下3中模式来启动hadoop：</p>
<ul>
<li>本地(standalone)模式</li>
<li>伪分布(Pseudo-Distributed)式</li>
<li>全分布(Full-Distributed)式</li>
</ul>
<h4 id="本地-Standalone-模式安装"><a href="#本地-Standalone-模式安装" class="headerlink" title="本地(Standalone)模式安装"></a>本地(Standalone)模式安装</h4><p>  默认情况下，Hadoop就是单机本地模式。方便调试。<br>  下面是一个样例，复制conf目录到input作为输入，找出符合正则的文件，输出到output目录</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ mkdir input</div><div class="line">$ cp conf/*.xml input</div><div class="line">$ bin/hadoop jar hadoop-examples-*.jar grep input output &apos;dfs[a-z.]+&apos;</div><div class="line">$ cat output/*</div></pre></td></tr></table></figure>
<h4 id="伪分布-Pseudo-Distributed-式"><a href="#伪分布-Pseudo-Distributed-式" class="headerlink" title="伪分布(Pseudo-Distributed)式"></a>伪分布(Pseudo-Distributed)式</h4><p>配置conf/core-site.xml</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">property</span>&gt;</span></div><div class="line">         <span class="tag">&lt;<span class="name">name</span>&gt;</span>fs.default.name<span class="tag">&lt;/<span class="name">name</span>&gt;</span></div><div class="line">         <span class="tag">&lt;<span class="name">value</span>&gt;</span>hdfs://localhost:9000<span class="tag">&lt;/<span class="name">value</span>&gt;</span></div><div class="line">     <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></div></pre></td></tr></table></figure>
<p>配置conf/hdfs-site.xml</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">property</span>&gt;</span></div><div class="line">         <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.replication<span class="tag">&lt;/<span class="name">name</span>&gt;</span></div><div class="line">         <span class="tag">&lt;<span class="name">value</span>&gt;</span>1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></div><div class="line">     <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></div></pre></td></tr></table></figure>
<p>配置conf/mapred-site.xml:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">property</span>&gt;</span></div><div class="line">         <span class="tag">&lt;<span class="name">name</span>&gt;</span>mapred.job.tracker<span class="tag">&lt;/<span class="name">name</span>&gt;</span></div><div class="line">         <span class="tag">&lt;<span class="name">value</span>&gt;</span>localhost:9001<span class="tag">&lt;/<span class="name">value</span>&gt;</span></div><div class="line">     <span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></div></pre></td></tr></table></figure>
<p>  格式化一个新的distributed-filesystem</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bin/hadoop namenode -format</div></pre></td></tr></table></figure>
<p> 启动hadoop：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bin/start-all.sh</div></pre></td></tr></table></figure>
<p>  此时可以通过WEB UI控制台来监控NameNode，JobTracker，TaskTracker</p>
<ul>
<li>NameNode - <a href="http://localhost:50070/dfshealth.jsp/" target="_blank" rel="external">http://localhost:50070/dfshealth.jsp/</a></li>
<li>JobTracker - <a href="http://localhost:50030/jobtracker.jsp/" target="_blank" rel="external">http://localhost:50030/jobtracker.jsp/</a></li>
<li><p>TaskTracker - <a href="http://localhost:50060/tasktracker.jsp" target="_blank" rel="external">http://localhost:50060/tasktracker.jsp</a></p>
<p>下面使用distributed filesystem来跑样例:<br>拷贝conf目录到hadoop的input目录，此时可以在控制台看到创建了目录。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ bin/hadoop fs -put conf input</div></pre></td></tr></table></figure>
<p>运行:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ bin/hadoop jar hadoop-examples-*.jar grep input output &apos;dfs[a-z.]+&apos;</div></pre></td></tr></table></figure></p>
<p>检查结果：</p>
<p>拷贝output目录到本地并检查:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ bin/hadoop fs -get output output</div><div class="line">$ cat output/*</div></pre></td></tr></table></figure></p>
<p>或者直接在distributed filesystem查看:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ bin/hadoop fs -cat output/*</div></pre></td></tr></table></figure>
<p>使用完，可以这样来关闭：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ bin/stop-all.sh</div></pre></td></tr></table></figure>
<h4 id="Hadoop分布式部署"><a href="#Hadoop分布式部署" class="headerlink" title="Hadoop分布式部署"></a>Hadoop分布式部署</h4><p> 详见<a href="http://hadoop.apache.org/docs/r1.2.1/cluster_setup.html" target="_blank" rel="external">http://hadoop.apache.org/docs/r1.2.1/cluster_setup.html</a></p>
<hr>
<p>参考文档：<a href="http://hadoop.apache.org/docs/r1.2.1/single_node_setup.html" target="_blank" rel="external">http://hadoop.apache.org/docs/r1.2.1/single_node_setup.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;安装需求&quot;&gt;&lt;a href=&quot;#安装需求&quot; class=&quot;headerlink&quot; title=&quot;安装需求&quot;&gt;&lt;/a&gt;安装需求&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Java 1.6&lt;/li&gt;
&lt;li&gt;ssh,sshd正常安装&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;确保可以ssh到localhost，并且不需要密码&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;ssh localhost&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt; 如果报错，connect to host localhost port 22:Connection refused。说明ssh-server未安装或者未启动。&lt;br&gt; 运行：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;ps -ef | grep sshd&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;查看sshd进程是否存在，如果不存在，说明没有安装。那么进行安装。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;sudo apt-get install openssh-server&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;然后再执行&lt;code&gt;ssh localhost&lt;/code&gt;,如果不能无密码登陆，需要做一下操作：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;ssh-keygen -t dsa -P &amp;apos;&amp;apos; -f ~/.ssh/id_dsa&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;cat ~/.ssh/id_dsa.pub &amp;gt;&amp;gt; ~/.ssh/authorized_keys&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="hadoop" scheme="https://www.shenyanchao.cn/categories/hadoop/"/>
    
    
      <category term="hadoop" scheme="https://www.shenyanchao.cn/tags/hadoop/"/>
    
      <category term="linux" scheme="https://www.shenyanchao.cn/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>oryx介绍</title>
    <link href="https://www.shenyanchao.cn/blog/2014/11/11/introduce-oryx/"/>
    <id>https://www.shenyanchao.cn/blog/2014/11/11/introduce-oryx/</id>
    <published>2014-11-11T11:31:00.000Z</published>
    <updated>2018-10-23T08:41:02.826Z</updated>
    
    <content type="html"><![CDATA[<p>Hadoop软件供应商Cloudera去年收购了一家总部位于伦敦的新兴企业<a href="https://github.com/myrrix/myrrix-recommender]" target="_blank" rel="external">Myrrix</a>——但在此之后无论是买家还是卖家在机器学习技术方面都开始归于沉寂。不过无论如何，Myrrix公司的技术方案加上其创始人Sean Owen可能已经足以值回票价。</p>
<p>　　Owen目前的正式头衔为数据科学部门主管，目前他正专注投身于名为<a href="https://github.com/cloudera/oryx" target="_blank" rel="external">Oryx</a>的开源机器学习项目当中。(Oryx意思是剑羚、属于非洲羚羊的一类分支，Cloudera在售的产品中则有一款名为Impala——即黑斑羚)。Oryx的开发意图在于帮助Hadoop用户构建机器学习模式并将其加以部署，这样我们就能够以实时方式查询并获取其结果——例如将其作为垃圾邮件过滤器或者推荐引擎的组成部分。在理想状态下，Oryx能够在接纳输入数据流的同时对自身进行更新。</p>
<a id="more"></a>
<p>　　Owen将此称为Hadoop传统探索性分析(即利用数据寻找可资利用的模式)与运营性分析在最佳有效点方面的区别。“一旦弄清了网站运作的既定模式，我可能会希望利用这部分资源实现其它诉求，”他解释道。“……我们应该在Hadoop当中建立一系列规模化模式，同时也对这些模式进行规模化实施。”</p>
<p>　　作为Hadoop当中实现机器学习模式创建的传统途径，<a href="http://mahout.apache.org/" target="_blank" rel="external">Apache Mahout</a>“已经走到了发展道路的尽头，”Owen指出。它还停留在第一代MapReduce所采用的纯批量处理时代，而且要求用户承担起大量工作以保证工作系统能够落实到位。“Myrrix(属于Mahout的重新编写成果)实现了我长久以来对Mahout的种种期望，”他表示，并补充称如果Mahout真的运作良好、那么Cloudera可能根本不会决定收购Myrrix。Oryx项目当中约有九成代码取向Myrrix，当然其中也包含一部分在被Cloudera收购后才添加进去的代码。</p>
<p>　　开放而且简便的推荐引擎</p>
<p>　　比起构建一套体积庞大的机器学习算法库，Owen将精力主要放在了四大要素身上——回归、分类、聚类与协同过滤(又名推荐)。Owen表示最后一项也是目前人气最高的设计特性，而且他也与Cloudera的多位客户展开合作、希望利用Oryx实现推荐系统。事实上，约有80%的Oryx用户都希望借此建立自己的推荐引擎。</p>
<p>　　将Oryx作为创建推荐系统的标准化工具为该项目带来了极高人气。当然，在Netflix、Amazon以及几乎其它任何一个知名网站上，推荐系统都属于标准配置——不过目前标准类型的数量少得惊人，而开源工具的意义就在于弥合这种欠缺。</p>
<p>　　目前的状况还称不上是什么竞赛，但确实已经有多方参与到标准推荐机制的开发工作中来。举例来说，云计算新兴企业Mortar Data目前正在寻求合作伙伴、希望通过十五家企业联手(免费)在多位知名数据科学家的帮助下建立起定制化推荐引擎。该公司的这一项目于去年正式启动，他们计划借此找到足以改进其开源推荐框架的最佳实践方案。而Expect Labs等其它企业虽然没有选择开源道路，但也同样在尝试通过人工智能API实现自动推荐效果。</p>
<p>　　还只是个项目而非产品</p>
<p>　　Owen认为Cloudera的所有客户(基本上都属于Hadoop用户)都希望能够最终获得运营性机器学习方案——而非仅仅满足于推荐引擎——Oryx则很可能成为帮助他们实现愿望的关键性工具。不过他同时强调称，“在某种程度上，Oryx仍然属于实验性项目。”</p>
<p>　　举例来说，目前Owen正将大量时间投入到Apache Spark的代码贡献工作当中，因为他打算通过重新编写Oryx使Spark成为一套足以取代MapReduce的首选处理框架。“从机器学习的角度来看，Spark拥有大量极具吸引力的特性，”他表示。“……我更愿意把自己的主要精力放在这里。”</p>
<p>　　他的决定其实代表了很多技术人员的心声。正如我们之前所说，Spark正在逐步成为下一代大数据应用程序当中的代表性方案，而包括Cloudera以及Hortonworks在内的多家企业正积极将其打造为代表Hadoop未来的重要解决方案。Cloudera公司CEO Tom Reilly将联同其它大数据企业CEO、数据科学家以及CIO共同参加今年三月的结构数据大会，探讨Hadoop平台的下一步发展方向以及Spark在其中扮演的角色、外加足以转变业务及社交模式的机器学习实际应用。</p>
<p>　　不过虽然作出这么多承诺，Owen却并不认为Oryx能在短时间之内在Cloudera的Hadoop改造版或者相关产品当中发挥实际作用。“客户需要指导、服务以及培训，而这些需求将以软件形式予以交付，”他表示。不过就目前来看：“这些距离真正实现还有很长的路要走。”</p>
<p>　　“现在要让庞大的Hadoop消费市场接受数据科学都还为时过早，”他解释道，“更不用说运营性实时机器学习方案了。</p>
<hr>
<p>参考：<br><a href="http://storage.chinabyte.com/134/12873634.shtml" target="_blank" rel="external">http://storage.chinabyte.com/134/12873634.shtml</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Hadoop软件供应商Cloudera去年收购了一家总部位于伦敦的新兴企业&lt;a href=&quot;https://github.com/myrrix/myrrix-recommender]&quot;&gt;Myrrix&lt;/a&gt;——但在此之后无论是买家还是卖家在机器学习技术方面都开始归于沉寂。不过无论如何，Myrrix公司的技术方案加上其创始人Sean Owen可能已经足以值回票价。&lt;/p&gt;
&lt;p&gt;　　Owen目前的正式头衔为数据科学部门主管，目前他正专注投身于名为&lt;a href=&quot;https://github.com/cloudera/oryx&quot;&gt;Oryx&lt;/a&gt;的开源机器学习项目当中。(Oryx意思是剑羚、属于非洲羚羊的一类分支，Cloudera在售的产品中则有一款名为Impala——即黑斑羚)。Oryx的开发意图在于帮助Hadoop用户构建机器学习模式并将其加以部署，这样我们就能够以实时方式查询并获取其结果——例如将其作为垃圾邮件过滤器或者推荐引擎的组成部分。在理想状态下，Oryx能够在接纳输入数据流的同时对自身进行更新。&lt;/p&gt;
    
    </summary>
    
      <category term="oryx" scheme="https://www.shenyanchao.cn/categories/oryx/"/>
    
    
      <category term="cloudera" scheme="https://www.shenyanchao.cn/tags/cloudera/"/>
    
      <category term="oryx" scheme="https://www.shenyanchao.cn/tags/oryx/"/>
    
      <category term="myrrix" scheme="https://www.shenyanchao.cn/tags/myrrix/"/>
    
  </entry>
  
  <entry>
    <title>solr中的tie breaker</title>
    <link href="https://www.shenyanchao.cn/blog/2014/10/22/tie-breaker-in-solr/"/>
    <id>https://www.shenyanchao.cn/blog/2014/10/22/tie-breaker-in-solr/</id>
    <published>2014-10-22T09:14:00.000Z</published>
    <updated>2018-12-24T04:52:53.018Z</updated>
    
    <content type="html"><![CDATA[<p>solr 查询参数中有tie这样的一个参数，下面是它的官方解释：</p>
<p><strong>The tie (Tie Breaker) Parameter</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">The tie parameter specifies a float value (which should be something much less than 1) to use as tiebreaker in DisMax queries.</div><div class="line"></div><div class="line">When a term from the user&apos;s input is tested against multiple fields, more than one field may match. If so, each field will generate a different score based on how common that word is in that field (for each document relative to all other documents). The tie parameter lets you control how much the final score of the query will be influenced by the scores of the lower scoring fields compared to the highest scoring field.</div><div class="line"></div><div class="line">A value of &quot;0.0&quot; makes the query a pure &quot;disjunction max query&quot;: that is, only the maximum scoring subquery contributes to the final score. A value of &quot;1.0&quot; makes the query a pure &quot;disjunction sum query&quot; where it doesn&apos;t matter what the maximum scoring sub query is, because the final score will be the sum of the subquery scores. Typically a low value, such as 0.1, is useful.</div></pre></td></tr></table></figure>
<p>读起来比较令人费解。</p>
<p>简单解释就是：</p>
<p>这个tie参数通常是一个小于1的浮点数，用于defType=disMax的solr查询。当查询命中多个field的时候，最终的score获得多少将由这个tie参数来进行调节。比如命中了field1，field2这2个field。</p>
<p>如果field1.score= 10，field2.score=3。那么 score = 10 + tie * 3.</p>
<p>也就是说，如果tie=1的话，最终的score就相当于多个字段得分总和;如果tie=0,那么最终的score就相当于是命中的field的最高分。</p>
<p>通常情况下呢，官方推荐tie=0.1。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;solr 查询参数中有tie这样的一个参数，下面是它的官方解释：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;The tie (Tie Breaker) Parameter&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;
    
    </summary>
    
      <category term="solr" scheme="https://www.shenyanchao.cn/categories/solr/"/>
    
    
      <category term="solr" scheme="https://www.shenyanchao.cn/tags/solr/"/>
    
      <category term="lucene" scheme="https://www.shenyanchao.cn/tags/lucene/"/>
    
      <category term="tie" scheme="https://www.shenyanchao.cn/tags/tie/"/>
    
  </entry>
  
  <entry>
    <title>Java新特性</title>
    <link href="https://www.shenyanchao.cn/blog/2014/08/27/java-new-feature/"/>
    <id>https://www.shenyanchao.cn/blog/2014/08/27/java-new-feature/</id>
    <published>2014-08-27T06:43:00.000Z</published>
    <updated>2018-12-24T06:47:16.435Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java7新特性"><a href="#Java7新特性" class="headerlink" title="Java7新特性"></a>Java7新特性</h2><h3 id="Java7语法特性"><a href="#Java7语法特性" class="headerlink" title="Java7语法特性"></a>Java7语法特性</h3><p>根据JSR 334，Java7添加了数个语法方面的新特性：</p>
<h4 id="1-switch可以消化String"><a href="#1-switch可以消化String" class="headerlink" title="1. switch可以消化String"></a>1. switch可以消化String</h4><p>比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">switchString</span><span class="params">(String s)</span></span>&#123;</div><div class="line">    <span class="keyword">switch</span> (s)&#123;</div><div class="line">    <span class="keyword">case</span> <span class="string">"db"</span>: ...</div><div class="line">    <span class="keyword">case</span> <span class="string">"wls"</span>: ...</div><div class="line">    <span class="keyword">case</span> <span class="string">"ibm"</span>: ...</div><div class="line">    <span class="keyword">case</span> <span class="string">"soa"</span>: ...</div><div class="line">    <span class="keyword">case</span> <span class="string">"fa"</span>: ...</div><div class="line">    <span class="keyword">default</span>: ...</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<a id="more"></a>
<h4 id="2-新的整数字面表达方式-“0b”前缀和”-”连数符，提升程序员的幸福感。"><a href="#2-新的整数字面表达方式-“0b”前缀和”-”连数符，提升程序员的幸福感。" class="headerlink" title="2. 新的整数字面表达方式 - “0b”前缀和”_”连数符，提升程序员的幸福感。"></a>2. 新的整数字面表达方式 - “0b”前缀和”_”连数符，提升程序员的幸福感。</h4><ul>
<li><p>a. 表示二进制字面值的前缀, 0b:<br> 比如以下三个变量的值相同：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">byte</span> b1 = <span class="number">0b00100001</span>;     <span class="comment">// New</span></div><div class="line"><span class="keyword">byte</span> b2 = <span class="number">0x21</span>;        <span class="comment">// Old</span></div><div class="line"><span class="keyword">byte</span> b3 = <span class="number">33</span>;        <span class="comment">// Old</span></div></pre></td></tr></table></figure>
</li>
<li><p>b. 用下划线连接整数提升其可读性，自身无含义，不可用在数字的起始和末尾：</p>
   <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">long</span> phone_nbr = <span class="number">021_1111_2222</span>;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="3-简化了泛型对象创建的语法-“菱形-new”，以下两个语句等价："><a href="#3-简化了泛型对象创建的语法-“菱形-new”，以下两个语句等价：" class="headerlink" title="3. 简化了泛型对象创建的语法 - “菱形 new”，以下两个语句等价："></a>3. 简化了泛型对象创建的语法 - “菱形 new”，以下两个语句等价：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ArrayList&lt;String&gt; al1 = <span class="keyword">new</span> ArrayList&lt;String&gt;();    <span class="comment">// Old</span></div><div class="line">ArrayList&lt;String&gt; al2 = <span class="keyword">new</span> ArrayList&lt;&gt;();        <span class="comment">// New</span></div></pre></td></tr></table></figure>
<h4 id="4-为所有的reflect操作异常找了个新爸爸-ReflectOperationException，孩儿们是："><a href="#4-为所有的reflect操作异常找了个新爸爸-ReflectOperationException，孩儿们是：" class="headerlink" title="4. 为所有的reflect操作异常找了个新爸爸 - ReflectOperationException，孩儿们是："></a>4. 为所有的reflect操作异常找了个新爸爸 - ReflectOperationException，孩儿们是：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ClassNotFoundException,</div><div class="line">IllegalAccessException,</div><div class="line">InstantiationException,</div><div class="line">InvocationTargetException,</div><div class="line">NoSuchFieldException,</div><div class="line">NoSuchMethodException</div></pre></td></tr></table></figure>
<h4 id="5-catch有了多重捕获功能，也玩起了包养的勾当，以下代码心领神会："><a href="#5-catch有了多重捕获功能，也玩起了包养的勾当，以下代码心领神会：" class="headerlink" title="5. catch有了多重捕获功能，也玩起了包养的勾当，以下代码心领神会："></a>5. catch有了多重捕获功能，也玩起了包养的勾当，以下代码心领神会：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span>&#123;</div><div class="line">    <span class="comment">// code</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">catch</span> (SQLException | IOException ex) &#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="6-异常精确重抛-重抛时自动造型为子类，有点半主动制导武器的style："><a href="#6-异常精确重抛-重抛时自动造型为子类，有点半主动制导武器的style：" class="headerlink" title="6. 异常精确重抛 - 重抛时自动造型为子类，有点半主动制导武器的style："></a>6. 异常精确重抛 - 重抛时自动造型为子类，有点半主动制导武器的style：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchMethodException, NoSuchFieldException</span>&#123;    <span class="comment">// 子类</span></div><div class="line">    <span class="keyword">try</span>&#123;</div><div class="line">        <span class="comment">// code</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">catch</span> (RelectiveOperationException ex)&#123;    <span class="comment">// 父类</span></div><div class="line">        <span class="keyword">throws</span> ex;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="7-发明了try-结构-Try-with-Resources，能够自动接住异常并关闭资源-所谓的资源需要利用新的java-lang-AutoCloseable接口-，注意以下代码中try后面跟的是”-“不是”-“："><a href="#7-发明了try-结构-Try-with-Resources，能够自动接住异常并关闭资源-所谓的资源需要利用新的java-lang-AutoCloseable接口-，注意以下代码中try后面跟的是”-“不是”-“：" class="headerlink" title="7. 发明了try()结构 - Try with Resources，能够自动接住异常并关闭资源(所谓的资源需要利用新的java.lang.AutoCloseable接口)，注意以下代码中try后面跟的是”(“不是”{“："></a>7. 发明了try()结构 - Try with Resources，能够自动接住异常并关闭资源(所谓的资源需要利用新的java.lang.AutoCloseable接口)，注意以下代码中try后面跟的是”(“不是”{“：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span>(BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">"/home/oracle/temp.txt"</span>)))&#123;</div><div class="line">    ... br.readLine() ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>try-with-resources语句可以带catch，也可以向上例一样一个catch也没有。</p>
<h3 id="Java7-NIO-新方法"><a href="#Java7-NIO-新方法" class="headerlink" title="Java7 NIO 新方法"></a>Java7 NIO 新方法</h3><p>整体来说，对IO操作进行了优化，使用起来更加顺手，甚至可以替换apache common-io包。</p>
<h4 id="1-增加java-nio-file-Paths用于目录操作"><a href="#1-增加java-nio-file-Paths用于目录操作" class="headerlink" title="1.增加java.nio.file.Paths用于目录操作"></a>1.增加<code>java.nio.file.Paths</code>用于目录操作</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Path path = Paths.get(<span class="string">"/home/shenyanchao"</span>, <span class="string">"Desktop"</span>);</div><div class="line">   System.out.println(path.toAbsolutePath());</div><div class="line">   System.out.println(path.getParent());</div><div class="line">   System.out.println(path.getFileSystem().isOpen());</div></pre></td></tr></table></figure>
<h4 id="2-增加java-nio-file-Files工具类来处理文件"><a href="#2-增加java-nio-file-Files工具类来处理文件" class="headerlink" title="2.增加java.nio.file.Files工具类来处理文件"></a>2.增加<code>java.nio.file.Files</code>工具类来处理文件</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Files.copy(src,dest, StandardCopyOption.COPY_ATTRIBUTES,StandardCopyOption.REPLACE_EXISTING);</div><div class="line"></div><div class="line">Files.move(src,dest,StandardCopyOption.ATOMIC_MOVE);</div><div class="line"></div><div class="line">Files.createLink(src,dest);</div><div class="line">Files.createSymbolicLink(src,dest);</div><div class="line">Files.deleteIfExists(dest);</div><div class="line"></div><div class="line">Files.readAllLines(src);</div><div class="line"></div><div class="line">Files.createTempFile(src,<span class="string">"aa"</span>,<span class="string">"bb"</span>);</div></pre></td></tr></table></figure>
<h4 id="3-目录树遍历"><a href="#3-目录树遍历" class="headerlink" title="3.目录树遍历"></a>3.目录树遍历</h4><p>使用<code>FileVisitor</code>来实现访问者模式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">preVisitDirectory(T dir, BasicFileAttributes attrs);</div><div class="line">visitFile(T dir, BasicFileAttributes attrs);</div><div class="line">visitFileFailed(T dir, IOException exc);</div><div class="line">postVisitDirectory(T dir, IOException exc);</div></pre></td></tr></table></figure>
<h4 id="4-使用WatchService来监控目录，变化请通知"><a href="#4-使用WatchService来监控目录，变化请通知" class="headerlink" title="4.使用WatchService来监控目录，变化请通知"></a>4.使用WatchService来监控目录，变化请通知</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">WatchService watchService = FileSystems.getDefault().newWatchService();</div><div class="line">Path path = Paths.get(<span class="string">"/home/shenyanchao/Documents"</span>);</div><div class="line">WatchKey watchKey = path.register(watchService, StandardWatchEventKinds.ENTRY_CREATE,</div><div class="line">        StandardWatchEventKinds.ENTRY_DELETE, StandardWatchEventKinds.ENTRY_MODIFY);</div><div class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">    List&lt;WatchEvent&lt;?&gt;&gt; watchEvents = watchService.take().pollEvents();</div><div class="line">    <span class="keyword">for</span> (WatchEvent&lt;?&gt; watchEvent : watchEvents) &#123;</div><div class="line">        System.out.printf(<span class="string">"[%s]文件发生了[%s]事件。%n"</span>, watchEvent.context(), watchEvent.kind());</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">boolean</span> valid = watchKey.reset();</div><div class="line">    <span class="keyword">if</span> (!valid)&#123;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Java7并发（JSR166Y）"><a href="#Java7并发（JSR166Y）" class="headerlink" title="Java7并发（JSR166Y）"></a>Java7并发（JSR166Y）</h3><h4 id="Fork-Join框架，大任务分解为小任务"><a href="#Fork-Join框架，大任务分解为小任务" class="headerlink" title="Fork Join框架，大任务分解为小任务"></a>Fork Join框架，大任务分解为小任务</h4><p>通过ForkJoinPool，ForkJoinTask来实现的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Fibonacci</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> n;</div><div class="line"></div><div class="line">    Fibonacci(<span class="keyword">int</span> n) &#123;</div><div class="line">        <span class="keyword">this</span>.n = n;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> Integer <span class="title">compute</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>)</div><div class="line">            <span class="keyword">return</span> n;</div><div class="line">        Fibonacci f1 = <span class="keyword">new</span> Fibonacci(n - <span class="number">1</span>);</div><div class="line">        f1.fork();</div><div class="line">        Fibonacci f2 = <span class="keyword">new</span> Fibonacci(n - <span class="number">2</span>);</div><div class="line">        f2.fork();</div><div class="line">        <span class="keyword">return</span> f1.join() + f2.join();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Fibonacci fibonacci = <span class="keyword">new</span> Fibonacci(<span class="number">4</span>);</div><div class="line">        System.out.println(fibonacci.compute());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="TransferQueue，ConcurrentLinkedDeque等新类"><a href="#TransferQueue，ConcurrentLinkedDeque等新类" class="headerlink" title="TransferQueue，ConcurrentLinkedDeque等新类"></a>TransferQueue，ConcurrentLinkedDeque等新类</h4><p>TransferQueue是一个继承了 BlockingQueue的接口，并且增加若干新的方法。</p>
<h4 id="ThreadLocalRandom用于生成随机数"><a href="#ThreadLocalRandom用于生成随机数" class="headerlink" title="ThreadLocalRandom用于生成随机数"></a>ThreadLocalRandom用于生成随机数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ThreadLocalRandom.current().nextInt (...)</div></pre></td></tr></table></figure>
<p>Random是线程安全的，但速度较慢。而这个是快速的，但是速度很快。适用于线程内部的使用。</p>
<h3 id="Java7-client"><a href="#Java7-client" class="headerlink" title="Java7 client"></a>Java7 client</h3><p>诸如更新了很多swing显示相关的api.<br>更好的支持linux fonts</p>
<h3 id="Java7-VM新特性"><a href="#Java7-VM新特性" class="headerlink" title="Java7 VM新特性"></a>Java7 VM新特性</h3><h4 id="1-引入Garbage-First回收算法"><a href="#1-引入Garbage-First回收算法" class="headerlink" title="1.引入Garbage First回收算法"></a>1.引入Garbage First回收算法</h4><p>Garbage First简称G1，它的目标是要做到尽量减少GC所导致的应用暂停的时间，让应用达到准实时的效果，同时保持JVM堆空间的利用率。用于替代CMS</p>
<hr>
<p>参考文档：<a href="http://www.slideshare.net/boulderjug/55-things-in-java-7" target="_blank" rel="external">http://www.slideshare.net/boulderjug/55-things-in-java-7</a></p>
<h2 id="Java8新特性"><a href="#Java8新特性" class="headerlink" title="Java8新特性"></a>Java8新特性</h2><h3 id="1-接口默认方法-接口允许有实现啦"><a href="#1-接口默认方法-接口允许有实现啦" class="headerlink" title="1.接口默认方法[接口允许有实现啦]"></a>1.接口默认方法[接口允许有实现啦]</h3><p>Java 8允许我们给接口添加一个非抽象的方法实现，只需要使用 <code>default</code>关键字即可，这个特征又叫做扩展方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Formula</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">double</span> <span class="title">calculate</span><span class="params">(<span class="keyword">int</span> a)</span></span>;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">default</span> <span class="keyword">double</span> <span class="title">sqrt</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</div><div class="line">    	<span class="keyword">return</span> Math.sqrt(a);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="2-Lambda表达式"><a href="#2-Lambda表达式" class="headerlink" title="2.Lambda表达式"></a>2.Lambda表达式</h3><p>据说借鉴了各种动态语言的新特性，比如scala，python<br>首先看看在老版本的Java中是如何排列字符串的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt; names = Arrays.asList(<span class="string">"peter"</span>, <span class="string">"anna"</span>, <span class="string">"mike"</span>, <span class="string">"xenia"</span>);</div><div class="line"></div><div class="line">Collections.sort(names, <span class="keyword">new</span> Comparator&lt;String&gt;() &#123;</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String a, String b)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> b.compareTo(a);</div><div class="line">&#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>Java 8 提供了更为简介的语法，lambda表达式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Collections.sort(names, (String a, String b) -&gt; &#123;</div><div class="line">    <span class="keyword">return</span> b.compareTo(a);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>可以更短：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Collections.sort(names, (String a, String b) -&gt; b.compareTo(a));</div></pre></td></tr></table></figure>
<p>再短：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Collections.sort(names, (a, b) -&gt; b.compareTo(a));</div></pre></td></tr></table></figure>
<h3 id="3-FunctionalInterface"><a href="#3-FunctionalInterface" class="headerlink" title="3.@FunctionalInterface"></a>3.@FunctionalInterface</h3><p>这是新引入的一个注解，用于支持lambda。用<code>FunctionalInterface</code>标识的接口，必须只包含1个抽象方法。否则会编译报错的。因为如果有多个抽象方法，lambda就无法知道对应哪个方法了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@FunctionalInterface</span></div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Converter</span>&lt;<span class="title">F</span>, <span class="title">T</span>&gt; </span>&#123;</div><div class="line">    <span class="function">T <span class="title">convert</span><span class="params">(F from)</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Converter&lt;String, Integer&gt; converter = (from) -&gt; Integer.valueOf(from);</div><div class="line">Integer converted = converter.convert(<span class="string">"123"</span>);</div><div class="line">System.out.println(converted);    <span class="comment">// 123</span></div></pre></td></tr></table></figure>
<p>例子中，<code>(from) -&gt; Integer.valueOf(from)</code>这个lambda表达式指出了convert方法的具体实现。</p>
<h4 id="1-方法与构造函数的引用"><a href="#1-方法与构造函数的引用" class="headerlink" title="(1)方法与构造函数的引用::"></a>(1)方法与构造函数的引用::</h4><p>Java 8 允许你使用 :: 关键字来传递方法或者构造函数引用,下面的代码展示了如何引用一个静态方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Converter&lt;String, Integer&gt; converter = Integer::valueOf;</div><div class="line">Integer converted = converter.convert(<span class="string">"123"</span>);</div><div class="line">System.out.println(converted);   <span class="comment">// 123</span></div></pre></td></tr></table></figure>
<p>当然也可以引用一个对象的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">converter = something::startsWith;</div><div class="line">String converted = converter.convert(<span class="string">"Java"</span>);</div><div class="line">System.out.println(converted);    <span class="comment">// "J"</span></div></pre></td></tr></table></figure>
<p>那么如何引用构造函数呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</div><div class="line">    String firstName;</div><div class="line">    String lastName;</div><div class="line"></div><div class="line">    Person() &#123;&#125;</div><div class="line"></div><div class="line">    Person(String firstName, String lastName) &#123;</div><div class="line">        <span class="keyword">this</span>.firstName = firstName;</div><div class="line">        <span class="keyword">this</span>.lastName = lastName;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这是一个pojo类。下面创建一个用于创建person对象的FunctionalInterface：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">PersonFactory</span>&lt;<span class="title">P</span> <span class="keyword">extends</span> <span class="title">Person</span>&gt; </span>&#123;</div><div class="line">    <span class="function">P <span class="title">create</span><span class="params">(String firstName, String lastName)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里我们使用构造函数引用来将他们关联起来，而不是实现一个完整的工厂：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">PersonFactory&lt;Person&gt; personFactory = Person::<span class="keyword">new</span>;</div><div class="line">Person person = personFactory.create(<span class="string">"Peter"</span>, <span class="string">"Parker"</span>);</div></pre></td></tr></table></figure>
<p>我们只需要使用 Person::new 来获取Person类构造函数的引用，Java编译器会自动根据PersonFactory.create方法的签名来选择合适的构造函数。</p>
<h4 id="2-内嵌的Functional-Interfaces"><a href="#2-内嵌的Functional-Interfaces" class="headerlink" title="(2)内嵌的Functional Interfaces"></a>(2)内嵌的Functional Interfaces</h4><p>上面提到的Comparator接口，为什么可以使用lambda表达式，正是因为在java 8中，被定义为了FunctionalInterface。这些已经存在的接口是通过添加@FunctionalInterface注解来支持的。</p>
<p>另外，java 8 api还提供了丰富的接口。这些接口貌似都是从Google Guava包里得到的提示，命名甚至都是一样的。</p>
<ul>
<li>Predicates</li>
</ul>
<p>Predicate 接口只有一个参数，返回boolean类型。该接口包含多种默认方法来将Predicate组合成其他复杂的逻辑（比如：与，或，非）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Predicate&lt;String&gt; predicate = (s) -&gt; s.length() &gt; <span class="number">0</span>;</div><div class="line"></div><div class="line">predicate.test(<span class="string">"foo"</span>);              <span class="comment">// true</span></div><div class="line">predicate.negate().test(<span class="string">"foo"</span>);     <span class="comment">// false</span></div><div class="line"></div><div class="line">Predicate&lt;Boolean&gt; nonNull = Objects::nonNull;</div><div class="line">Predicate&lt;Boolean&gt; isNull = Objects::isNull;</div><div class="line"></div><div class="line">Predicate&lt;String&gt; isEmpty = String::isEmpty;</div><div class="line">Predicate&lt;String&gt; isNotEmpty = isEmpty.negate();</div></pre></td></tr></table></figure>
<ul>
<li>Function</li>
</ul>
<p>Function 接口有一个参数并且返回一个结果，并附带了一些可以和其他函数组合的默认方法（compose, andThen）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Function&lt;String, Integer&gt; toInteger = Integer::valueOf;</div><div class="line">Function&lt;String, String&gt; backToString = toInteger.andThen(String::valueOf);</div><div class="line"></div><div class="line">backToString.apply(<span class="string">"123"</span>);     <span class="comment">// "123"</span></div></pre></td></tr></table></figure>
<ul>
<li>Supplier</li>
</ul>
<p>Supplier 接口返回一个给定类型的泛型，和Function接口不同的是该接口不接受任何参数.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Supplier&lt;Person&gt; personSupplier = Person::<span class="keyword">new</span>;</div><div class="line">personSupplier.get();   <span class="comment">// new Person</span></div></pre></td></tr></table></figure>
<ul>
<li>Consumer</li>
</ul>
<p>Consumer在一个输入参数上做一些操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Consumer&lt;Person&gt; greeter = (p) -&gt; System.out.println(<span class="string">"Hello, "</span> + p.firstName);</div><div class="line">greeter.accept(<span class="keyword">new</span> Person(<span class="string">"Luke"</span>, <span class="string">"Skywalker"</span>));</div></pre></td></tr></table></figure>
<ul>
<li>Comparator</li>
</ul>
<p>Comparator是早就存在的，不过java 8提供了一些默认方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Comparator&lt;Person&gt; comparator = (p1, p2) -&gt; p1.firstName.compareTo(p2.firstName);</div><div class="line"></div><div class="line">Person p1 = <span class="keyword">new</span> Person(<span class="string">"John"</span>, <span class="string">"Doe"</span>);</div><div class="line">Person p2 = <span class="keyword">new</span> Person(<span class="string">"Alice"</span>, <span class="string">"Wonderland"</span>);</div><div class="line"></div><div class="line">comparator.compare(p1, p2);             <span class="comment">// &gt; 0</span></div><div class="line">comparator.reversed().compare(p1, p2);  <span class="comment">// &lt; 0</span></div></pre></td></tr></table></figure>
<ul>
<li>Optional</li>
</ul>
<p>Optional其实并不是一个FunctionInterface，而是一个用来避免<code>NullPointerException</code>的工具。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Optional&lt;String&gt; optional = Optional.of(<span class="string">"bam"</span>);</div><div class="line"></div><div class="line">optional.isPresent();           <span class="comment">// true</span></div><div class="line">optional.get();                 <span class="comment">// "bam"</span></div><div class="line">optional.orElse(<span class="string">"fallback"</span>);    <span class="comment">// "bam"</span></div><div class="line"></div><div class="line">optional.ifPresent((s) -&gt; System.out.println(s.charAt(<span class="number">0</span>)));     <span class="comment">// "b"</span></div></pre></td></tr></table></figure>
<ul>
<li>Stream</li>
</ul>
<p><code>java.util.stream.Stream</code>代表了能在其上做一系列操作的一串元素。在java 8中，Collections被扩展了。我们可以通过<code>Collections.stream()</code>或者<code>Collections.parallelStream()</code>来创建Stream。<br>首先，新建一个数组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt; stringCollection = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">stringCollection.add(<span class="string">"ddd2"</span>);</div><div class="line">stringCollection.add(<span class="string">"aaa2"</span>);</div><div class="line">stringCollection.add(<span class="string">"bbb1"</span>);</div><div class="line">stringCollection.add(<span class="string">"aaa1"</span>);</div><div class="line">stringCollection.add(<span class="string">"bbb3"</span>);</div><div class="line">stringCollection.add(<span class="string">"ccc"</span>);</div><div class="line">stringCollection.add(<span class="string">"bbb2"</span>);</div><div class="line">stringCollection.add(<span class="string">"ddd1"</span>);</div></pre></td></tr></table></figure>
<p>具体使用如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">stringCollection</div><div class="line">    .stream()</div><div class="line">    .sorted()</div><div class="line">    .filter((s) -&gt; s.startsWith(<span class="string">"a"</span>))</div><div class="line">    .forEach(System.out::println);</div><div class="line"></div><div class="line"><span class="comment">// "aaa1", "aaa2"</span></div></pre></td></tr></table></figure>
<p>map()函数可以把每个值转换为另外的值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">stringCollection</div><div class="line">    .stream()</div><div class="line">    .map(String::toUpperCase)</div><div class="line">    .sorted((a, b) -&gt; b.compareTo(a))</div><div class="line">    .forEach(System.out::println);</div><div class="line"></div><div class="line"><span class="comment">// "DDD2", "DDD1", "CCC", "BBB3", "BBB2", "AAA2", "AAA1"</span></div></pre></td></tr></table></figure>
<p>另外提供有各种match方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">boolean</span> anyStartsWithA =</div><div class="line">    stringCollection</div><div class="line">        .stream()</div><div class="line">        .anyMatch((s) -&gt; s.startsWith(<span class="string">"a"</span>));</div><div class="line"></div><div class="line">System.out.println(anyStartsWithA);      <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="keyword">boolean</span> allStartsWithA =</div><div class="line">    stringCollection</div><div class="line">        .stream()</div><div class="line">        .allMatch((s) -&gt; s.startsWith(<span class="string">"a"</span>));</div><div class="line"></div><div class="line">System.out.println(allStartsWithA);      <span class="comment">// false</span></div><div class="line"></div><div class="line"><span class="keyword">boolean</span> noneStartsWithZ =</div><div class="line">    stringCollection</div><div class="line">        .stream()</div><div class="line">        .noneMatch((s) -&gt; s.startsWith(<span class="string">"z"</span>));</div><div class="line"></div><div class="line">System.out.println(noneStartsWithZ);      <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>count()方法返回的是一个值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">long</span> startsWithB =</div><div class="line">    stringCollection</div><div class="line">        .stream()</div><div class="line">        .filter((s) -&gt; s.startsWith(<span class="string">"b"</span>))</div><div class="line">        .count();</div><div class="line"></div><div class="line">System.out.println(startsWithB);    <span class="comment">// 3</span></div></pre></td></tr></table></figure>
<p>reduce则进行了归一化处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Optional&lt;String&gt; reduced =</div><div class="line">    stringCollection</div><div class="line">        .stream()</div><div class="line">        .sorted()</div><div class="line">        .reduce((s1, s2) -&gt; s1 + <span class="string">"#"</span> + s2);</div><div class="line"></div><div class="line">reduced.ifPresent(System.out::println);</div><div class="line"><span class="comment">// "aaa1#aaa2#bbb1#bbb2#bbb3#ccc#ddd1#ddd2"</span></div></pre></td></tr></table></figure>
<ul>
<li>ParallelStream</li>
</ul>
<p>它是一个并行的。速度要比stream快的多。</p>
<ul>
<li>Map</li>
</ul>
<p>Map并不支持Stream，不过Java 8 提供了各种有用的新方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">Map&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">    map.putIfAbsent(i, <span class="string">"val"</span> + i);</div><div class="line">&#125;</div><div class="line"></div><div class="line">map.forEach((id, val) -&gt; System.out.println(val));</div><div class="line"></div><div class="line">map.computeIfPresent(<span class="number">3</span>, (num, val) -&gt; val + num);</div><div class="line">map.get(<span class="number">3</span>);             <span class="comment">// val33</span></div><div class="line"></div><div class="line">map.computeIfPresent(<span class="number">9</span>, (num, val) -&gt; <span class="keyword">null</span>);</div><div class="line">map.containsKey(<span class="number">9</span>);     <span class="comment">// false</span></div><div class="line"></div><div class="line">map.computeIfAbsent(<span class="number">23</span>, num -&gt; <span class="string">"val"</span> + num);</div><div class="line">map.containsKey(<span class="number">23</span>);    <span class="comment">// true</span></div><div class="line"></div><div class="line">map.computeIfAbsent(<span class="number">3</span>, num -&gt; <span class="string">"bam"</span>);</div><div class="line">map.get(<span class="number">3</span>);             <span class="comment">// val33</span></div><div class="line"></div><div class="line">map.remove(<span class="number">3</span>, <span class="string">"val3"</span>);</div><div class="line">map.get(<span class="number">3</span>);             <span class="comment">// val33</span></div><div class="line"></div><div class="line">map.remove(<span class="number">3</span>, <span class="string">"val33"</span>);</div><div class="line">map.get(<span class="number">3</span>);             <span class="comment">// null</span></div><div class="line"></div><div class="line">map.getOrDefault(<span class="number">42</span>, <span class="string">"not found"</span>);  <span class="comment">// not found</span></div><div class="line"></div><div class="line">map.merge(<span class="number">9</span>, <span class="string">"val9"</span>, (value, newValue) -&gt; value.concat(newValue));</div><div class="line">map.get(<span class="number">9</span>);             <span class="comment">// val9</span></div><div class="line"></div><div class="line">map.merge(<span class="number">9</span>, <span class="string">"concat"</span>, (value, newValue) -&gt; value.concat(newValue));</div><div class="line">map.get(<span class="number">9</span>);             <span class="comment">// val9concat</span></div></pre></td></tr></table></figure>
<h3 id="4-时间API"><a href="#4-时间API" class="headerlink" title="4.时间API"></a>4.时间API</h3><p>Java8更新了Date API,这个新的api与joda-time类似。</p>
<h4 id="1-Clock"><a href="#1-Clock" class="headerlink" title="(1)Clock"></a>(1)Clock</h4><p>Clock类提供了访问当前日期和时间的方法，Clock是时区敏感的，可以用来取代 System.currentTimeMillis() 来获取当前的微秒数。某一个特定的时间点也可以使用Instant类来表示，Instant类也可以用来创建老的java.util.Date对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Clock clock = Clock.systemDefaultZone();</div><div class="line"><span class="keyword">long</span> millis = clock.millis();</div><div class="line"></div><div class="line">Instant instant = clock.instant();</div><div class="line">Date legacyDate = Date.from(instant);   <span class="comment">// legacy java.util.Date</span></div></pre></td></tr></table></figure>
<h4 id="2-TimeZones"><a href="#2-TimeZones" class="headerlink" title="(2)TimeZones"></a>(2)TimeZones</h4><p>在新API中时区使用ZoneId来表示。时区可以很方便的使用静态方法of来获取到。 时区定义了到UTS时间的时间差，在Instant时间点对象到本地日期对象之间转换的时候是极其重要的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">System.out.println(ZoneId.getAvailableZoneIds());</div><div class="line"><span class="comment">// prints all available timezone ids</span></div><div class="line"></div><div class="line">ZoneId zone1 = ZoneId.of(<span class="string">"Europe/Berlin"</span>);</div><div class="line">ZoneId zone2 = ZoneId.of(<span class="string">"Brazil/East"</span>);</div><div class="line">System.out.println(zone1.getRules());</div><div class="line">System.out.println(zone2.getRules());</div><div class="line"></div><div class="line"><span class="comment">// ZoneRules[currentStandardOffset=+01:00]</span></div><div class="line"><span class="comment">// ZoneRules[currentStandardOffset=-03:00]</span></div></pre></td></tr></table></figure>
<h4 id="3-LocalTime"><a href="#3-LocalTime" class="headerlink" title="(3)LocalTime"></a>(3)LocalTime</h4><p>LocalTime 定义了一个没有时区信息的时间，例如 晚上10点，或者 17:30:15。下面的例子使用前面代码创建的时区创建了两个本地时间。之后比较时间并以小时和分钟为单位计算两个时间的时间差：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">LocalTime now1 = LocalTime.now(zone1);</div><div class="line">LocalTime now2 = LocalTime.now(zone2);</div><div class="line"></div><div class="line">System.out.println(now1.isBefore(now2));  <span class="comment">// false</span></div><div class="line"></div><div class="line"><span class="keyword">long</span> hoursBetween = ChronoUnit.HOURS.between(now1, now2);</div><div class="line"><span class="keyword">long</span> minutesBetween = ChronoUnit.MINUTES.between(now1, now2);</div><div class="line"></div><div class="line">System.out.println(hoursBetween);       <span class="comment">// -3</span></div><div class="line">System.out.println(minutesBetween);     <span class="comment">// -239</span></div></pre></td></tr></table></figure>
<p>LocalTime 提供了多种工厂方法来简化对象的创建，包括解析时间字符串</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">LocalTime late = LocalTime.of(<span class="number">23</span>, <span class="number">59</span>, <span class="number">59</span>);</div><div class="line">System.out.println(late);       <span class="comment">// 23:59:59</span></div><div class="line"></div><div class="line">DateTimeFormatter germanFormatter =</div><div class="line">    DateTimeFormatter</div><div class="line">        .ofLocalizedTime(FormatStyle.SHORT)</div><div class="line">        .withLocale(Locale.GERMAN);</div><div class="line"></div><div class="line">LocalTime leetTime = LocalTime.parse(<span class="string">"13:37"</span>, germanFormatter);</div><div class="line">System.out.println(leetTime);   <span class="comment">// 13:37</span></div></pre></td></tr></table></figure>
<h4 id="4-LocalDate"><a href="#4-LocalDate" class="headerlink" title="(4)LocalDate"></a>(4)LocalDate</h4><p>LocalDate 表示了一个确切的日期，比如 2014-03-11。该对象值是不可变的，用起来和LocalTime基本一致。下面的例子展示了如何给Date对象加减天/月/年。另外要注意的是这些对象是不可变的，操作返回的总是一个新实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">LocalDate today = LocalDate.now();</div><div class="line">LocalDate tomorrow = today.plus(<span class="number">1</span>, ChronoUnit.DAYS);</div><div class="line">LocalDate yesterday = tomorrow.minusDays(<span class="number">2</span>);</div><div class="line"></div><div class="line">LocalDate independenceDay = LocalDate.of(<span class="number">2014</span>, Month.JULY, <span class="number">4</span>);</div><div class="line">DayOfWeek dayOfWeek = independenceDay.getDayOfWeek();</div><div class="line">System.out.println(dayOfWeek);    <span class="comment">// FRIDAY</span></div><div class="line"></div><div class="line">DateTimeFormatter germanFormatter =</div><div class="line">    DateTimeFormatter</div><div class="line">        .ofLocalizedDate(FormatStyle.MEDIUM)</div><div class="line">        .withLocale(Locale.GERMAN);</div><div class="line"></div><div class="line">LocalDate xmas = LocalDate.parse(<span class="string">"24.12.2014"</span>, germanFormatter);</div><div class="line">System.out.println(xmas);   <span class="comment">// 2014-12-24</span></div></pre></td></tr></table></figure>
<h4 id="5-LocalDateTime"><a href="#5-LocalDateTime" class="headerlink" title="(5)LocalDateTime"></a>(5)LocalDateTime</h4><p>LocalDateTime 同时表示了时间和日期，相当于前两节内容合并到一个对象上了。LocalDateTime和LocalTime还有LocalDate一样，都是不可变的。LocalDateTime提供了一些能访问具体字段的方法。<br>​<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">LocalDateTime sylvester = LocalDateTime.of(<span class="number">2014</span>, Month.DECEMBER, <span class="number">31</span>, <span class="number">23</span>, <span class="number">59</span>, <span class="number">59</span>);</div><div class="line"></div><div class="line">DayOfWeek dayOfWeek = sylvester.getDayOfWeek();</div><div class="line">System.out.println(dayOfWeek);      <span class="comment">// WEDNESDAY</span></div><div class="line"></div><div class="line">Month month = sylvester.getMonth();</div><div class="line">System.out.println(month);          <span class="comment">// DECEMBER</span></div><div class="line"></div><div class="line"><span class="keyword">long</span> minuteOfDay = sylvester.getLong(ChronoField.MINUTE_OF_DAY);</div><div class="line">System.out.println(minuteOfDay);    <span class="comment">// 1439</span></div><div class="line"></div><div class="line">Instant instant = sylvester</div><div class="line">        .atZone(ZoneId.systemDefault())</div><div class="line">        .toInstant();</div><div class="line"></div><div class="line">Date legacyDate = Date.from(instant);</div><div class="line">System.out.println(legacyDate);     <span class="comment">// Wed Dec 31 23:59:59 CET 2014</span></div><div class="line"></div><div class="line">DateTimeFormatter formatter =</div><div class="line">    DateTimeFormatter</div><div class="line">        .ofPattern(<span class="string">"MMM dd, yyyy - HH:mm"</span>);</div><div class="line"></div><div class="line">LocalDateTime parsed = LocalDateTime.parse(<span class="string">"Nov 03, 2014 - 07:13"</span>, formatter);</div><div class="line">String string = formatter.format(parsed);</div><div class="line">System.out.println(string);     <span class="comment">// Nov 03, 2014 - 07:13</span></div></pre></td></tr></table></figure></p>
<h3 id="5-支持重复注解了，注解也可以用在任何地方了"><a href="#5-支持重复注解了，注解也可以用在任何地方了" class="headerlink" title="5.支持重复注解了，注解也可以用在任何地方了"></a>5.支持重复注解了，注解也可以用在任何地方了</h3><p>java8之前，类，属性，方法才有注解，现在几乎任何地方都可以了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> <span class="meta">@Interned</span> MyObject();</div><div class="line">myString = (<span class="meta">@NonNull</span> String) str;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">monitorTemperature</span><span class="params">()</span> <span class="keyword">throws</span> @Critical TemperatureException </span>&#123; ... &#125;</div></pre></td></tr></table></figure>
<p>之前要实现重复注解需要这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Authority &#123;</div><div class="line">     <span class="function">String <span class="title">role</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Authorities &#123;</div><div class="line">    Authority[] value();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RepeatAnnotationUseOldVersion</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Authorities</span>(&#123;<span class="meta">@Authority</span>(role=<span class="string">"Admin"</span>),<span class="meta">@Authority</span>(role=<span class="string">"Manager"</span>)&#125;)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomeThing</span><span class="params">()</span></span>&#123;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>而现在：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Repeatable</span>(Authorities.class)</div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Authority &#123;</div><div class="line">     <span class="function">String <span class="title">role</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Authorities &#123;</div><div class="line">    Authority[] value();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RepeatAnnotationUseNewVersion</span> </span>&#123;</div><div class="line">    <span class="meta">@Authority</span>(role=<span class="string">"Admin"</span>)</div><div class="line">    <span class="meta">@Authority</span>(role=<span class="string">"Manager"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomeThing</span><span class="params">()</span></span>&#123; &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="6-Nashorn-JavaScript-引擎"><a href="#6-Nashorn-JavaScript-引擎" class="headerlink" title="6.Nashorn JavaScript 引擎"></a>6.Nashorn JavaScript 引擎</h3><p>简单的说，它是 Rhino 的接替者.升级啦。</p>
<h3 id="7-StampedLock"><a href="#7-StampedLock" class="headerlink" title="7.StampedLock"></a>7.StampedLock</h3><p>它是java8在java.util.concurrent.locks新增的一个API。</p>
<p>ReentrantReadWriteLock 在沒有任何读写锁时，才可以取得写入锁，这可用于实现了悲观读取（Pessimistic Reading），即如果执行中进行读取时，经常可能有另一执行要写入的需求，为了保持同步，ReentrantReadWriteLock 的读取锁定就可派上用场。</p>
<p>然而，如果读取执行情况很多，写入很少的情况下，使用 ReentrantReadWriteLock 可能会使写入线程遭遇饥饿（Starvation）问题，也就是写入线程吃吃无法竞争到锁定而一直处于等待状态。</p>
<p>StampedLock控制锁有三种模式（写，读，乐观读），一个StampedLock状态是由版本和模式两个部分组成，锁获取方法返回一个数字作为票据stamp，它用相应的锁状态表示并控制访问，数字0表示没有写锁被授权访问。在读锁上分为悲观锁和乐观锁。</p>
<p>所谓的乐观读模式，也就是若读的操作很多，写的操作很少的情况下，你可以乐观地认为，写入与读取同时发生几率很少，因此不悲观地使用完全的读取锁定，程序可以查看读取资料之后，是否遭到写入执行的变更，再采取后续的措施（重新读取变更信息，或者抛出异常） ，这一个小小改进，可大幅度提高程序的吞吐量！！</p>
<p>它是java8在java.util.concurrent.locks新增的一个API。</p>
<p>ReentrantReadWriteLock 在沒有任何读写锁时，才可以取得写入锁，这可用于实现了悲观读取（Pessimistic Reading），即如果执行中进行读取时，经常可能有另一执行要写入的需求，为了保持同步，ReentrantReadWriteLock 的读取锁定就可派上用场。</p>
<p>然而，如果读取执行情况很多，写入很少的情况下，使用 ReentrantReadWriteLock 可能会使写入线程遭遇饥饿（Starvation）问题，也就是写入线程吃吃无法竞争到锁定而一直处于等待状态。</p>
<p>StampedLock控制锁有三种模式（写，读，乐观读），一个StampedLock状态是由版本和模式两个部分组成，锁获取方法返回一个数字作为票据stamp，它用相应的锁状态表示并控制访问，数字0表示没有写锁被授权访问。在读锁上分为悲观锁和乐观锁。</p>
<p>所谓的乐观读模式，也就是若读的操作很多，写的操作很少的情况下，你可以乐观地认为，写入与读取同时发生几率很少，因此不悲观地使用完全的读取锁定，程序可以查看读取资料之后，是否遭到写入执行的变更，再采取后续的措施（重新读取变更信息，或者抛出异常） ，这一个小小改进，可大幅度提高程序的吞吐量！！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</div><div class="line">   <span class="keyword">private</span> <span class="keyword">double</span> x, y;</div><div class="line">   <span class="keyword">private</span> <span class="keyword">final</span> StampedLock sl = <span class="keyword">new</span> StampedLock();</div><div class="line">   <span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">double</span> deltaX, <span class="keyword">double</span> deltaY)</span> </span>&#123; <span class="comment">// an exclusively locked method</span></div><div class="line">     <span class="keyword">long</span> stamp = sl.writeLock();</div><div class="line">     <span class="keyword">try</span> &#123;</div><div class="line">       x += deltaX;</div><div class="line">       y += deltaY;</div><div class="line">     &#125; <span class="keyword">finally</span> &#123;</div><div class="line">       sl.unlockWrite(stamp);</div><div class="line">     &#125;</div><div class="line">   &#125;</div><div class="line">  <span class="comment">//下面看看乐观读锁案例</span></div><div class="line">   <span class="function"><span class="keyword">double</span> <span class="title">distanceFromOrigin</span><span class="params">()</span> </span>&#123; <span class="comment">// A read-only method</span></div><div class="line">     <span class="keyword">long</span> stamp = sl.tryOptimisticRead(); <span class="comment">//获得一个乐观读锁</span></div><div class="line">     <span class="keyword">double</span> currentX = x, currentY = y; <span class="comment">//将两个字段读入本地局部变量</span></div><div class="line">     <span class="keyword">if</span> (!sl.validate(stamp)) &#123; <span class="comment">//检查发出乐观读锁后同时是否有其他写锁发生？</span></div><div class="line">        stamp = sl.readLock(); <span class="comment">//如果没有，我们再次获得一个读悲观锁</span></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">          currentX = x; <span class="comment">// 将两个字段读入本地局部变量</span></div><div class="line">          currentY = y; <span class="comment">// 将两个字段读入本地局部变量</span></div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">           sl.unlockRead(stamp);</div><div class="line">        &#125;</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">return</span> Math.sqrt(currentX * currentX + currentY * currentY);</div><div class="line">   &#125;</div><div class="line"><span class="comment">//下面是悲观读锁案例</span></div><div class="line">   <span class="function"><span class="keyword">void</span> <span class="title">moveIfAtOrigin</span><span class="params">(<span class="keyword">double</span> newX, <span class="keyword">double</span> newY)</span> </span>&#123; <span class="comment">// upgrade</span></div><div class="line">     <span class="comment">// Could instead start with optimistic, not read mode</span></div><div class="line">     <span class="keyword">long</span> stamp = sl.readLock();</div><div class="line">     <span class="keyword">try</span> &#123;</div><div class="line">       <span class="keyword">while</span> (x == <span class="number">0.0</span> &amp;&amp; y == <span class="number">0.0</span>) &#123; <span class="comment">//循环，检查当前状态是否符合</span></div><div class="line">         <span class="keyword">long</span> ws = sl.tryConvertToWriteLock(stamp); <span class="comment">//将读锁转为写锁</span></div><div class="line">         <span class="keyword">if</span> (ws != <span class="number">0L</span>) &#123; <span class="comment">//这是确认转为写锁是否成功</span></div><div class="line">           stamp = ws; <span class="comment">//如果成功 替换票据</span></div><div class="line">           x = newX; <span class="comment">//进行状态改变</span></div><div class="line">           y = newY; <span class="comment">//进行状态改变</span></div><div class="line">           <span class="keyword">break</span>;</div><div class="line">         &#125;</div><div class="line">         <span class="keyword">else</span> &#123; <span class="comment">//如果不能成功转换为写锁</span></div><div class="line">           sl.unlockRead(stamp); <span class="comment">//我们显式释放读锁</span></div><div class="line">           stamp = sl.writeLock(); <span class="comment">//显式直接进行写锁 然后再通过循环再试</span></div><div class="line">         &#125;</div><div class="line">       &#125;</div><div class="line">     &#125; <span class="keyword">finally</span> &#123;</div><div class="line">       sl.unlock(stamp); <span class="comment">//释放读锁或写锁</span></div><div class="line">     &#125;</div><div class="line">   &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<hr>
<p>参考文档：<a href="http://winterbe.com/posts/2014/03/16/java-8-tutorial/" target="_blank" rel="external">http://winterbe.com/posts/2014/03/16/java-8-tutorial/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Java7新特性&quot;&gt;&lt;a href=&quot;#Java7新特性&quot; class=&quot;headerlink&quot; title=&quot;Java7新特性&quot;&gt;&lt;/a&gt;Java7新特性&lt;/h2&gt;&lt;h3 id=&quot;Java7语法特性&quot;&gt;&lt;a href=&quot;#Java7语法特性&quot; class=&quot;headerlink&quot; title=&quot;Java7语法特性&quot;&gt;&lt;/a&gt;Java7语法特性&lt;/h3&gt;&lt;p&gt;根据JSR 334，Java7添加了数个语法方面的新特性：&lt;/p&gt;
&lt;h4 id=&quot;1-switch可以消化String&quot;&gt;&lt;a href=&quot;#1-switch可以消化String&quot; class=&quot;headerlink&quot; title=&quot;1. switch可以消化String&quot;&gt;&lt;/a&gt;1. switch可以消化String&lt;/h4&gt;&lt;p&gt;比如：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;switchString&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String s)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;switch&lt;/span&gt; (s)&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;db&quot;&lt;/span&gt;: ...&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;wls&quot;&lt;/span&gt;: ...&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;ibm&quot;&lt;/span&gt;: ...&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;soa&quot;&lt;/span&gt;: ...&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;fa&quot;&lt;/span&gt;: ...&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;default&lt;/span&gt;: ...&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="java" scheme="https://www.shenyanchao.cn/categories/java/"/>
    
    
      <category term="java7" scheme="https://www.shenyanchao.cn/tags/java7/"/>
    
      <category term="java8" scheme="https://www.shenyanchao.cn/tags/java8/"/>
    
  </entry>
  
  <entry>
    <title>使用 jXLS导出报表</title>
    <link href="https://www.shenyanchao.cn/blog/2014/06/24/export-excel-by-jxls/"/>
    <id>https://www.shenyanchao.cn/blog/2014/06/24/export-excel-by-jxls/</id>
    <published>2014-06-24T07:17:00.000Z</published>
    <updated>2018-12-24T06:53:18.921Z</updated>
    
    <content type="html"><![CDATA[<h3 id="常用的excel操作工具"><a href="#常用的excel操作工具" class="headerlink" title="常用的excel操作工具"></a>常用的excel操作工具</h3><ul>
<li>Apache POI</li>
<li>jexcelApi</li>
</ul>
<p>它们都提供了完善的API来支持EXCEL的读写。</p>
<h3 id="jXLS是什么？"><a href="#jXLS是什么？" class="headerlink" title="jXLS是什么？"></a>jXLS是什么？</h3><p>jXLS是基于apache poi的一个扩展。它的功能就类似于jstl在servlet中的作用，你可以自定义一个模板，然后往里面放数据就OK了。</p>
<p>jXLS的基本功能：</p>
<ul>
<li>支持Excel 95-2000的所有版本</li>
<li>生成Excel 2000标准格式</li>
<li>支持字体、数字、日期操作</li>
<li>能够修饰单元格属性</li>
<li>支持图像和图表</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>net.sf.jxls<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jxls-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure>
<a id="more"></a>
<p>jXLS的API也很简单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Map beans = <span class="keyword">new</span> HashMap();</div><div class="line">beans.put(<span class="string">"department"</span>, department);</div><div class="line">XLSTransformer transformer = <span class="keyword">new</span> XLSTransformer();</div><div class="line">transformer.transformXLS(xlsTemplateFileName, beans, outputFileName);</div></pre></td></tr></table></figure>
<h3 id="jXLS是如何解析模板生成数据的？"><a href="#jXLS是如何解析模板生成数据的？" class="headerlink" title="jXLS是如何解析模板生成数据的？"></a>jXLS是如何解析模板生成数据的？</h3><p>查看<code>net.sf.jxls.transformer.CellTransformer</code>可以看到：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Object value = ((Expression) cell.getExpressions().get(<span class="number">0</span>)).evaluate();</div></pre></td></tr></table></figure>
<p>而evaluate()方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">evaluate</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    <span class="keyword">if</span> (beans != <span class="keyword">null</span> &amp;&amp; !beans.isEmpty()) &#123;</div><div class="line">        JexlContext context = <span class="keyword">new</span> MapContext(beans);</div><div class="line">        Object ret = jexlExpresssion.evaluate(context);</div><div class="line">        <span class="keyword">if</span> (aggregateFunction != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> calculateAggregate(aggregateFunction, aggregateField, ret);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> ret;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> expression;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从而可以看出，数据的获得是通过JEXL来实现的。换句话说，模板内可以使用任何的JEXL标签。</p>
<h3 id="让jXLS支持hyperlink"><a href="#让jXLS支持hyperlink" class="headerlink" title="让jXLS支持hyperlink"></a>让jXLS支持hyperlink</h3><p>业务上有这么一个需求，想在单元格内显示一个链接，而链接是动态生成的。通过模板设置单元格为链接始终无法生效，但是如果链接是固定的是可以生效的。如何实现动态的呢，改源码net.sf.jxls.transformer.CellTransformer 82行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (cell.getStringCellValue().toLowerCase().startsWith(<span class="string">"$&#123;href&#125;"</span>) &amp;&amp; cell.getExpressions().size() == <span class="number">3</span>)&#123;</div><div class="line">           <span class="comment">//是链接类型的cell</span></div><div class="line">           HSSFCell hssfCell = (HSSFCell) cell.getPoiCell();</div><div class="line">           Expression valueExpr = (Expression)cell.getExpressions().get(<span class="number">1</span>);</div><div class="line">           Expression linkExpr = (Expression)cell.getExpressions().get(<span class="number">2</span>);</div><div class="line">           hssfCell.setCellValue((String)valueExpr.evaluate());</div><div class="line">           Hyperlink link = <span class="keyword">new</span> HSSFHyperlink(Hyperlink.LINK_URL);</div><div class="line">           link.setAddress((String)linkExpr.evaluate());</div><div class="line">           hssfCell.setHyperlink(link);</div><div class="line">           cell.setPoiCell(hssfCell);</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p>当遇见${href}开头的表达式，则认为是链接CELL。此处${href}只是一个标记，可以任意替换的啦。然后将后面的第1个表达式作为显示值，第2个表达式作为链接地址就实现啦。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;常用的excel操作工具&quot;&gt;&lt;a href=&quot;#常用的excel操作工具&quot; class=&quot;headerlink&quot; title=&quot;常用的excel操作工具&quot;&gt;&lt;/a&gt;常用的excel操作工具&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Apache POI&lt;/li&gt;
&lt;li&gt;jexcelApi&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;它们都提供了完善的API来支持EXCEL的读写。&lt;/p&gt;
&lt;h3 id=&quot;jXLS是什么？&quot;&gt;&lt;a href=&quot;#jXLS是什么？&quot; class=&quot;headerlink&quot; title=&quot;jXLS是什么？&quot;&gt;&lt;/a&gt;jXLS是什么？&lt;/h3&gt;&lt;p&gt;jXLS是基于apache poi的一个扩展。它的功能就类似于jstl在servlet中的作用，你可以自定义一个模板，然后往里面放数据就OK了。&lt;/p&gt;
&lt;p&gt;jXLS的基本功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;支持Excel 95-2000的所有版本&lt;/li&gt;
&lt;li&gt;生成Excel 2000标准格式&lt;/li&gt;
&lt;li&gt;支持字体、数字、日期操作&lt;/li&gt;
&lt;li&gt;能够修饰单元格属性&lt;/li&gt;
&lt;li&gt;支持图像和图表&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;     &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;net.sf.jxls&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;     &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;jxls-core&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;     &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;1.0.5&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Java" scheme="https://www.shenyanchao.cn/categories/Java/"/>
    
    
      <category term="apache poi" scheme="https://www.shenyanchao.cn/tags/apache-poi/"/>
    
      <category term="excel" scheme="https://www.shenyanchao.cn/tags/excel/"/>
    
      <category term="jXLS" scheme="https://www.shenyanchao.cn/tags/jXLS/"/>
    
      <category term="jxl" scheme="https://www.shenyanchao.cn/tags/jxl/"/>
    
  </entry>
  
  <entry>
    <title>Spring中配置quartz集群</title>
    <link href="https://www.shenyanchao.cn/blog/2014/06/24/quartz-cluster-with-spring/"/>
    <id>https://www.shenyanchao.cn/blog/2014/06/24/quartz-cluster-with-spring/</id>
    <published>2014-06-24T07:10:00.000Z</published>
    <updated>2018-10-24T06:14:32.681Z</updated>
    
    <content type="html"><![CDATA[<h3 id="为什么使用quartz集群？"><a href="#为什么使用quartz集群？" class="headerlink" title="为什么使用quartz集群？"></a>为什么使用quartz集群？</h3><p>在服务部署一个节点的时候，quartz任务是可以正常运行的。但是如果你业务上需要部署2个或者以上的集群时，就需要处理集群之间的定时任务执行问题了。而quartz集群就是为了解决这个问题的。前提是集群的时间同步，以及共用同一个数据库。<br>quartz集群在spring中的配置</p>
<h4 id="1-导入数据库表"><a href="#1-导入数据库表" class="headerlink" title="1.导入数据库表"></a>1.导入数据库表</h4><p>以mysql为例，下载quartz发行版，在/docs/dbTables下找到tables_mysql_innodb.sql。导入数据结构到数据库内。 使用tables_mysql.sql的话，由于没有指定使用innodB引擎，在一些默认使用MYISAM的数据库实例内可能会报错。</p>
<p>注意事项：</p>
<p>修改SQL： TYPE=InnoDB –&gt; ENGINE=InnoDB<br><a id="more"></a></p>
<h4 id="2-项目中加入配置文件quartz-properties"><a href="#2-项目中加入配置文件quartz-properties" class="headerlink" title="2.项目中加入配置文件quartz.properties"></a>2.项目中加入配置文件quartz.properties</h4><pre><code>#============================================================================
# Configure Main Scheduler Properties
#============================================================================
org.quartz.scheduler.instanceName = ClusteredScheduler
org.quartz.scheduler.instanceId = AUTO
org.quartz.scheduler.skipUpdateCheck = true

#============================================================================
# Configure ThreadPool
#============================================================================
org.quartz.threadPool.class = org.quartz.simpl.SimpleThreadPool
org.quartz.threadPool.threadCount = 5
org.quartz.threadPool.threadPriority = 5

#============================================================================
# Configure JobStore
#============================================================================
org.quartz.jobStore.class = org.quartz.impl.jdbcjobstore.JobStoreTX
org.quartz.jobStore.driverDelegateClass=org.quartz.impl.jdbcjobstore.StdJDBCDelegate
org.quartz.jobStore.misfireThreshold = 60000
org.quartz.jobStore.useProperties = false
org.quartz.jobStore.tablePrefix = QRTZ_

org.quartz.jobStore.isClustered = true
org.quartz.jobStore.clusterCheckinInterval = 15000
</code></pre><h4 id="3-增加applicationContext-quartz-xml"><a href="#3-增加applicationContext-quartz-xml" class="headerlink" title="3.增加applicationContext-quartz.xml"></a>3.增加applicationContext-quartz.xml</h4><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:util=&quot;http://www.springframework.org/schema/util&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
                        http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-3.0.xsd&quot;
       default-lazy-init=&quot;false&quot;&gt;

    &lt;description&gt;Quartz的定时集群任务配置&lt;/description&gt;

    &lt;bean id=&quot;quartzDataSource&quot; class=&quot;org.springframework.jdbc.datasource.SimpleDriverDataSource&quot;&gt;
        &lt;property name=&quot;driverClass&quot; value=&quot;${db.driver}&quot; /&gt;
        &lt;property name=&quot;url&quot; value=&quot;${db.url}&quot; /&gt;
        &lt;property name=&quot;username&quot; value=&quot;${db.user}&quot; /&gt;
        &lt;property name=&quot;password&quot; value=&quot;${db.pass}&quot; /&gt;
    &lt;/bean&gt;

    &lt;!-- Quartz集群Schduler --&gt;
    &lt;bean id=&quot;clusterQuartzScheduler&quot; class=&quot;org.springframework.scheduling.quartz.SchedulerFactoryBean&quot;&gt;
        &lt;!-- Triggers集成 --&gt;
        &lt;property name=&quot;triggers&quot;&gt;
            &lt;list&gt;
                &lt;ref bean=&quot;testTrigger&quot; /&gt;
            &lt;/list&gt;
        &lt;/property&gt;
        &lt;!--  quartz配置文件路径--&gt;
        &lt;property name=&quot;configLocation&quot; value=&quot;classpath:quartz/quartz.properties&quot; /&gt;
        &lt;!-- 启动时延期3秒开始任务 --&gt;
        &lt;property name=&quot;startupDelay&quot; value=&quot;3&quot; /&gt;
        &lt;!-- 保存Job数据到数据库所需的数据源 --&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;quartzDataSource&quot; /&gt;
        &lt;!-- Job接受applicationContext的成员变量名 --&gt;
        &lt;property name=&quot;applicationContextSchedulerContextKey&quot; value=&quot;applicationContext&quot; /&gt;
        &lt;property name=&quot;overwriteExistingJobs&quot; value=&quot;true&quot; /&gt;
        &lt;property name=&quot;jobFactory&quot;&gt;
            &lt;bean class=&quot;com.shenyanchao.quartz.AutoWiringSpringBeanJobFactory&quot;/&gt;
        &lt;/property&gt;
     &lt;/bean&gt;


    &lt;bean id=&quot;testTrigger&quot; class=&quot;org.springframework.scheduling.quartz.CronTriggerBean&quot;&gt;
        &lt;property name=&quot;jobDetail&quot; ref=&quot;testJobDetail&quot; /&gt;
        &lt;property name=&quot;cronExpression&quot; value=&quot;* 0/10 * * * ?&quot; /&gt;
    &lt;/bean&gt;

    &lt;!-- Timer JobDetail, 基于JobDetailBean实例化Job Class,可持久化到数据库实现集群 --&gt;
    &lt;bean id=&quot;testJobDetail&quot; class=&quot;org.springframework.scheduling.quartz.JobDetailBean&quot;&gt;
        &lt;property name=&quot;jobClass&quot; value=&quot;cn.shenyanchao.quartz.TestTask&quot; /&gt;
    &lt;/bean&gt;

    &lt;!-- Timer Job的可配置属性,在job中通过applicationContext动态获取 --&gt;
    &lt;util:map id=&quot;timerJobConfig&quot;&gt;
        &lt;entry key=&quot;nodeName&quot; value=&quot;default&quot; /&gt;
    &lt;/util:map&gt;
&lt;/beans&gt;
</code></pre><p>其中尤其注意，设置overwriteExistingJobs为true，这个选项可以在修改cronExpression之后，能够更新到数据库，否则无法生效。</p>
<p>另外，配置JobFactory使得QuartzJob可以@Autowired注入spring托管的实例。内容如下：</p>
<pre><code>public final class AutoWiringSpringBeanJobFactory extends SpringBeanJobFactory implements ApplicationContextAware {

        private transient AutowireCapableBeanFactory beanFactory;

        public void setApplicationContext(final ApplicationContext context) {
            beanFactory = context.getAutowireCapableBeanFactory();
        }

        @Override
        protected Object createJobInstance(final TriggerFiredBundle bundle) throws Exception {
            final Object job = super.createJobInstance(bundle);
            beanFactory.autowireBean(job);
            return job;
        }
    }
</code></pre><h4 id="4-如何写JOB？"><a href="#4-如何写JOB？" class="headerlink" title="4. 如何写JOB？"></a>4. 如何写JOB？</h4><pre><code>@Component
public class TestTask extends QuartzJobBean {


    @Autowired
    private UserService userService;

    @Override
    protected void executeInternal(JobExecutionContext context) throws JobExecutionException {
        System.out.println(userService.findByName(&quot;shenyanchao&quot;).getEmail());
    }
}
</code></pre><p>由于使用MethodInvokingFactoryBean总是报seriziable错误，因此本例使用的是JobDetailBean。那这也意味着要继承QuartzJobBean。同时由于配置了JobFactory，使得可以直接注入UserService等实例。</p>
<h4 id="5-quartz在mysql5-6下报错"><a href="#5-quartz在mysql5-6下报错" class="headerlink" title="5.quartz在mysql5.6下报错"></a>5.quartz在mysql5.6下报错</h4><pre><code>You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &apos;OPTION SQL_SELECT_LIMIT=5&apos; at line 1
</code></pre><p>这个错误是由于mysql connector的版本太低导致的，可以通过升级版本来解决。 参见<a href="http://stackoverflow.com/questions/13023548/mysql-server-version-for-the-right-syntax-to-use-near-option-sql-select-limit-1" target="_blank" rel="external">http://stackoverflow.com/questions/13023548/mysql-server-version-for-the-right-syntax-to-use-near-option-sql-select-limit-1</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;为什么使用quartz集群？&quot;&gt;&lt;a href=&quot;#为什么使用quartz集群？&quot; class=&quot;headerlink&quot; title=&quot;为什么使用quartz集群？&quot;&gt;&lt;/a&gt;为什么使用quartz集群？&lt;/h3&gt;&lt;p&gt;在服务部署一个节点的时候，quartz任务是可以正常运行的。但是如果你业务上需要部署2个或者以上的集群时，就需要处理集群之间的定时任务执行问题了。而quartz集群就是为了解决这个问题的。前提是集群的时间同步，以及共用同一个数据库。&lt;br&gt;quartz集群在spring中的配置&lt;/p&gt;
&lt;h4 id=&quot;1-导入数据库表&quot;&gt;&lt;a href=&quot;#1-导入数据库表&quot; class=&quot;headerlink&quot; title=&quot;1.导入数据库表&quot;&gt;&lt;/a&gt;1.导入数据库表&lt;/h4&gt;&lt;p&gt;以mysql为例，下载quartz发行版，在/docs/dbTables下找到tables_mysql_innodb.sql。导入数据结构到数据库内。 使用tables_mysql.sql的话，由于没有指定使用innodB引擎，在一些默认使用MYISAM的数据库实例内可能会报错。&lt;/p&gt;
&lt;p&gt;注意事项：&lt;/p&gt;
&lt;p&gt;修改SQL： TYPE=InnoDB –&amp;gt; ENGINE=InnoDB&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="https://www.shenyanchao.cn/categories/Java/"/>
    
    
      <category term="spring" scheme="https://www.shenyanchao.cn/tags/spring/"/>
    
      <category term="quartz" scheme="https://www.shenyanchao.cn/tags/quartz/"/>
    
      <category term="集群" scheme="https://www.shenyanchao.cn/tags/%E9%9B%86%E7%BE%A4/"/>
    
  </entry>
  
</feed>
