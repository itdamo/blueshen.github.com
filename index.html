<!doctype html>



  


<html class="theme-next pisces use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="搜索, 自然语言处理" />





  <link rel="alternate" href="/atom.xml" title="Blues小站" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta property="og:type" content="website">
<meta property="og:title" content="Blues小站">
<meta property="og:url" content="http://www.shenyanchao.cn/index.html">
<meta property="og:site_name" content="Blues小站">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Blues小站">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>

  <title> Blues小站 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  


<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-123-12', 'auto');
  ga('send', 'pageview');
</script>


  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?81c9612f8fdceca45435ef7f5404d7b2";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>








  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Blues小站</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">搜索引擎与自然语言处理</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404.html" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            公益404
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/blog/2016/08/14/about-interface-define/" itemprop="url">
                  关于接口定义的一些想法
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-08-14T21:19:53+08:00" content="2016-08-14">
              2016-08-14
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/blog/2016/08/14/about-interface-define/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="blog/2016/08/14/about-interface-define/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近公司内项目，需要开发接口给ios,android客户端去调用。因此，做了一些思考，主要是关于如何更好的定义接口以及联调。</p>
<h3 id="使用RESTFul接口"><a href="#使用RESTFul接口" class="headerlink" title="使用RESTFul接口"></a>使用RESTFul接口</h3><p>RESTFul接口作为一个通行的标准，当然是优先使用的。项目都是基于Spring的，因此采用的是Spring MVC.</p>
<h3 id="解决接口联调的苦难"><a href="#解决接口联调的苦难" class="headerlink" title="解决接口联调的苦难"></a>解决接口联调的苦难</h3><p>作为一个技术人员，写文档是一大令人头疼的事情。况且即使把文档写好了，也可能导致在以后的修修补补中，导致不一致的情况。<br>因此，考虑采用文档自动生成的方式。最终选用了Swagger<wwww.swagger.io>来自动为Spring MVC生成文档。</wwww.swagger.io></p>
<ul>
<li>swagger-maven-plugin</li>
<li>swagger-ui</li>
</ul>
<h3 id="项目中遇到的一些教训"><a href="#项目中遇到的一些教训" class="headerlink" title="项目中遇到的一些教训"></a>项目中遇到的一些教训</h3><p>作为技术负责人</p>
<ul>
<li>提前制定接口，方便联调</li>
<li>提前规划返回接口类型，统一字段名称。</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/blog/2015/11/03/restful-springmvc/" itemprop="url">
                  Restful Spring MVC
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-11-03T13:53:00+08:00" content="2015-11-03">
              2015-11-03
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/spring/" itemprop="url" rel="index">
                    <span itemprop="name">spring</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/blog/2015/11/03/restful-springmvc/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="blog/2015/11/03/restful-springmvc/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Spring MVC本身对Restful支持非常好。它的<code>@RequestMapping</code>、<code>@RequestParam</code>、<code>@PathVariable</code>、<code>@ResponseBody</code>注解很好的支持了REST。<a href="http://static.springsource.org/spring/docs/3.0.0.M3/reference/html/ch18s02.html" target="_blank" rel="external">18.2 Creating RESTful services</a></p>
<h3 id="1-RequestMapping"><a href="#1-RequestMapping" class="headerlink" title="1. @RequestMapping"></a>1. <code>@RequestMapping</code></h3><p>Spring uses the @RequestMapping method annotation to define the URI Template for the request. 类似于struts的action-mapping。 可以指定POST或者GET。</p>
<h3 id="2-PathVariable"><a href="#2-PathVariable" class="headerlink" title="2. @PathVariable"></a>2. <code>@PathVariable</code></h3><p>The @PathVariable method parameter annotation is used to indicate that a method parameter should be bound to the value of a URI template variable. 用于抽取URL中的信息作为参数。（注意，不包括请求字符串，那是<code>@RequestParam</code>做的事情。）</p>
<pre><code>@RequestMapping(&quot;/owners/{ownerId}&quot;, method=RequestMethod.GET)
public String findOwner(@PathVariable String ownerId, Model model) {
        // ...
}
</code></pre><p>如果变量名与pathVariable名不一致，那么需要指定：</p>
<pre><code>@RequestMapping(&quot;/owners/{ownerId}&quot;, method=RequestMethod.GET)
public String findOwner(@PathVariable(&quot;ownerId&quot;) String theOwner, Model model) {
    // implementation omitted
}
</code></pre><blockquote>
<p><strong>Tip</strong></p>
<p>method parameters that are decorated with the @PathVariable annotation can be of any simple type such as int, long, Date… Spring automatically converts to the appropriate type and throws a TypeMismatchException if the type is not correct.</p>
</blockquote>
<h3 id="3-RequestParam"><a href="#3-RequestParam" class="headerlink" title="3. @RequestParam"></a>3. <code>@RequestParam</code></h3><p>官方文档居然没有对这个注解进行说明，估计是遗漏了（真不应该啊）。这个注解跟<code>@PathVariable</code>功能差不多，只是参数值的来源不一样而已。它的取值来源是请求参数（querystring或者post表单字段）。</p>
<p>对了，因为它的来源可以是POST字段，所以它支持更丰富和复杂的类型信息。比如文件对象:</p>
<pre><code>@RequestMapping(&quot;/imageUpload&quot;)
public String processImageUpload(@RequestParam(&quot;name&quot;) String name,
                @RequestParam(&quot;description&quot;) String description,
                @RequestParam(&quot;image&quot;) MultipartFile image) throws IOException {
    this.imageDatabase.storeImage(name, image.getInputStream(), 
                                    (int) image.getSize(), description);
    return &quot;redirect:imageList&quot;;
}
</code></pre><p>还可以设置defaultValue：</p>
<pre><code>@RequestMapping(&quot;/imageUpload&quot;)
public String processImageUpload(@RequestParam(value=&quot;name&quot;, defaultValue=&quot;arganzheng&quot;) String name,
                @RequestParam(&quot;description&quot;) String description,
                @RequestParam(&quot;image&quot;) MultipartFile image) throws IOException {
    this.imageDatabase.storeImage(name, image.getInputStream(), 
                                    (int) image.getSize(), description);
    return &quot;redirect:imageList&quot;;
}
</code></pre><h3 id="4-RequestBody和-ResponseBody"><a href="#4-RequestBody和-ResponseBody" class="headerlink" title="4. @RequestBody和@ResponseBody"></a>4. <code>@RequestBody</code>和<code>@ResponseBody</code></h3><p>这两个注解其实用到了Spring的一个非常灵活的设计——<code>HttpMessageConverter</code> <a href="http://static.springsource.org/spring/docs/3.0.0.M3/reference/html/ch18s03.html#rest-message-conversion" target="_blank" rel="external">18.3.2 HTTP Message Conversion</a></p>
<p>与<code>@RequestParam</code>不同，<code>@RequestBody</code>和<code>@ResponseBody</code>是针对整个HTTP请求或者返回消息的。前者只是针对HTTP请求消息中的一个 name=value 键值对(名称很贴切)。</p>
<p><code>HtppMessageConverter</code>负责将HTTP请求消息(HTTP request message)转化为对象，或者将对象转化为HTTP响应体(HTTP response body)。</p>
<pre><code>public interface HttpMessageConverter&lt;T&gt; {

    // Indicate whether the given class is supported by this converter.
    boolean supports(Class&lt;? extends T&gt; clazz);

    // Return the list of MediaType objects supported by this converter.
    List&lt;MediaType&gt; getSupportedMediaTypes();

    // Read an object of the given type form the given input message, and returns it.
    T read(Class&lt;T&gt; clazz, HttpInputMessage inputMessage) throws IOException, 
                                                                    HttpMessageNotReadableException;

    // Write an given object to the given output message.
    void write(T t, HttpOutputMessage outputMessage) throws IOException, 
                                                            HttpMessageNotWritableException;

}        
</code></pre><p>Spring MVC对<code>HttpMessageConverter</code>有多种默认实现，基本上不需要自己再自定义<code>HttpMessageConverter</code><br>&gt;</p>
<ul>
<li>StringHttpMessageConverter - converts strings</li>
<li>FormHttpMessageConverter - converts form data to/from a MultiValueMap<string, string=""></string,></li>
<li>ByteArrayMessageConverter - converts byte arrays</li>
<li>SourceHttpMessageConverter - convert to/from a javax.xml.transform.Source</li>
<li>RssChannelHttpMessageConverter - convert to/from RSS feeds</li>
<li>MappingJacksonHttpMessageConverter - convert to/from JSON using Jackson’s ObjectMapper</li>
<li>etc…</li>
</ul>
<p>然而对于RESTful应用，用的最多的当然是<code>MappingJacksonHttpMessageConverter</code>。</p>
<p>但是<code>MappingJacksonHttpMessageConverter</code>不是默认的<code>HttpMessageConverter</code>：</p>
<pre><code>public class AnnotationMethodHandlerAdapter extends WebContentGenerator
implements HandlerAdapter, Ordered, BeanFactoryAware {

    ...

    public AnnotationMethodHandlerAdapter() {
        // no restriction of HTTP methods by default
        super(false);

        // See SPR-7316
        StringHttpMessageConverter stringHttpMessageConverter = new StringHttpMessageConverter();
        stringHttpMessageConverter.setWriteAcceptCharset(false);
        this.messageConverters = new HttpMessageConverter[]{new ByteArrayHttpMessageConverter(), stringHttpMessageConverter,
        new SourceHttpMessageConverter(), new XmlAwareFormHttpMessageConverter()};
    }
}   
</code></pre><p>如上：默认的<code>HttpMessageConverter</code>是<code>ByteArrayHttpMessageConverter</code>、<code>stringHttpMessageConverter</code>、<code>SourceHttpMessageConverter</code>和<code>XmlAwareFormHttpMessageConverter</code>转换器。所以需要配置一下：</p>
<pre><code>&lt;bean class=&quot;org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter&quot;&gt;
    &lt;property name=&quot;messageConverters&quot;&gt;
    &lt;list&gt;
        &lt;bean class=&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt;
        &lt;property name=&quot;supportedMediaTypes&quot;&gt;
            &lt;list&gt;
            &lt;value&gt;text/plain;charset=GBK&lt;/value&gt;
            &lt;/list&gt;
        &lt;/property&gt;
        &lt;/bean&gt;
        &lt;bean class=&quot;org.springframework.http.converter.json.MappingJacksonHttpMessageConverter&quot; /&gt;
    &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre><p>配置好了之后，就可以享受<code>@Requestbody</code>和<code>@ResponseBody</code>对JONS转换的便利之处了：</p>
<pre><code>@RequestMapping(value = &quot;api&quot;, method = RequestMethod.POST)
@ResponseBody
public boolean addApi(@RequestBody
    Api api, @RequestParam(value = &quot;afterApiId&quot;, required = false)
    Integer afterApiId) {
        Integer id = apiMetadataService.addApi(api);
        return id &gt; 0;
}

@RequestMapping(value = &quot;api/{apiId}&quot;, method = RequestMethod.GET)
@ResponseBody
public Api getApi(@PathVariable(&quot;apiId&quot;)
    int apiId) {
        return apiMetadataService.getApi(apiId, Version.primary);
}
</code></pre><p>一般情况下我们是不需要自定义<code>HttpMessageConverter</code>，不过对于Restful应用，有时候我们需要返回jsonp数据：</p>
<pre><code>package me.arganzheng.study.springmvc.util;

import java.io.IOException;
import java.io.PrintStream;

import org.codehaus.jackson.map.ObjectMapper;
import org.codehaus.jackson.map.annotate.JsonSerialize.Inclusion;
import org.springframework.http.HttpOutputMessage;
import org.springframework.http.converter.HttpMessageNotWritableException;
import org.springframework.http.converter.json.MappingJacksonHttpMessageConverter;
import org.springframework.web.context.request.RequestAttributes;
import org.springframework.web.context.request.RequestContextHolder;
import org.springframework.web.context.request.ServletRequestAttributes;

public class MappingJsonpHttpMessageConverter extends MappingJacksonHttpMessageConverter {

    public MappingJsonpHttpMessageConverter() {
    ObjectMapper objectMapper = new ObjectMapper();
    objectMapper.setSerializationConfig(objectMapper.getSerializationConfig().withSerializationInclusion(Inclusion.NON_NULL));
    setObjectMapper(objectMapper);
    }

    @Override
    protected void writeInternal(Object o, HttpOutputMessage outputMessage) throws IOException, HttpMessageNotWritableException {
    String jsonpCallback = null;

    RequestAttributes reqAttrs = RequestContextHolder.currentRequestAttributes();
    if(reqAttrs instanceof ServletRequestAttributes){
        jsonpCallback = ((ServletRequestAttributes)reqAttrs).getRequest().getParameter(&quot;jsonpCallback&quot;);
    }

    if(jsonpCallback != null){
        new PrintStream(outputMessage.getBody()).print(jsonpCallback + &quot;(&quot;);
    }

    super.writeInternal(o, outputMessage);

    if(jsonpCallback != null){
        new PrintStream(outputMessage.getBody()).println(&quot;);&quot;);
    }
    }
}
</code></pre><p>如果请求的参数中带有<code>jsonpCallback</code>，那么会返回jsonp格式数据。比如：<br><a href="http://open.buy.qq.com/meta/api/1.xhtml?jsonpCallback=clientFunction。" target="_blank" rel="external">http://open.buy.qq.com/meta/api/1.xhtml?jsonpCallback=clientFunction。</a><br>会返回<code>clientFunction(…);</code></p>
<h3 id="5-CookieValue"><a href="#5-CookieValue" class="headerlink" title="5. @CookieValue"></a>5. <code>@CookieValue</code></h3><p><code>@CookieValue</code>用于将请求的Cookie数据映射到功能处理方法的参数上。</p>
<pre><code>public String test(@CookieValue(value=&quot;JSESSIONID&quot;, defaultValue=&quot;&quot;) String sessionId){
    ...
}
</code></pre><p>如上配置将自动将JSESSIONID值入参到sessionId参数上，defaultValue表示Cookie中没有JSESSIONID时默认为空。</p>
<pre><code>public String test2(@CookieValue(value=&quot;JSESSIONID&quot;, defaultValue=&quot;&quot;) Cookie sessionId){
    ...
}
</code></pre><p>传入参数类型也可以是javax.servlet.http.Cookie类型。</p>
<p><strong>TIPS</strong> 如果是使用cookies值来保持回话状态的话，推荐使用Spring的<a href="http://docs.spring.io/spring/docs/3.0.0.M3/reference/html/ch04s04.html" target="_blank" rel="external">Bean Scopes</a>机制，具体参见笔者的另一篇文章：<a href="http://blog.arganzheng.me/posts/spring-bean-scopes.html" target="_blank" rel="external">Spring的Bean Scopes</a>。非常方便。</p>
<h3 id="6-RequestHeader"><a href="#6-RequestHeader" class="headerlink" title="6. @RequestHeader"></a>6. <code>@RequestHeader</code></h3><p><code>@RequestHeader</code>用于将请求的头信息区数据映射到功能处理方法的参数上。</p>
<pre><code>@RequestMapping(value=&quot;/header&quot;)  
public String test(  
   @RequestHeader(&quot;User-Agent&quot;) String userAgent,  
   @RequestHeader(value=&quot;Accept&quot;) String[] accepts)  
</code></pre><p>如上配置将自动将请求头“User-Agent”值入参到userAgent参数上，并将“Accept”请求头值入参到accepts参数上。</p>
<h3 id="7-返回多种表现形式-Returning-multiple-representations"><a href="#7-返回多种表现形式-Returning-multiple-representations" class="headerlink" title="7. 返回多种表现形式(Returning multiple representations)"></a>7. 返回多种表现形式(Returning multiple representations)</h3><p>对于Restful服务，一个资源往往有多种表现形式，比如最常见的就是返回xml和json格式数据，还有就是RSS和ATOM。怎样让客户端告诉Restful服务，我希望得到什么样表现形式的资源呢？</p>
<p>一般来说client可以通过以下三者方式来通知Server它希望拿到的资源格式：</p>
<ol>
<li>使用不同URI来表示同个资源的不同表现形式。一般使用不同的文件拓展名。如<a href="http://blog.arganzheng.me/users/argan.xml表示返回xml格式数据，而http://blog.arganzheng.me/users/aganzheng.json表示返回json格式" target="_blank" rel="external">http://blog.arganzheng.me/users/argan.xml表示返回xml格式数据，而http://blog.arganzheng.me/users/aganzheng.json表示返回json格式</a>.</li>
<li>使用一个请求参数告诉服务器希望得到的资源格式。如format=json。</li>
<li>使用同个URI，但是通过Accept HTTP request header来告诉server它理解的media types。例如同样请求<a href="http://blog.arganzheng.me/users/argan，如果带上`text/xml`" target="_blank" rel="external">http://blog.arganzheng.me/users/argan，如果带上`text/xml`</a> accept header表示请求一个XML资源，带上<code>application/pdf</code>则表示期望收到pdf格式资源。</li>
</ol>
<p>这其实就是Spring MVC默认的三个<code>ContentNegotiationStrategy</code>，即所谓的PPA Strategy（path extension, then parameter, then Accept header) ，顺序也是先path extension，然后parameter(默认是format参数)，然后才是accept头。</p>
<p>Spring提供了<a href="http://static.springsource.org/spring/docs/3.0.x/javadoc-api/org/springframework/web/servlet/view/ContentNegotiatingViewResolver.html" target="_blank" rel="external"><code>ContentNegotiatingViewResolver</code></a>来解决这个问题：</p>
<pre><code>public class ContentNegotiatingViewResolver extends WebApplicationObjectSupport implements ViewResolver, Ordered {

    private static final Log logger = LogFactory.getLog(ContentNegotiatingViewResolver.class);

    private static final String ACCEPT_HEADER = &quot;Accept&quot;;

    private static final boolean jafPresent =
        ClassUtils.isPresent(&quot;javax.activation.FileTypeMap&quot;, ContentNegotiatingViewResolver.class.getClassLoader());

    private static final UrlPathHelper urlPathHelper = new UrlPathHelper();


    private int order = Ordered.HIGHEST_PRECEDENCE;

    private boolean favorPathExtension = true;

    private boolean favorParameter = false;

    private String parameterName = &quot;format&quot;;

    private boolean useNotAcceptableStatusCode = false;

    private boolean ignoreAcceptHeader = false;

    private boolean useJaf = true;

    private ConcurrentMap&lt;String, MediaType&gt; mediaTypes = new ConcurrentHashMap&lt;String, MediaType&gt;();

    private List&lt;View&gt; defaultViews;

    private MediaType defaultContentType;

    private List&lt;ViewResolver&gt; viewResolvers;


    // ignore some setter and getter...    

    public void setMediaTypes(Map&lt;String, String&gt; mediaTypes) {
      Assert.notNull(mediaTypes, &quot;&apos;mediaTypes&apos; must not be null&quot;);
      for (Map.Entry&lt;String, String&gt; entry : mediaTypes.entrySet()) {
        String extension = entry.getKey().toLowerCase(Locale.ENGLISH);
        MediaType mediaType = MediaType.parseMediaType(entry.getValue());
        this.mediaTypes.put(extension, mediaType);
      }
    }

    public void setDefaultViews(List&lt;View&gt; defaultViews) {
      this.defaultViews = defaultViews;
    }

    public void setDefaultContentType(MediaType defaultContentType) {
      this.defaultContentType = defaultContentType;
    }

    public void setViewResolvers(List&lt;ViewResolver&gt; viewResolvers) {
      this.viewResolvers = viewResolvers;
    }


    @Override
    protected void initServletContext(ServletContext servletContext) {
      if (this.viewResolvers == null) {
        Map&lt;String, ViewResolver&gt; matchingBeans =
            BeanFactoryUtils.beansOfTypeIncludingAncestors(getApplicationContext(), ViewResolver.class);
        this.viewResolvers = new ArrayList&lt;ViewResolver&gt;(matchingBeans.size());
        for (ViewResolver viewResolver : matchingBeans.values()) {
          if (this != viewResolver) {
            this.viewResolvers.add(viewResolver);
          }
        }
      }
      if (this.viewResolvers.isEmpty()) {
        logger.warn(&quot;Did not find any ViewResolvers to delegate to; please configure them using the &quot; +
            &quot;&apos;viewResolvers&apos; property on the ContentNegotiatingViewResolver&quot;);
      }
      OrderComparator.sort(this.viewResolvers);
    }

    public View resolveViewName(String viewName, Locale locale) throws Exception {
      RequestAttributes attrs = RequestContextHolder.getRequestAttributes();
      Assert.isInstanceOf(ServletRequestAttributes.class, attrs);
      List&lt;MediaType&gt; requestedMediaTypes = getMediaTypes(((ServletRequestAttributes) attrs).getRequest());
      if (requestedMediaTypes != null) {
        List&lt;View&gt; candidateViews = getCandidateViews(viewName, locale, requestedMediaTypes);
        View bestView = getBestView(candidateViews, requestedMediaTypes);
        if (bestView != null) {
          return bestView;
        }
      }
      if (this.useNotAcceptableStatusCode) {
        if (logger.isDebugEnabled()) {
          logger.debug(&quot;No acceptable view found; returning 406 (Not Acceptable) status code&quot;);
        }
        return NOT_ACCEPTABLE_VIEW;
      }
      else {
        logger.debug(&quot;No acceptable view found; returning null&quot;);
        return null;
      }
    }


    protected List&lt;MediaType&gt; getMediaTypes(HttpServletRequest request) {
      if (this.favorPathExtension) {
        String requestUri = urlPathHelper.getRequestUri(request);
        String filename = WebUtils.extractFullFilenameFromUrlPath(requestUri);
        MediaType mediaType = getMediaTypeFromFilename(filename);
        if (mediaType != null) {
          if (logger.isDebugEnabled()) {
            logger.debug(&quot;Requested media type is &apos;&quot; + mediaType + &quot;&apos; (based on filename &apos;&quot; + filename + &quot;&apos;)&quot;);
          }
          return Collections.singletonList(mediaType);
        }
      }
      if (this.favorParameter) {
        if (request.getParameter(this.parameterName) != null) {
          String parameterValue = request.getParameter(this.parameterName);
          MediaType mediaType = getMediaTypeFromParameter(parameterValue);
          if (mediaType != null) {
            if (logger.isDebugEnabled()) {
              logger.debug(&quot;Requested media type is &apos;&quot; + mediaType + &quot;&apos; (based on parameter &apos;&quot; +
                  this.parameterName + &quot;&apos;=&apos;&quot; + parameterValue + &quot;&apos;)&quot;);
            }
            return Collections.singletonList(mediaType);
          }
        }
      }
      if (!this.ignoreAcceptHeader) {
        String acceptHeader = request.getHeader(ACCEPT_HEADER);
        if (StringUtils.hasText(acceptHeader)) {
          try {
                      List&lt;MediaType&gt; mediaTypes = MediaType.parseMediaTypes(acceptHeader);
                      MediaType.sortByQualityValue(mediaTypes);
                      if (logger.isDebugEnabled()) {
                          logger.debug(&quot;Requested media types are &quot; + mediaTypes + &quot; (based on Accept header)&quot;);
                      }
                      return mediaTypes;
          }
          catch (IllegalArgumentException ex) {
            if (logger.isDebugEnabled()) {
              logger.debug(&quot;Could not parse accept header [&quot; + acceptHeader + &quot;]: &quot; + ex.getMessage());
            }
            return null;
          }
        }
      }
      if (this.defaultContentType != null) {
        if (logger.isDebugEnabled()) {
          logger.debug(&quot;Requested media types is &quot; + this.defaultContentType +
              &quot; (based on defaultContentType property)&quot;);
        }
        return Collections.singletonList(this.defaultContentType);
      }
      else {
        return Collections.emptyList();
      }
    }


    protected MediaType getMediaTypeFromFilename(String filename) {
      String extension = StringUtils.getFilenameExtension(filename);
      if (!StringUtils.hasText(extension)) {
        return null;
      }
      extension = extension.toLowerCase(Locale.ENGLISH);
      MediaType mediaType = this.mediaTypes.get(extension);
      if (mediaType == null &amp;&amp; this.useJaf &amp;&amp; jafPresent) {
        mediaType = ActivationMediaTypeFactory.getMediaType(filename);
        if (mediaType != null) {
          this.mediaTypes.putIfAbsent(extension, mediaType);
        }
      }
      return mediaType;
    }


    protected MediaType getMediaTypeFromParameter(String parameterValue) {
      return this.mediaTypes.get(parameterValue.toLowerCase(Locale.ENGLISH));
    }

    private List&lt;View&gt; getCandidateViews(String viewName, Locale locale, List&lt;MediaType&gt; requestedMediaTypes)
        throws Exception {

      List&lt;View&gt; candidateViews = new ArrayList&lt;View&gt;();
      for (ViewResolver viewResolver : this.viewResolvers) {
        View view = viewResolver.resolveViewName(viewName, locale);
        if (view != null) {
          candidateViews.add(view);
        }
        for (MediaType requestedMediaType : requestedMediaTypes) {
          List&lt;String&gt; extensions = getExtensionsForMediaType(requestedMediaType);
          for (String extension : extensions) {
            String viewNameWithExtension = viewName + &quot;.&quot; + extension;
            view = viewResolver.resolveViewName(viewNameWithExtension, locale);
            if (view != null) {
              candidateViews.add(view);
            }
          }

        }
      }
      if (!CollectionUtils.isEmpty(this.defaultViews)) {
        candidateViews.addAll(this.defaultViews);
      }
      return candidateViews;
    }

    private List&lt;String&gt; getExtensionsForMediaType(MediaType requestedMediaType) {
      List&lt;String&gt; result = new ArrayList&lt;String&gt;();
      for (Entry&lt;String, MediaType&gt; entry : this.mediaTypes.entrySet()) {
        if (requestedMediaType.includes(entry.getValue())) {
          result.add(entry.getKey());
        }
      }
      return result;
    }

    private View getBestView(List&lt;View&gt; candidateViews, List&lt;MediaType&gt; requestedMediaTypes) {
      MediaType bestRequestedMediaType = null;
      View bestView = null;
      for (MediaType requestedMediaType : requestedMediaTypes) {
        for (View candidateView : candidateViews) {
          if (StringUtils.hasText(candidateView.getContentType())) {
            MediaType candidateContentType = MediaType.parseMediaType(candidateView.getContentType());
            if (requestedMediaType.includes(candidateContentType)) {
              bestRequestedMediaType = requestedMediaType;
              bestView = candidateView;
              break;
            }
          }
        }
        if (bestView != null) {
          if (logger.isDebugEnabled()) {
            logger.debug(&quot;Returning [&quot; + bestView + &quot;] based on requested media type &apos;&quot; +
                bestRequestedMediaType + &quot;&apos;&quot;);
          }
          break;
        }
      }
      return bestView;

    }

    ...

}
</code></pre><p>可以看到<code>ContentNegotiationViewResolver</code>有点类似于ComposeCommand（参见Command模式 by GoF），它本身实现了ViewResolver接口，所以它是一个ViewResolver，但是它组合了一堆的ViewResolver，根据一定的规则（前面讨论的content negotiation）将视图请求转发给最match的ViewResolver。</p>
<p>所以关键在两点：</p>
<h4 id="1-content-negotiation策略-ContentNegotiationStrategy"><a href="#1-content-negotiation策略-ContentNegotiationStrategy" class="headerlink" title="1. content negotiation策略 (ContentNegotiationStrategy)"></a>1. content negotiation策略 (<code>ContentNegotiationStrategy</code>)</h4><blockquote>
<p>This view resolver uses the requested media type to select a suitable View for a request. This media type is determined by using the following criteria:</p>
<ol>
<li>If the requested path has a file extension and if the setFavorPathExtension(boolean) property is true, the mediaTypes property is inspected for a matching media type.</li>
<li>If the request contains a parameter defining the extension and if the setFavorParameter(boolean) property is true, the mediaTypes property is inspected for a matching media type. The default name of the parameter is format and it can be configured using the parameterName property.</li>
<li>If there is no match in the mediaTypes property and if the Java Activation Framework (JAF) is both enabled and present on the classpath, FileTypeMap.getContentType(String) is used instead.</li>
<li>If the previous steps did not result in a media type, and ignoreAcceptHeader is false, the request Accept header is used.</li>
</ol>
<p>Once the requested media type has been determined, this resolver queries each delegate view resolver for a View and determines if the requested media type is compatible with the view’s content type). The most compatible view is returned.</p>
</blockquote>
<p>这个就是上面提到的Spring MVC默认的三个<code>ContentNegotiationStrategy</code>，即所谓的PPA Strategy（path extension, then parameter, then Accept header) ，顺序也是先path extension，然后parameter(默认是format参数)，然后才是accept头。</p>
<p>关于<code>ContentNegotiationStrategy</code>，可以参考笔者的另一篇文章：<a href="http://blog.arganzheng.me/posts/content-negotiation-using-spring-mvc.html" target="_blank" rel="external">content negotiation using spring mvc</a>。有具体的实际案例。</p>
<h5 id="2-供选择的SingleViewResolver"><a href="#2-供选择的SingleViewResolver" class="headerlink" title="2. 供选择的SingleViewResolver"></a>2. 供选择的SingleViewResolver</h5><blockquote>
<ol>
<li><p>The ContentNegotiatingViewResolver does not resolve views itself, but delegates to other ViewResolvers. By default, these other view resolvers are picked up automatically from the application context, though they can also be set explicitly by using the viewResolvers property. Note that in order for this view resolver to work properly, the order property needs to be set to a higher precedence than the others (the default is Ordered.HIGHEST_PRECEDENCE.)</p>
<p> 说明：即<code>private List&lt;ViewResolver&gt; viewResolvers;</code>属性。需要注意的是Spring会自动加载和注册所有其他的ViewResolver到<code>ContentNegotiationViewResolover</code>的<code>viewResolvers</code>属性。但是你需要告诉Spring MVC，你希望controller返回的view都是由<code>ContentNegotiationViewResolover</code>来解析，而不是其他定义的ViewResolver。这是通过order配置项来决定。你应该给<code>ContentNegotiationViewResolover</code>配置最高的order(其实默认就是最高了)。</p>
</li>
<li><p>Additionally, this view resolver exposes the defaultViews property, allowing you to override the views provided by the view resolvers. Note that these default views are offered as candicates, and still need have the content type requested (via file extension, parameter, or Accept header, described above). You can also set the default content type directly, which will be returned when the other mechanisms (Accept header, file extension or parameter) do not result in a match.</p>
<p> 说明：即<code>private List&lt;View&gt; defaultViews;</code>和<code>private MediaType defaultContentType;</code>属性。</p>
</li>
</ol>
</blockquote>
<p>关于<code>ContentNegotiatingViewResolver</code>，下面两篇文章都不错，值得一看：</p>
<ol>
<li><a href="http://blog.eyallupu.com/2009/07/content-negotiation-using-spring-mvcs.html" target="_blank" rel="external">Content Negotiation using Spring MVC’s ContentNegotiatingViewResolver</a>:使用了<code>viewResolvers</code>配置。</li>
<li><a href="http://blog.springsource.com/2009/03/16/adding-an-atom-view-to-an-application-using-springs-rest-support/" target="_blank" rel="external">ADDING AN ATOM VIEW TO AN APPLICATION USING SPRING’S REST SUPPORT</a>:使用了<code>ViewResolvers</code>配置。</li>
<li><a href="http://www.mkyong.com/spring-mvc/spring-3-mvc-contentnegotiatingviewresolver-example/" target="_blank" rel="external">Spring 3 MVC ContentNegotiatingViewResolver Example</a>:使用了<code>defaultViews</code>配置。</li>
</ol>
<p>注意：<code>@ResponseBody</code>是为了单个View准备的，即它只能转换成一种格式，对于<code>ContentNegotiatingViewResolver</code>，需要多个<strong>Single</strong>ViewResolver来接收。</p>
<h3 id="8-客户端调用-Accessing-RESTful-services-on-the-Client"><a href="#8-客户端调用-Accessing-RESTful-services-on-the-Client" class="headerlink" title="8. 客户端调用 Accessing RESTful services on the Client"></a>8. 客户端调用 <a href="http://static.springsource.org/spring/docs/3.0.0.M3/reference/html/ch18s03.html#rest-resttemplate" target="_blank" rel="external">Accessing RESTful services on the Client</a></h3><p>Spring MVC不仅大大的简化了服务端RESTful服务的开发和开放，还提供了一些辅助类来方便客户端调用REST服务。</p>
<p>以前Client如果要调用REST服务，一般是使用HttpClient来发送HTTP请求：</p>
<pre><code>String uri = &quot;http://example.com/hotels/1/bookings&quot;;

PostMethod post = new PostMethod(uri);
String request = // create booking request content
post.setRequestEntity(new StringRequestEntity(request));

httpClient.executeMethod(post);

if (HttpStatus.SC_CREATED == post.getStatusCode()) {
  Header location = post.getRequestHeader(&quot;Location&quot;);
  if (location != null) {
    System.out.println(&quot;Created new booking at :&quot; + location.getValue());
  }
}
</code></pre><p>太过底层，而且代码比较冗长，一般都要手动封装一下（即类似于SDK，封装了签名和HTTP发送和接受细节）。我们看一下Spring MVC是怎么解决这个问题的。</p>
<h4 id="RestTemplate"><a href="#RestTemplate" class="headerlink" title="RestTemplate"></a><a href="http://blog.springsource.org/2009/03/27/rest-in-spring-3-resttemplate/" target="_blank" rel="external">RestTemplate</a></h4><p>RestTemplate是client-site HTTP access的核心类。正如它的名称所示，<code>RestTemplate</code>非常类似于<code>JdbcTemplate</code>, <code>JmsTemplate</code>等XXXTemplate。这意味着<code>RestTemplate</code>是线程安全的并且可以通过callback来定制它的行为。</p>
<p><strong>TIPS</strong> Spring提供的Template类非常灵活和好用，种类也很丰富。当你需要做一些事情的时候可以先考虑一下有没有相应的template可以用。</p>
<p>RestTemplate默认使用<code>java.net</code>包下的基础类来创建HTTP请求。你可以实现<code>ClientHttpRequestFactory</code>接口，提供你自己的Http请求工厂类。Spring提供了<code>CommonsClientHttpRequestFactory</code>，这个工厂类使用Jakarta Commons HttpClient来创建HTTP请求。这样就可以使用HttpClient提供的认证和链接池功能了。</p>
<p><a href="http://static.springsource.org/spring/docs/3.0.x/javadoc-api/org/springframework/web/client/RestTemplate.html" target="_blank" rel="external">RestTemplate提供的方法如下</a>：</p>
<blockquote>
<p><strong>HTTP Method</strong>    <strong>RestTemplate Method</strong></p>
<ul>
<li>DELETE    delete(String url, String… urlVariables)</li>
<li>GET    getForObject(String url, Class<t> responseType, String… urlVariables)</t></li>
<li>HEAD    headForHeaders(String url, String… urlVariables)</li>
<li>OPTIONS    optionsForAllow(String url, String… urlVariables)</li>
<li>POST    postForLocation(String url, Object request, String… urlVariables)</li>
<li>PUT    put(String url, Object request, String…urlVariables)</li>
<li>ANY    exchange(String, HttpMethod, HttpEntity, Class, Object…)<pre><code>execute(String, HttpMethod, RequestCallback, ResponseExtractor, Object...)
</code></pre></li>
</ul>
</blockquote>
<p>方法名称很有规律，都是这个pattern——<code>${HTTP Method}${WhatIsReturne}</code>。例如getForObject() will perform a GET, convert the HTTP response into an object type of your choice, and returns that object. postForLocation will do a POST, converting the given object into a HTTP request, and returns the response HTTP Location header where the newly created object can be found. As you can see, these methods try to enforce REST best practices.</p>
<p>其中getForObject()、postForLocation()和put()方法接收或者返回的参数通过<code>HttpMessageConverter</code>来转换为Http Request或者Http Response。这点与前面介绍服务端RESTful的<code>@RequestBody</code>和<code>@ResponseBody</code>是一样的，Spring MVC默认会注册常用的Converter，你也可以自定义。</p>
<p>另外，每个方法的第一个参数都是一个url string，但是这个URI可以带有变量(还记得<code>@PathVariable</code>吗:)哦。参数有两种方式绑定值：</p>
<ol>
<li><p>作为字符串变量数组(String variable arguments array)</p>
<pre><code>String result = restTemplate.getForObject(&quot;http://example.com/hotels/{hotel}/bookings/{booking}&quot;, String.class, &quot;42&quot;, &quot;21&quot;);
</code></pre><p> 会转换为一个对<code>http://example.com/hotels/42/bookings/21</code>的GET请求。</p>
</li>
<li><p>或者Map对象(Map)</p>
<p>The map variant expands the template based on variable name, and is therefore more useful when using many variables, or when a single variable is used multiple times.</p>
<pre><code>Map&lt;String, String&gt; vars = new HashMap&lt;String, String&gt;();
vars.put(&quot;hotel&quot;, &quot;42&quot;);
vars.put(&quot;booking&quot;, &quot;21&quot;);
String result = restTemplate.getForObject(&quot;http://example.com/hotels/{hotel}/bookings/{booking}&quot;, String.class, vars);
会转换为一个对`http://example.com/hotels/42/rooms/42`的GET请求。
</code></pre></li>
</ol>
<p>关于RestTemplate使用的具体例子可以参考这篇文章<a href="http://blog.springsource.org/2009/03/27/rest-in-spring-3-resttemplate/" target="_blank" rel="external"><br>REST IN SPRING 3: RESTTEMPLATE</a>。写的非常好，强烈推荐！</p>
<h3 id="9-支持RESTful的URL"><a href="#9-支持RESTful的URL" class="headerlink" title="9. 支持RESTful的URL"></a>9. 支持RESTful的URL</h3><p>在开发功能模块之前，应该先把URL设计好。比查对 <strong>消息</strong> 这个资源的操作URL可以这么设计：</p>
<pre><code>http://arganzheng.me/messages/show/123456
http://arganzheng.me/messages/preview/123456
http://arganzheng.me/messages/delete/123456
http://arganzheng.me/messages/new
http://arganzheng.me/message/update
</code></pre><p>说明：可以看到我们的URL中有动作在里面，事实上纯粹的RESTful URL是把动作隐含在HTTP头中：GET、PUT、DELETE、POST。。不过这样对用户编码有要求，这个相对简单点。</p>
<p>要支持这种URL，web.xml需要这么配置：</p>
<pre><code>&lt;!-- REST servlet-mapping --&gt;
&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;DispatcherServlet&lt;srvlet-name&gt;
    &lt;url-pattern&gt;/&lt;/url-pattern&gt;
&lt;srvlet-mapping&gt;
</code></pre><p>但是这样的话有个问题，就是静态文件也被mapping了，会导致找不到资源。Spring提供了一个resources配置项支持静态文件的处理<a href="http://static.springsource.org/spring/docs/3.1.x/spring-framework-reference/html/mvc.html#mvc-config-static-resources" target="_blank" rel="external">16.14.5 Configuring Serving of Resources</a>：</p>
<pre><code>&lt;!-- Forwards requests to the &quot;/&quot; resource to the &quot;welcome&quot; view --&gt;
  &lt;mvc:view-controller path=&quot;/&quot; view-name=&quot;index&quot;/&gt;

  &lt;!-- Handles HTTP GET requests for /resources/** by efficiently serving up static resources in the ${webappRoot}/resources/ directory --&gt;
  &lt;mvc:resources mapping=&quot;/resources/**&quot; location=&quot;/resources/&quot; /&gt;
  &lt;!-- 注意：配置了mvc:resources就必须配置这个选项，否则handler mapping都失效了 
      @see  http://stackoverflow.com/questions/7910845/the-handler-mapping-from-the-mvcresource-override-other-mappings-which-defined 
  --&gt;
  &lt;mvc:annotation-driven /&gt;
</code></pre><p>这样所有请求：<code>http://arganzheng.me/resources/**</code>会映射到webapp下的resources目录，而不是找我们的controller处理。</p>
<p>但是有个奇怪的问题，就是配置这个之后，原来动态东西就不能访问到了，提示找不到对应的handler，解决方案是增加一个<code>&lt;mvc:annotation-driven /&gt;</code>配置。具体参见<a href="http://stackoverflow.com/questions/7910845/the-handler-mapping-from-the-mvcresource-override-other-mappings-which-defined" target="_blank" rel="external">The handler mapping from the mvc:resource override other mappings which defined with annotation</a>。</p>
<p>另外，静态的html页面一般不放在resources路面下，而是直接在根目录下，比如：<a href="http://arganzheng.me/index.html或者http://arganzheng.me/404.html。所以应该在web.xml中在配置一个url-mapping规则：" target="_blank" rel="external">http://arganzheng.me/index.html或者http://arganzheng.me/404.html。所以应该在web.xml中在配置一个url-mapping规则：</a></p>
<pre><code>&lt;!-- 避免被Spring DispatcherServlet接管 --&gt;
  &lt;servlet-mapping&gt;
      &lt;servlet-name&gt;default&lt;srvlet-name&gt;
      &lt;url-pattern&gt;*.html&lt;/url-pattern&gt;
  &lt;srvlet-mapping&gt;
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/blog/2015/03/26/c3p0-config/" itemprop="url">
                  关于C3P0容错和自动重连特性的研究
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-03-26T13:07:00+08:00" content="2015-03-26">
              2015-03-26
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/c3p0/" itemprop="url" rel="index">
                    <span itemprop="name">c3p0</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/blog/2015/03/26/c3p0-config/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="blog/2015/03/26/c3p0-config/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>最近常有数据库和网络设备升级和搬迁等事情，而各个应用都是基于数据库连接池做的，大部分都是基于C3P0，数据库或网络状况的变动都会导致客户端连接池中的connection失效，如何剔除这些blocked connection就和C3P0的各个配置息息相关。</p>
<p>####1）C3P0容错和自动重连与以下配置参数有关：</p>
<p><code>breakAfterAcquireFailure</code> ：true表示pool向数据库请求连接失败后标记整个pool为block并close，就算后端数据库恢复正常也不进行重连，客户端对pool的请求都拒绝掉。false表示不会标记 pool为block，新的请求都会尝试去数据库请求connection。默认为false。因此，如果想让数据库和网络故障恢复之后，pool能继续请求正常资源必须把此项配置设为false<br>
          <div class="post-more-link text-center">
            <a class="btn" href="/blog/2015/03/26/c3p0-config/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/blog/2014/11/25/better-synonym-handling-in-solr/" itemprop="url">
                  如何在Solr中更好的处理同义词
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2014-11-25T13:53:00+08:00" content="2014-11-25">
              2014-11-25
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/solr/" itemprop="url" rel="index">
                    <span itemprop="name">solr</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/blog/2014/11/25/better-synonym-handling-in-solr/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="blog/2014/11/25/better-synonym-handling-in-solr/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>当使用Solr来构建搜索引擎的时候，你可能经常会遇到这样的场景：你有一个同义词列表，并且你想用户查询也能够命中到同义词。听起来很简单不是吗？为什么搜索“dog”的时候，不能命中包含“hound(猎犬)”或者“pooch(狗)”的文档呢？甚至包含“Rover(流浪者)”和“canis familiaris(犬)”?</p>
<p><img src="/images/blog/2014/File-Licking_the_staffy_pup.JPG" alt="小狗"></p>
<p>叫Rover或者其他名字，可能只是为了让小狗听起来很可爱。</p>
<p>事实证明，Solr的同义词扩展没有你想象的那么简单。但是我们有很多好的方法来搬石头砸自己的脚。</p>
          <div class="post-more-link text-center">
            <a class="btn" href="/blog/2014/11/25/better-synonym-handling-in-solr/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/blog/2014/11/14/use-mahout-to-classify-sogou-corpus/" itemprop="url">
                  使用mahout对Sogou语料库进行分类
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2014-11-14T13:26:00+08:00" content="2014-11-14">
              2014-11-14
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/mahout/" itemprop="url" rel="index">
                    <span itemprop="name">mahout</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/blog/2014/11/14/use-mahout-to-classify-sogou-corpus/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="blog/2014/11/14/use-mahout-to-classify-sogou-corpus/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>###软件版本</p>
<ul>
<li>Ubuntu Linux</li>
<li><a href="http://mirror.bit.edu.cn/apache/mahout/0.9/mahout-distribution-0.9.tar.gz">mahout-0.9</a>,本文写作的时候的最新版本</li>
<li><a href="http://download.labs.sogou.com/dl/sogoulabdown/SogouC.reduced.20061102.tar.gz">Sogou语料库</a>精简版</li>
<li><a href="https://github.com/blueshen/ik-analyzer">ik-analyzer</a>, 这个版本是专门为了在mahout中进行分词而单独做的版本，源码从官方拿来。只更改了停用词，以及适配lucene4.6.1版本。maven化更方便使用。</li>
</ul>
<p>###Sogou语料库处理<br>下载后的预料库，文档都是GB2312编码的。虽然mahout支持不同的编码方式，但是为了更方便的放到Hadoop里跑，还是建议先转化为标准的UTF-8.<br>语料库解压后，是sogou目录。我们执行以下代码进行转化，转换后的在utf/sogou目录下：</p>
<pre><code>find sogou -type d -exec mkdir -p utf/{} \;
find sogou -type f -exec iconv -f GB2312 -t UTF-8 {} -o utf/{} \;
</code></pre><p>###使用mahout生成sequence file<br>进入utf/sogou目录，执行：</p>
<pre><code>mahout seqdirectory -i sogou -o sogou-seq -c UTF-8 -ow
</code></pre><p>生成的sequence file存放在sogou-seq目录内。<br>可以通过seqdumper命令查看：<br>
          <div class="post-more-link text-center">
            <a class="btn" href="/blog/2014/11/14/use-mahout-to-classify-sogou-corpus/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/blog/2014/11/13/encode-convert-in-linux/" itemprop="url">
                  Linux中文件编码转换
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2014-11-13T16:20:00+08:00" content="2014-11-13">
              2014-11-13
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index">
                    <span itemprop="name">linux</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/blog/2014/11/13/encode-convert-in-linux/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="blog/2014/11/13/encode-convert-in-linux/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>　在工作中，经常会遇到使用操作系统不一样的环境，从而导致在不同环境下的文件编辑的编码是不一样的，Windows默认是GBK编码格式，Linux默认是UTF-8的格式，这样就会出现把GBK编码的文件拷贝到Linux下出现乱码情况，很是让人头疼，下面给大家介绍下GBK-&gt;UTF-8文件编码批量转换。</p>
<p>Linux命令-enca 查看文件的编码</p>
<p>Enca语法</p>
<pre><code>Usage:  enca [-L LANGUAGE] [OPTION]... [FILE]...
        enconv [-L LANGUAGE] [OPTION]... [FILE]...
        Detect encoding of text files and convert them if required.
</code></pre><p>Enca用法</p>
<pre><code>$ enca -L zh_CN file 检查文件的编码
$ enca -L zh_CN -x UTF-8 file 将文件编码转换为&quot;UTF-8&quot;编码
$ enca -L zh_CN -x UTF-8 file1 file2 如果不想覆盖原文件可以这样
</code></pre><p>除了有检查文件编码的功能以外，”enca”还有一个好处就是如果文件本来就是你要转换的那种编码，它不会报错，还是会print出结果来， 而”iconv”则会报错。这对于脚本编写是比较方便的事情。<br>
          <div class="post-more-link text-center">
            <a class="btn" href="/blog/2014/11/13/encode-convert-in-linux/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/blog/2014/11/13/install-hadoop/" itemprop="url">
                  Hadoop1.2.1安装部署
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2014-11-13T13:24:00+08:00" content="2014-11-13">
              2014-11-13
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/hadoop/" itemprop="url" rel="index">
                    <span itemprop="name">hadoop</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/blog/2014/11/13/install-hadoop/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="blog/2014/11/13/install-hadoop/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>###安装需求</p>
<ul>
<li>Java 1.6</li>
<li>ssh,sshd正常安装</li>
</ul>
<p>确保可以ssh到localhost，并且不需要密码</p>
<pre><code>ssh localhost
</code></pre><p> 如果报错，connect to host localhost port 22:Connection refused。说明ssh-server未安装或者未启动。<br> 运行：  </p>
<pre><code>ps -ef | grep sshd 
</code></pre><p>查看sshd进程是否存在，如果不存在，说明没有安装。那么进行安装。</p>
<pre><code>sudo apt-get install openssh-server
</code></pre><p>然后再执行<code>ssh localhost</code>,如果不能无密码登陆，需要做一下操作：</p>
<pre><code>ssh-keygen -t dsa -P &apos;&apos; -f ~/.ssh/id_dsa 
cat ~/.ssh/id_dsa.pub &gt;&gt; ~/.ssh/authorized_keys
</code></pre>
          <div class="post-more-link text-center">
            <a class="btn" href="/blog/2014/11/13/install-hadoop/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/blog/2014/11/11/introduce-oryx/" itemprop="url">
                  oryx介绍
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2014-11-11T19:31:00+08:00" content="2014-11-11">
              2014-11-11
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/oryx/" itemprop="url" rel="index">
                    <span itemprop="name">oryx</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/blog/2014/11/11/introduce-oryx/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="blog/2014/11/11/introduce-oryx/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>Hadoop软件供应商Cloudera去年收购了一家总部位于伦敦的新兴企业<a href="https://github.com/myrrix/myrrix-recommender]">Myrrix</a>——但在此之后无论是买家还是卖家在机器学习技术方面都开始归于沉寂。不过无论如何，Myrrix公司的技术方案加上其创始人Sean Owen可能已经足以值回票价。</p>
<p>　　Owen目前的正式头衔为数据科学部门主管，目前他正专注投身于名为<a href="https://github.com/cloudera/oryx">Oryx</a>的开源机器学习项目当中。(Oryx意思是剑羚、属于非洲羚羊的一类分支，Cloudera在售的产品中则有一款名为Impala——即黑斑羚)。Oryx的开发意图在于帮助Hadoop用户构建机器学习模式并将其加以部署，这样我们就能够以实时方式查询并获取其结果——例如将其作为垃圾邮件过滤器或者推荐引擎的组成部分。在理想状态下，Oryx能够在接纳输入数据流的同时对自身进行更新。</p>
          <div class="post-more-link text-center">
            <a class="btn" href="/blog/2014/11/11/introduce-oryx/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/blog/2014/10/22/tie-breaker-in-solr/" itemprop="url">
                  solr中的tie breaker
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2014-10-22T17:14:00+08:00" content="2014-10-22">
              2014-10-22
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/solr/" itemprop="url" rel="index">
                    <span itemprop="name">solr</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/blog/2014/10/22/tie-breaker-in-solr/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="blog/2014/10/22/tie-breaker-in-solr/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>solr 查询参数中有tie这样的一个参数，下面是它的官方解释：</p>
<p><strong>The tie (Tie Breaker) Parameter</strong></p>
<p>The tie parameter specifies a float value (which should be something much less than 1) to use as tiebreaker in DisMax queries.</p>
<p>When a term from the user’s input is tested against multiple fields, more than one field may match. If so, each field will generate a different score based on how common that word is in that field (for each document relative to all other documents). The tie parameter lets you control how much the final score of the query will be influenced by the scores of the lower scoring fields compared to the highest scoring field.</p>
<p>A value of “0.0” makes the query a pure “disjunction max query”: that is, only the maximum scoring subquery contributes to the final score. A value of “1.0” makes the query a pure “disjunction sum query” where it doesn’t matter what the maximum scoring sub query is, because the final score will be the sum of the subquery scores. Typically a low value, such as 0.1, is useful.</p>
<p>读起来比较令人费解。</p>
<p>简单解释就是：</p>
<p>这个tie参数通常是一个小于1的浮点数，用于defType=disMax的solr查询。当查询命中多个field的时候，最终的score获得多少将由这个tie参数来进行调节。比如命中了field1，field2这2个field。</p>
<p>如果field1.score= 10，field2.score=3。那么 score = 10 + tie * 3.</p>
<p>也就是说，如果tie=1的话，最终的score就相当于多个字段得分总和;如果tie=0,那么最终的score就相当于是命中的field的最高分。</p>
<p>通常情况下呢，官方推荐tie=0.1。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/blog/2014/08/27/java-new-feature/" itemprop="url">
                  Java新特性
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2014-08-27T14:43:00+08:00" content="2014-08-27">
              2014-08-27
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/blog/2014/08/27/java-new-feature/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="blog/2014/08/27/java-new-feature/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>##Java7新特性</p>
<p>###Java7语法特性<br>根据JSR 334，Java7添加了数个语法方面的新特性：</p>
<p>####1. switch可以消化String</p>
<p>比如：</p>
<pre><code>public static void switchString(String s){
    switch (s){
    case &quot;db&quot;: ...
    case &quot;wls&quot;: ...
    case &quot;ibm&quot;: ...
    case &quot;soa&quot;: ...
    case &quot;fa&quot;: ...
    default: ...
    }
}
</code></pre>
          <div class="post-more-link text-center">
            <a class="btn" href="/blog/2014/08/27/java-new-feature/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="https://avatars0.githubusercontent.com/u/2255020?v=3&s=460"
               alt="shenyanchao" />
          <p class="site-author-name" itemprop="name">shenyanchao</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">106</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">35</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">191</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/blueshen" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2012 - 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">shenyanchao</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.0.1"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  

    <script type="text/javascript">
      var disqus_shortname = 'blueshen';
      var disqus_identifier = 'index.html';
      var disqus_title = '';
      var disqus_url = '';

      function run_disqus_script(disqus_script){
        var dsq = document.createElement('script');
        dsq.type = 'text/javascript';
        dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      }

      run_disqus_script('count.js');
      
    </script>
  



  
  
  

  

  
<script type="text/javascript" async src="//push.zhanzhang.baidu.com/push.js">
</script>


</body>
</html>
